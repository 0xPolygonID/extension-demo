{
  "version": 3,
  "sources": ["../../node_modules/@esbuild-plugins/node-globals-polyfill/_virtual-process-polyfill_.js", "../../node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js", "../../node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js", "node-modules-polyfills:events", "node-modules-polyfills-commonjs:events", "../../node_modules/readable-stream/lib/internal/streams/stream-browser.js", "node-modules-polyfills:buffer", "node-modules-polyfills-commonjs:buffer", "node-modules-polyfills:process", "../../node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js", "node-modules-polyfills:util", "node-modules-polyfills-commonjs:util", "../../node_modules/readable-stream/lib/internal/streams/buffer_list.js", "../../node_modules/readable-stream/lib/internal/streams/destroy.js", "../../node_modules/readable-stream/errors-browser.js", "../../node_modules/readable-stream/lib/internal/streams/state.js", "../../node_modules/inherits/inherits_browser.js", "../../node_modules/util-deprecate/browser.js", "../../node_modules/readable-stream/lib/_stream_writable.js", "../../node_modules/readable-stream/lib/_stream_duplex.js", "../../node_modules/safe-buffer/index.js", "../../node_modules/string_decoder/lib/string_decoder.js", "../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js", "../../node_modules/readable-stream/lib/internal/streams/async_iterator.js", "../../node_modules/readable-stream/lib/internal/streams/from-browser.js", "../../node_modules/readable-stream/lib/_stream_readable.js", "../../node_modules/readable-stream/lib/_stream_transform.js", "../../node_modules/readable-stream/lib/_stream_passthrough.js", "../../node_modules/readable-stream/lib/internal/streams/pipeline.js", "../../node_modules/readable-stream/readable-browser.js", "../../node_modules/blake-hash/lib/api/blake.js", "../../node_modules/blake-hash/lib/api/index.js", "../../node_modules/blake-hash/lib/blake.js", "../../node_modules/blake-hash/lib/blake256.js", "../../node_modules/blake-hash/lib/blake224.js", "../../node_modules/blake-hash/lib/blake512.js", "../../node_modules/blake-hash/lib/blake384.js", "../../node_modules/blake-hash/lib/index.js", "../../node_modules/blake-hash/js.js", "node-modules-polyfills:crypto", "../../node_modules/wasmcurves/src/utils.js", "../../node_modules/wasmcurves/src/build_int.js", "../../node_modules/wasmcurves/src/build_timesscalar.js", "../../node_modules/wasmcurves/src/build_batchinverse.js", "../../node_modules/wasmcurves/src/build_batchconvertion.js", "../../node_modules/wasmcurves/src/build_batchop.js", "../../node_modules/wasmcurves/src/bigint.js", "../../node_modules/wasmcurves/src/build_f1m.js", "../../node_modules/wasmcurves/src/build_f1.js", "../../node_modules/wasmcurves/src/build_f2m.js", "../../node_modules/wasmcurves/src/build_f3m.js", "../../node_modules/wasmcurves/src/build_timesscalarnaf.js", "../../node_modules/wasmcurves/src/build_multiexp.js", "../../node_modules/wasmcurves/src/build_curve_jacobian_a0.js", "../../node_modules/wasmcurves/src/build_fft.js", "../../node_modules/wasmcurves/src/build_pol.js", "../../node_modules/wasmcurves/src/build_qap.js", "../../node_modules/wasmcurves/src/build_applykey.js", "../../node_modules/wasmcurves/src/bn128/build_bn128.js", "../../node_modules/wasmcurves/src/bls12381/build_bls12381.js", "../../node_modules/wasmcurves/index.js", "../../node_modules/web-worker/cjs/browser.js", "../../node_modules/base64-js/index.js", "../../node_modules/ieee754/index.js", "../../node_modules/buffer/index.js", "node-modules-polyfills-commonjs:crypto", "../../node_modules/cross-sha256/index.js", "../../node_modules/base58-js/private/base58_chars.js", "../../node_modules/base58-js/public/base58_to_binary.js", "../../node_modules/base58-js/private/create_base58_map.js", "../../node_modules/base58-js/public/binary_to_base58.js", "../../node_modules/base58-js/public/index.js", "../../node_modules/rfc4648/lib/index.js", "node-modules-polyfills:fs", "../../node_modules/nanoassert/index.js", "../../node_modules/b4a/lib/ascii.js", "../../node_modules/b4a/lib/base64.js", "../../node_modules/b4a/lib/hex.js", "../../node_modules/b4a/lib/utf8.js", "../../node_modules/b4a/lib/utf16le.js", "../../node_modules/b4a/browser.js", "../../node_modules/blake2b-wasm/blake2b.js", "../../node_modules/blake2b-wasm/index.js", "node-modules-polyfills-commonjs:fs", "node-modules-polyfills:path", "node-modules-polyfills-commonjs:path", "../../node_modules/ejs/lib/utils.js", "../../node_modules/ejs/lib/ejs.js", "../../node_modules/js-sha3/src/sha3.js", "../../src/index.ts", "../../src/hash.ts", "../../node_modules/@iden3/js-iden3-core/src/index.ts", "../../node_modules/@iden3/js-iden3-core/src/claim.ts", "../../node_modules/@iden3/js-iden3-core/src/schemaHash.ts", "../../node_modules/@iden3/js-crypto/src/index.ts", "../../node_modules/@iden3/js-crypto/src/babyjub/index.ts", "../../node_modules/@iden3/js-crypto/src/babyjub/eddsa.ts", "../../node_modules/@iden3/js-crypto/src/hex.ts", "../../node_modules/@iden3/js-crypto/src/babyjub/babyjub.ts", "../../node_modules/@iden3/js-crypto/src/ff.ts", "../../node_modules/ffjavascript/main.js", "../../node_modules/ffjavascript/src/scalar.js", "../../node_modules/ffjavascript/src/polfield.js", "../../node_modules/ffjavascript/src/f1field.js", "../../node_modules/ffjavascript/src/futils.js", "../../node_modules/ffjavascript/src/fsqrt.js", "../../node_modules/ffjavascript/src/random.js", "../../node_modules/ffjavascript/src/chacha.js", "../../node_modules/ffjavascript/src/fft.js", "../../node_modules/ffjavascript/src/f2field.js", "../../node_modules/ffjavascript/src/f3field.js", "../../node_modules/ffjavascript/src/ec.js", "../../node_modules/ffjavascript/src/bn128.js", "../../node_modules/ffjavascript/src/engine.js", "../../node_modules/ffjavascript/src/wasm_field1.js", "../../node_modules/ffjavascript/src/utils.js", "../../node_modules/ffjavascript/src/engine_batchconvert.js", "../../node_modules/ffjavascript/src/bigbuffer.js", "../../node_modules/ffjavascript/src/wasm_field2.js", "../../node_modules/ffjavascript/src/wasm_field3.js", "../../node_modules/ffjavascript/src/wasm_curve.js", "../../node_modules/ffjavascript/src/threadman.js", "../../node_modules/ffjavascript/src/threadman_thread.js", "node-modules-polyfills:os", "../../node_modules/ffjavascript/src/engine_applykey.js", "../../node_modules/ffjavascript/src/engine_pairing.js", "../../node_modules/ffjavascript/src/engine_multiexp.js", "../../node_modules/ffjavascript/src/engine_fft.js", "../../node_modules/wasmbuilder/main.js", "../../node_modules/wasmbuilder/src/modulebuilder.js", "../../node_modules/wasmbuilder/src/functionbuilder.js", "../../node_modules/wasmbuilder/src/codebuilder.js", "../../node_modules/wasmbuilder/src/utils.js", "../../node_modules/wasmbuilder/src/modulebuilder_wat.js", "../../node_modules/wasmbuilder/src/functionbuilder_wat.js", "../../node_modules/wasmbuilder/src/codebuilder_wat.js", "../../node_modules/wasmbuilder/src/protoboard.js", "../../node_modules/ffjavascript/src/bls12381.js", "../../node_modules/ffjavascript/src/curves.js", "../../node_modules/@iden3/js-crypto/src/poseidon/index.ts", "../../node_modules/@iden3/js-crypto/src/poseidon/poseidon-opt.ts", "../../node_modules/@iden3/js-crypto/src/babyjub/eddsa-keys.ts", "../../node_modules/@iden3/js-iden3-core/src/constants.ts", "../../node_modules/@iden3/js-iden3-core/src/elemBytes.ts", "../../node_modules/@iden3/js-iden3-core/src/utils.ts", "../../node_modules/@iden3/js-iden3-core/src/id.ts", "../../node_modules/@iden3/js-iden3-core/src/did.ts", "../../src/jwz.ts", "../../src/proving.ts", "../../node_modules/rfc4648/lib/index.mjs", "../../src/authGroth16.ts", "../../src/common.ts", "../../src/witness_calculator.ts", "../../node_modules/snarkjs/main.js", "../../node_modules/snarkjs/src/groth16.js", "../../node_modules/snarkjs/src/groth16_fullprove.js", "../../node_modules/snarkjs/src/groth16_prove.js", "../../node_modules/@iden3/binfileutils/src/binfileutils.js", "../../node_modules/fastfile/src/fastfile.js", "../../node_modules/fastfile/src/osfile.js", "../../node_modules/fastfile/src/memfile.js", "../../node_modules/fastfile/src/bigmemfile.js", "node-modules-polyfills:constants", "../../node_modules/snarkjs/src/zkey_utils.js", "../../node_modules/snarkjs/node_modules/ffjavascript/main.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/polfield.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/f1field.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/futils.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/fsqrt.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/random.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/fft.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/f2field.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/f3field.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/ec.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/engine.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field1.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/utils.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field2.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field3.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/wasm_curve.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/threadman.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/threadman_thread.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/engine_applykey.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/engine_pairing.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/engine_multiexp.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/engine_fft.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js", "../../node_modules/snarkjs/node_modules/ffjavascript/src/curves.js", "../../node_modules/snarkjs/src/curves.js", "../../node_modules/snarkjs/src/misc.js", "node-modules-polyfills:readline", "../../node_modules/snarkjs/src/wtns_utils.js", "../../node_modules/snarkjs/src/wtns_calculate.js", "../../node_modules/circom_runtime/main.js", "../../node_modules/circom_runtime/js/witness_calculator.js", "../../node_modules/circom_runtime/js/utils.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/main.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/scalar.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/polfield.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/f1field.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/futils.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/fsqrt.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/random.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/chacha.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/fft.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/f2field.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/f3field.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/ec.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/bn128.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/engine.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/wasm_field1.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/utils.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/engine_batchconvert.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/bigbuffer.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/wasm_field2.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/wasm_field3.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/wasm_curve.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/threadman.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/threadman_thread.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/engine_applykey.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/engine_pairing.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/engine_multiexp.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/engine_fft.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/bls12381.js", "../../node_modules/circom_runtime/node_modules/ffjavascript/src/curves.js", "../../node_modules/snarkjs/src/groth16_verify.js", "../../node_modules/snarkjs/src/groth16_exportsoliditycalldata.js", "../../node_modules/snarkjs/src/powersoftau.js", "../../node_modules/snarkjs/src/powersoftau_new.js", "../../node_modules/snarkjs/src/powersoftau_utils.js", "../../node_modules/snarkjs/src/keypair.js", "../../node_modules/snarkjs/src/powersoftau_export_challenge.js", "../../node_modules/snarkjs/src/powersoftau_import.js", "../../node_modules/snarkjs/src/powersoftau_verify.js", "../../node_modules/snarkjs/src/powersoftau_challenge_contribute.js", "../../node_modules/snarkjs/src/mpc_applykey.js", "../../node_modules/snarkjs/src/powersoftau_beacon.js", "../../node_modules/snarkjs/src/powersoftau_contribute.js", "../../node_modules/snarkjs/src/powersoftau_preparephase2.js", "../../node_modules/snarkjs/src/powersoftau_truncate.js", "../../node_modules/snarkjs/src/powersoftau_convert.js", "../../node_modules/snarkjs/src/powersoftau_export_json.js", "../../node_modules/snarkjs/src/r1cs.js", "../../node_modules/snarkjs/src/r1cs_print.js", "../../node_modules/snarkjs/src/r1cs_info.js", "../../node_modules/r1csfile/src/r1csfile.js", "../../node_modules/r1csfile/node_modules/ffjavascript/main.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/scalar.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/polfield.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/f1field.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/futils.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/fsqrt.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/random.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/chacha.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/fft.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/f2field.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/f3field.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/ec.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/bn128.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/engine.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/wasm_field1.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/utils.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/engine_batchconvert.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/bigbuffer.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/wasm_field2.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/wasm_field3.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/wasm_curve.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/threadman.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/threadman_thread.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/engine_applykey.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/engine_pairing.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/engine_multiexp.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/engine_fft.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/bls12381.js", "../../node_modules/r1csfile/node_modules/ffjavascript/src/curves.js", "../../node_modules/@iden3/bigarray/src/bigarray.js", "../../node_modules/snarkjs/src/r1cs_export_json.js", "../../node_modules/snarkjs/src/wtns.js", "../../node_modules/snarkjs/src/wtns_debug.js", "../../node_modules/snarkjs/src/loadsyms.js", "../../node_modules/snarkjs/src/wtns_export_json.js", "../../node_modules/snarkjs/src/zkey.js", "../../node_modules/snarkjs/src/zkey_new.js", "../../node_modules/snarkjs/src/bigarray.js", "../../node_modules/snarkjs/src/zkey_export_bellman.js", "../../node_modules/snarkjs/src/zkey_import_bellman.js", "../../node_modules/snarkjs/src/zkey_verify_fromr1cs.js", "../../node_modules/snarkjs/src/zkey_verify_frominit.js", "../../node_modules/snarkjs/src/zkey_contribute.js", "../../node_modules/snarkjs/src/zkey_beacon.js", "../../node_modules/snarkjs/src/zkey_export_json.js", "../../node_modules/snarkjs/src/zkey_bellman_contribute.js", "../../node_modules/snarkjs/src/zkey_export_verificationkey.js", "../../node_modules/snarkjs/src/zkey_export_solidityverifier.js", "../../node_modules/snarkjs/src/plonk.js", "../../node_modules/snarkjs/src/plonk_setup.js", "../../node_modules/snarkjs/src/plonk_fullprove.js", "../../node_modules/snarkjs/src/plonk_prove.js", "../../node_modules/snarkjs/src/plonk_verify.js", "../../node_modules/snarkjs/src/plonk_exportsoliditycalldata.js", "../../src/authV2Groth16.ts", "../../node_modules/@iden3/js-merkletree/src/index.ts", "../../node_modules/@iden3/js-merkletree/src/constants/index.ts", "../../node_modules/@iden3/js-merkletree/src/constants/hash.ts", "../../node_modules/@iden3/js-merkletree/src/constants/node.ts", "../../node_modules/@iden3/js-merkletree/src/constants/data.ts", "../../node_modules/@iden3/js-merkletree/src/constants/proof.ts", "../../node_modules/@iden3/js-merkletree/src/constants/field.ts", "../../node_modules/@iden3/js-merkletree/src/lib/index.ts", "../../node_modules/@iden3/js-merkletree/src/lib/db/index.ts", "../../node_modules/@iden3/js-merkletree/src/lib/db/inMemory.ts", "../../node_modules/@iden3/js-merkletree/src/lib/hash/hash.ts", "../../node_modules/@iden3/js-merkletree/src/lib/utils/index.ts", "../../node_modules/@iden3/js-merkletree/src/lib/utils/bytes.ts", "../../node_modules/@iden3/js-merkletree/src/lib/utils/crypto.ts", "../../node_modules/@iden3/js-merkletree/src/lib/utils/hash.ts", "../../node_modules/@iden3/js-merkletree/src/lib/utils/bigint.ts", "../../node_modules/@iden3/js-merkletree/src/lib/utils/poseidon.ts", "../../node_modules/@iden3/js-merkletree/src/lib/utils/entry.ts", "../../node_modules/@iden3/js-merkletree/src/lib/utils/circom.ts", "../../node_modules/@iden3/js-merkletree/src/lib/utils/merkletree.ts", "../../node_modules/@iden3/js-merkletree/src/lib/utils/proof.ts", "../../node_modules/@iden3/js-merkletree/src/lib/utils/node.ts", "../../node_modules/@iden3/js-merkletree/src/lib/errors/proof.ts", "../../node_modules/@iden3/js-merkletree/src/lib/db/localStorage.ts", "../../node_modules/@iden3/js-merkletree/src/lib/entry/index.ts", "../../node_modules/@iden3/js-merkletree/src/lib/errors/index.ts", "../../node_modules/@iden3/js-merkletree/src/lib/errors/merkletree.ts", "../../node_modules/@iden3/js-merkletree/src/lib/errors/db.ts", "../../node_modules/@iden3/js-merkletree/src/lib/merkletree/index.ts", "../../node_modules/@iden3/js-merkletree/src/lib/merkletree/circom.ts", "../../node_modules/@iden3/js-merkletree/src/lib/merkletree/proof.ts", "../../node_modules/@iden3/js-merkletree/src/types/index.ts", "../../node_modules/@iden3/js-merkletree/dist/esm/types/hash.js", "../../node_modules/@iden3/js-merkletree/dist/esm/types/node.js", "../../node_modules/@iden3/js-merkletree/dist/esm/types/bytes.js", "../../node_modules/@iden3/js-merkletree/dist/esm/types/storage.js", "../../node_modules/@iden3/js-merkletree/dist/esm/types/merkletree.js"],
  "sourcesContent": ["// shim for using process in browser\n// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined')\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined')\n}\nvar cachedSetTimeout = defaultSetTimout\nvar cachedClearTimeout = defaultClearTimeout\nif (typeof global.setTimeout === 'function') {\n    cachedSetTimeout = setTimeout\n}\nif (typeof global.clearTimeout === 'function') {\n    cachedClearTimeout = clearTimeout\n}\n\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0)\n    }\n    // if setTimeout wasn't available but was latter defined\n    if (\n        (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&\n        setTimeout\n    ) {\n        cachedSetTimeout = setTimeout\n        return setTimeout(fun, 0)\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0)\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0)\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0)\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker)\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if (\n        (cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &&\n        clearTimeout\n    ) {\n        cachedClearTimeout = clearTimeout\n        return clearTimeout(marker)\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker)\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker)\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker)\n        }\n    }\n}\nvar queue = []\nvar draining = false\nvar currentQueue\nvar queueIndex = -1\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return\n    }\n    draining = false\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue)\n    } else {\n        queueIndex = -1\n    }\n    if (queue.length) {\n        drainQueue()\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return\n    }\n    var timeout = runTimeout(cleanUpNextTick)\n    draining = true\n\n    var len = queue.length\n    while (len) {\n        currentQueue = queue\n        queue = []\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run()\n            }\n        }\n        queueIndex = -1\n        len = queue.length\n    }\n    currentQueue = null\n    draining = false\n    runClearTimeout(timeout)\n}\nfunction nextTick(fun) {\n    var args = new Array(arguments.length - 1)\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i]\n        }\n    }\n    queue.push(new Item(fun, args))\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue)\n    }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun\n    this.array = array\n}\nItem.prototype.run = function() {\n    this.fun.apply(null, this.array)\n}\nvar title = 'browser'\nvar platform = 'browser'\nvar browser = true\nvar env = {}\nvar argv = []\nvar version = '' // empty string to avoid regexp issues\nvar versions = {}\nvar release = {}\nvar config = {}\n\nfunction noop() {}\n\nvar on = noop\nvar addListener = noop\nvar once = noop\nvar off = noop\nvar removeListener = noop\nvar removeAllListeners = noop\nvar emit = noop\n\nfunction binding(name) {\n    throw new Error('process.binding is not supported')\n}\n\nfunction cwd() {\n    return '/'\n}\nfunction chdir(dir) {\n    throw new Error('process.chdir is not supported')\n}\nfunction umask() {\n    return 0\n}\n\n// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\nvar performance = global.performance || {}\nvar performanceNow =\n    performance.now ||\n    performance.mozNow ||\n    performance.msNow ||\n    performance.oNow ||\n    performance.webkitNow ||\n    function() {\n        return new Date().getTime()\n    }\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nfunction hrtime(previousTimestamp) {\n    var clocktime = performanceNow.call(performance) * 1e-3\n    var seconds = Math.floor(clocktime)\n    var nanoseconds = Math.floor((clocktime % 1) * 1e9)\n    if (previousTimestamp) {\n        seconds = seconds - previousTimestamp[0]\n        nanoseconds = nanoseconds - previousTimestamp[1]\n        if (nanoseconds < 0) {\n            seconds--\n            nanoseconds += 1e9\n        }\n    }\n    return [seconds, nanoseconds]\n}\n\nvar startTime = new Date()\nfunction uptime() {\n    var currentTime = new Date()\n    var dif = currentTime - startTime\n    return dif / 1000\n}\n\nexport var process = {\n    nextTick: nextTick,\n    title: title,\n    browser: browser,\n    env: env,\n    argv: argv,\n    version: version,\n    versions: versions,\n    on: on,\n    addListener: addListener,\n    once: once,\n    off: off,\n    removeListener: removeListener,\n    removeAllListeners: removeAllListeners,\n    emit: emit,\n    binding: binding,\n    cwd: cwd,\n    chdir: chdir,\n    umask: umask,\n    hrtime: hrtime,\n    platform: platform,\n    release: release,\n    config: config,\n    uptime: uptime,\n}\n\n// replace process.env.VAR with define\n\nconst defines = {\n\n}\nObject.keys(defines).forEach((key) => {\n    const segs = key.split('.')\n    let target = process\n    for (let i = 0; i < segs.length; i++) {\n        const seg = segs[i]\n        if (i === segs.length - 1) {\n            target[seg] = defines[key]\n        } else {\n            target = target[seg] || (target[seg] = {})\n        }\n    }\n})\n", "// taken from https://github.com/calvinmetcalf/buffer-es6\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\nvar inited = false\nfunction init() {\n    inited = true\n    var code =\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n    for (var i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i]\n        revLookup[code.charCodeAt(i)] = i\n    }\n\n    revLookup['-'.charCodeAt(0)] = 62\n    revLookup['_'.charCodeAt(0)] = 63\n}\n\nfunction base64toByteArray(b64) {\n    if (!inited) {\n        init()\n    }\n    var i, j, l, tmp, placeHolders, arr\n    var len = b64.length\n\n    if (len % 4 > 0) {\n        throw new Error('Invalid string. Length must be a multiple of 4')\n    }\n\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr((len * 3) / 4 - placeHolders)\n\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? len - 4 : len\n\n    var L = 0\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 18) |\n            (revLookup[b64.charCodeAt(i + 1)] << 12) |\n            (revLookup[b64.charCodeAt(i + 2)] << 6) |\n            revLookup[b64.charCodeAt(i + 3)]\n        arr[L++] = (tmp >> 16) & 0xff\n        arr[L++] = (tmp >> 8) & 0xff\n        arr[L++] = tmp & 0xff\n    }\n\n    if (placeHolders === 2) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 2) |\n            (revLookup[b64.charCodeAt(i + 1)] >> 4)\n        arr[L++] = tmp & 0xff\n    } else if (placeHolders === 1) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 10) |\n            (revLookup[b64.charCodeAt(i + 1)] << 4) |\n            (revLookup[b64.charCodeAt(i + 2)] >> 2)\n        arr[L++] = (tmp >> 8) & 0xff\n        arr[L++] = tmp & 0xff\n    }\n\n    return arr\n}\n\nfunction tripletToBase64(num) {\n    return (\n        lookup[(num >> 18) & 0x3f] +\n        lookup[(num >> 12) & 0x3f] +\n        lookup[(num >> 6) & 0x3f] +\n        lookup[num & 0x3f]\n    )\n}\n\nfunction encodeChunk(uint8, start, end) {\n    var tmp\n    var output = []\n    for (var i = start; i < end; i += 3) {\n        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2]\n        output.push(tripletToBase64(tmp))\n    }\n    return output.join('')\n}\n\nfunction base64fromByteArray(uint8) {\n    if (!inited) {\n        init()\n    }\n    var tmp\n    var len = uint8.length\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n    var output = ''\n    var parts = []\n    var maxChunkLength = 16383 // must be multiple of 3\n\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n        parts.push(\n            encodeChunk(\n                uint8,\n                i,\n                i + maxChunkLength > len2 ? len2 : i + maxChunkLength,\n            ),\n        )\n    }\n\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1]\n        output += lookup[tmp >> 2]\n        output += lookup[(tmp << 4) & 0x3f]\n        output += '=='\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n        output += lookup[tmp >> 10]\n        output += lookup[(tmp >> 4) & 0x3f]\n        output += lookup[(tmp << 2) & 0x3f]\n        output += '='\n    }\n\n    parts.push(output)\n\n    return parts.join('')\n}\n\nvar INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT =\n    global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : true\n\nfunction kMaxLength() {\n    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff\n}\n\nfunction createBuffer(that, length) {\n    if (kMaxLength() < length) {\n        throw new RangeError('Invalid typed array length')\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = new Uint8Array(length)\n        that.__proto__ = Buffer.prototype\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        if (that === null) {\n            that = new Buffer(length)\n        }\n        that.length = length\n    }\n\n    return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nexport function Buffer(arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, encodingOrOffset, length)\n    }\n\n    // Common case.\n    if (typeof arg === 'number') {\n        if (typeof encodingOrOffset === 'string') {\n            throw new Error(\n                'If encoding is specified then the first argument must be a string',\n            )\n        }\n        return allocUnsafe(this, arg)\n    }\n    return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function(arr) {\n    arr.__proto__ = Buffer.prototype\n    return arr\n}\n\nfunction from(that, value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n        throw new TypeError('\"value\" argument must not be a number')\n    }\n\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length)\n    }\n\n    if (typeof value === 'string') {\n        return fromString(that, value, encodingOrOffset)\n    }\n\n    return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function(value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length)\n}\n\nBuffer.kMaxLength = kMaxLength()\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype\n    Buffer.__proto__ = Uint8Array\n    if (\n        typeof Symbol !== 'undefined' &&\n        Symbol.species &&\n        Buffer[Symbol.species] === Buffer\n    ) {\n        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n        // Object.defineProperty(Buffer, Symbol.species, {\n        //   value: null,\n        //   configurable: true\n        // })\n    }\n}\n\nfunction assertSize(size) {\n    if (typeof size !== 'number') {\n        throw new TypeError('\"size\" argument must be a number')\n    } else if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative')\n    }\n}\n\nfunction alloc(that, size, fill, encoding) {\n    assertSize(size)\n    if (size <= 0) {\n        return createBuffer(that, size)\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === 'string'\n            ? createBuffer(that, size).fill(fill, encoding)\n            : createBuffer(that, size).fill(fill)\n    }\n    return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function(size, fill, encoding) {\n    return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe(that, size) {\n    assertSize(size)\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n            that[i] = 0\n        }\n    }\n    return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function(size) {\n    return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function(size) {\n    return allocUnsafe(null, size)\n}\n\nfunction fromString(that, string, encoding) {\n    if (typeof encoding !== 'string' || encoding === '') {\n        encoding = 'utf8'\n    }\n\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding')\n    }\n\n    var length = byteLength(string, encoding) | 0\n    that = createBuffer(that, length)\n\n    var actual = that.write(string, encoding)\n\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        that = that.slice(0, actual)\n    }\n\n    return that\n}\n\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0\n    that = createBuffer(that, length)\n    for (var i = 0; i < length; i += 1) {\n        that[i] = array[i] & 255\n    }\n    return that\n}\n\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\")\n    }\n\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\")\n    }\n\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array)\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset)\n    } else {\n        array = new Uint8Array(array, byteOffset, length)\n    }\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = array\n        that.__proto__ = Buffer.prototype\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        that = fromArrayLike(that, array)\n    }\n    return that\n}\n\nfunction fromObject(that, obj) {\n    if (internalIsBuffer(obj)) {\n        var len = checked(obj.length) | 0\n        that = createBuffer(that, len)\n\n        if (that.length === 0) {\n            return that\n        }\n\n        obj.copy(that, 0, 0, len)\n        return that\n    }\n\n    if (obj) {\n        if (\n            (typeof ArrayBuffer !== 'undefined' &&\n                obj.buffer instanceof ArrayBuffer) ||\n            'length' in obj\n        ) {\n            if (typeof obj.length !== 'number' || isnan(obj.length)) {\n                return createBuffer(that, 0)\n            }\n            return fromArrayLike(that, obj)\n        }\n\n        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n            return fromArrayLike(that, obj.data)\n        }\n    }\n\n    throw new TypeError(\n        'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.',\n    )\n}\n\nfunction checked(length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n        throw new RangeError(\n            'Attempt to allocate Buffer larger than maximum ' +\n                'size: 0x' +\n                kMaxLength().toString(16) +\n                ' bytes',\n        )\n    }\n    return length | 0\n}\n\nexport function SlowBuffer(length) {\n    if (+length != length) {\n        // eslint-disable-line eqeqeq\n        length = 0\n    }\n    return Buffer.alloc(+length)\n}\nBuffer.isBuffer = isBuffer\nfunction internalIsBuffer(b) {\n    return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare(a, b) {\n    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n        throw new TypeError('Arguments must be Buffers')\n    }\n\n    if (a === b) return 0\n\n    var x = a.length\n    var y = b.length\n\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n            x = a[i]\n            y = b[i]\n            break\n        }\n    }\n\n    if (x < y) return -1\n    if (y < x) return 1\n    return 0\n}\n\nBuffer.isEncoding = function isEncoding(encoding) {\n    switch (String(encoding).toLowerCase()) {\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return true\n        default:\n            return false\n    }\n}\n\nBuffer.concat = function concat(list, length) {\n    if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n\n    if (list.length === 0) {\n        return Buffer.alloc(0)\n    }\n\n    var i\n    if (length === undefined) {\n        length = 0\n        for (i = 0; i < list.length; ++i) {\n            length += list[i].length\n        }\n    }\n\n    var buffer = Buffer.allocUnsafe(length)\n    var pos = 0\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i]\n        if (!internalIsBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers')\n        }\n        buf.copy(buffer, pos)\n        pos += buf.length\n    }\n    return buffer\n}\n\nfunction byteLength(string, encoding) {\n    if (internalIsBuffer(string)) {\n        return string.length\n    }\n    if (\n        typeof ArrayBuffer !== 'undefined' &&\n        typeof ArrayBuffer.isView === 'function' &&\n        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)\n    ) {\n        return string.byteLength\n    }\n    if (typeof string !== 'string') {\n        string = '' + string\n    }\n\n    var len = string.length\n    if (len === 0) return 0\n\n    // Use a for loop to avoid recursion\n    var loweredCase = false\n    for (;;) {\n        switch (encoding) {\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n                return len\n            case 'utf8':\n            case 'utf-8':\n            case undefined:\n                return utf8ToBytes(string).length\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return len * 2\n            case 'hex':\n                return len >>> 1\n            case 'base64':\n                return base64ToBytes(string).length\n            default:\n                if (loweredCase) return utf8ToBytes(string).length // assume utf8\n                encoding = ('' + encoding).toLowerCase()\n                loweredCase = true\n        }\n    }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString(encoding, start, end) {\n    var loweredCase = false\n\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n        start = 0\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n        return ''\n    }\n\n    if (end === undefined || end > this.length) {\n        end = this.length\n    }\n\n    if (end <= 0) {\n        return ''\n    }\n\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0\n    start >>>= 0\n\n    if (end <= start) {\n        return ''\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    while (true) {\n        switch (encoding) {\n            case 'hex':\n                return hexSlice(this, start, end)\n\n            case 'utf8':\n            case 'utf-8':\n                return utf8Slice(this, start, end)\n\n            case 'ascii':\n                return asciiSlice(this, start, end)\n\n            case 'latin1':\n            case 'binary':\n                return latin1Slice(this, start, end)\n\n            case 'base64':\n                return base64Slice(this, start, end)\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return utf16leSlice(this, start, end)\n\n            default:\n                if (loweredCase)\n                    throw new TypeError('Unknown encoding: ' + encoding)\n                encoding = (encoding + '').toLowerCase()\n                loweredCase = true\n        }\n    }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap(b, n, m) {\n    var i = b[n]\n    b[n] = b[m]\n    b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16() {\n    var len = this.length\n    if (len % 2 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 16-bits')\n    }\n    for (var i = 0; i < len; i += 2) {\n        swap(this, i, i + 1)\n    }\n    return this\n}\n\nBuffer.prototype.swap32 = function swap32() {\n    var len = this.length\n    if (len % 4 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 32-bits')\n    }\n    for (var i = 0; i < len; i += 4) {\n        swap(this, i, i + 3)\n        swap(this, i + 1, i + 2)\n    }\n    return this\n}\n\nBuffer.prototype.swap64 = function swap64() {\n    var len = this.length\n    if (len % 8 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 64-bits')\n    }\n    for (var i = 0; i < len; i += 8) {\n        swap(this, i, i + 7)\n        swap(this, i + 1, i + 6)\n        swap(this, i + 2, i + 5)\n        swap(this, i + 3, i + 4)\n    }\n    return this\n}\n\nBuffer.prototype.toString = function toString() {\n    var length = this.length | 0\n    if (length === 0) return ''\n    if (arguments.length === 0) return utf8Slice(this, 0, length)\n    return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals(b) {\n    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n    if (this === b) return true\n    return Buffer.compare(this, b) === 0\n}\n\n\nBuffer.prototype.compare = function compare(\n    target,\n    start,\n    end,\n    thisStart,\n    thisEnd,\n) {\n    if (!internalIsBuffer(target)) {\n        throw new TypeError('Argument must be a Buffer')\n    }\n\n    if (start === undefined) {\n        start = 0\n    }\n    if (end === undefined) {\n        end = target ? target.length : 0\n    }\n    if (thisStart === undefined) {\n        thisStart = 0\n    }\n    if (thisEnd === undefined) {\n        thisEnd = this.length\n    }\n\n    if (\n        start < 0 ||\n        end > target.length ||\n        thisStart < 0 ||\n        thisEnd > this.length\n    ) {\n        throw new RangeError('out of range index')\n    }\n\n    if (thisStart >= thisEnd && start >= end) {\n        return 0\n    }\n    if (thisStart >= thisEnd) {\n        return -1\n    }\n    if (start >= end) {\n        return 1\n    }\n\n    start >>>= 0\n    end >>>= 0\n    thisStart >>>= 0\n    thisEnd >>>= 0\n\n    if (this === target) return 0\n\n    var x = thisEnd - thisStart\n    var y = end - start\n    var len = Math.min(x, y)\n\n    var thisCopy = this.slice(thisStart, thisEnd)\n    var targetCopy = target.slice(start, end)\n\n    for (var i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i]\n            y = targetCopy[i]\n            break\n        }\n    }\n\n    if (x < y) return -1\n    if (y < x) return 1\n    return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1\n\n    // Normalize byteOffset\n    if (typeof byteOffset === 'string') {\n        encoding = byteOffset\n        byteOffset = 0\n    } else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff\n    } else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000\n    }\n    byteOffset = +byteOffset // Coerce to Number.\n    if (isNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : buffer.length - 1\n    }\n\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1\n        else byteOffset = buffer.length - 1\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0\n        else return -1\n    }\n\n    // Normalize val\n    if (typeof val === 'string') {\n        val = Buffer.from(val, encoding)\n    }\n\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (internalIsBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n    } else if (typeof val === 'number') {\n        val = val & 0xff // Search for a byte value [0-255]\n        if (\n            Buffer.TYPED_ARRAY_SUPPORT &&\n            typeof Uint8Array.prototype.indexOf === 'function'\n        ) {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(\n                    buffer,\n                    val,\n                    byteOffset,\n                )\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(\n                    buffer,\n                    val,\n                    byteOffset,\n                )\n            }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n    }\n\n    throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1\n    var arrLength = arr.length\n    var valLength = val.length\n\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase()\n        if (\n            encoding === 'ucs2' ||\n            encoding === 'ucs-2' ||\n            encoding === 'utf16le' ||\n            encoding === 'utf-16le'\n        ) {\n            if (arr.length < 2 || val.length < 2) {\n                return -1\n            }\n            indexSize = 2\n            arrLength /= 2\n            valLength /= 2\n            byteOffset /= 2\n        }\n    }\n\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i]\n        } else {\n            return buf.readUInt16BE(i * indexSize)\n        }\n    }\n\n    var i\n    if (dir) {\n        var foundIndex = -1\n        for (i = byteOffset; i < arrLength; i++) {\n            if (\n                read(arr, i) ===\n                read(val, foundIndex === -1 ? 0 : i - foundIndex)\n            ) {\n                if (foundIndex === -1) foundIndex = i\n                if (i - foundIndex + 1 === valLength)\n                    return foundIndex * indexSize\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex\n                foundIndex = -1\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength\n        for (i = byteOffset; i >= 0; i--) {\n            var found = true\n            for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false\n                    break\n                }\n            }\n            if (found) return i\n        }\n    }\n\n    return -1\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0\n    var remaining = buf.length - offset\n    if (!length) {\n        length = remaining\n    } else {\n        length = Number(length)\n        if (length > remaining) {\n            length = remaining\n        }\n    }\n\n    // must be an even number of digits\n    var strLen = string.length\n    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n    if (length > strLen / 2) {\n        length = strLen / 2\n    }\n    for (var i = 0; i < length; ++i) {\n        var parsed = parseInt(string.substr(i * 2, 2), 16)\n        if (isNaN(parsed)) return i\n        buf[offset + i] = parsed\n    }\n    return i\n}\n\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(\n        utf8ToBytes(string, buf.length - offset),\n        buf,\n        offset,\n        length,\n    )\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write(buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(\n        utf16leToBytes(string, buf.length - offset),\n        buf,\n        offset,\n        length,\n    )\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = 'utf8'\n        length = this.length\n        offset = 0\n        // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === 'string') {\n        encoding = offset\n        length = this.length\n        offset = 0\n        // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset | 0\n        if (isFinite(length)) {\n            length = length | 0\n            if (encoding === undefined) encoding = 'utf8'\n        } else {\n            encoding = length\n            length = undefined\n        }\n        // legacy write(string, encoding, offset, length) - remove in v0.13\n    } else {\n        throw new Error(\n            'Buffer.write(string, encoding, offset[, length]) is no longer supported',\n        )\n    }\n\n    var remaining = this.length - offset\n    if (length === undefined || length > remaining) length = remaining\n\n    if (\n        (string.length > 0 && (length < 0 || offset < 0)) ||\n        offset > this.length\n    ) {\n        throw new RangeError('Attempt to write outside buffer bounds')\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    var loweredCase = false\n    for (;;) {\n        switch (encoding) {\n            case 'hex':\n                return hexWrite(this, string, offset, length)\n\n            case 'utf8':\n            case 'utf-8':\n                return utf8Write(this, string, offset, length)\n\n            case 'ascii':\n                return asciiWrite(this, string, offset, length)\n\n            case 'latin1':\n            case 'binary':\n                return latin1Write(this, string, offset, length)\n\n            case 'base64':\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length)\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return ucs2Write(this, string, offset, length)\n\n            default:\n                if (loweredCase)\n                    throw new TypeError('Unknown encoding: ' + encoding)\n                encoding = ('' + encoding).toLowerCase()\n                loweredCase = true\n        }\n    }\n}\n\nBuffer.prototype.toJSON = function toJSON() {\n    return {\n        type: 'Buffer',\n        data: Array.prototype.slice.call(this._arr || this, 0),\n    }\n}\n\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return base64fromByteArray(buf)\n    } else {\n        return base64fromByteArray(buf.slice(start, end))\n    }\n}\n\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end)\n    var res = []\n\n    var i = start\n    while (i < end) {\n        var firstByte = buf[i]\n        var codePoint = null\n        var bytesPerSequence =\n            firstByte > 0xef\n                ? 4\n                : firstByte > 0xdf\n                ? 3\n                : firstByte > 0xbf\n                ? 2\n                : 1\n\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint\n\n            switch (bytesPerSequence) {\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte\n                    }\n                    break\n                case 2:\n                    secondByte = buf[i + 1]\n                    if ((secondByte & 0xc0) === 0x80) {\n                        tempCodePoint =\n                            ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f)\n                        if (tempCodePoint > 0x7f) {\n                            codePoint = tempCodePoint\n                        }\n                    }\n                    break\n                case 3:\n                    secondByte = buf[i + 1]\n                    thirdByte = buf[i + 2]\n                    if (\n                        (secondByte & 0xc0) === 0x80 &&\n                        (thirdByte & 0xc0) === 0x80\n                    ) {\n                        tempCodePoint =\n                            ((firstByte & 0xf) << 0xc) |\n                            ((secondByte & 0x3f) << 0x6) |\n                            (thirdByte & 0x3f)\n                        if (\n                            tempCodePoint > 0x7ff &&\n                            (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)\n                        ) {\n                            codePoint = tempCodePoint\n                        }\n                    }\n                    break\n                case 4:\n                    secondByte = buf[i + 1]\n                    thirdByte = buf[i + 2]\n                    fourthByte = buf[i + 3]\n                    if (\n                        (secondByte & 0xc0) === 0x80 &&\n                        (thirdByte & 0xc0) === 0x80 &&\n                        (fourthByte & 0xc0) === 0x80\n                    ) {\n                        tempCodePoint =\n                            ((firstByte & 0xf) << 0x12) |\n                            ((secondByte & 0x3f) << 0xc) |\n                            ((thirdByte & 0x3f) << 0x6) |\n                            (fourthByte & 0x3f)\n                        if (\n                            tempCodePoint > 0xffff &&\n                            tempCodePoint < 0x110000\n                        ) {\n                            codePoint = tempCodePoint\n                        }\n                    }\n            }\n        }\n\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xfffd\n            bytesPerSequence = 1\n        } else if (codePoint > 0xffff) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000\n            res.push(((codePoint >>> 10) & 0x3ff) | 0xd800)\n            codePoint = 0xdc00 | (codePoint & 0x3ff)\n        }\n\n        res.push(codePoint)\n        i += bytesPerSequence\n    }\n\n    return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray(codePoints) {\n    var len = codePoints.length\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n    }\n\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    var res = ''\n    var i = 0\n    while (i < len) {\n        res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)),\n        )\n    }\n    return res\n}\n\nfunction asciiSlice(buf, start, end) {\n    var ret = ''\n    end = Math.min(buf.length, end)\n\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 0x7f)\n    }\n    return ret\n}\n\nfunction latin1Slice(buf, start, end) {\n    var ret = ''\n    end = Math.min(buf.length, end)\n\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i])\n    }\n    return ret\n}\n\nfunction hexSlice(buf, start, end) {\n    var len = buf.length\n\n    if (!start || start < 0) start = 0\n    if (!end || end < 0 || end > len) end = len\n\n    var out = ''\n    for (var i = start; i < end; ++i) {\n        out += toHex(buf[i])\n    }\n    return out\n}\n\nfunction utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end)\n    var res = ''\n    for (var i = 0; i < bytes.length; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n    }\n    return res\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length\n    start = ~~start\n    end = end === undefined ? len : ~~end\n\n    if (start < 0) {\n        start += len\n        if (start < 0) start = 0\n    } else if (start > len) {\n        start = len\n    }\n\n    if (end < 0) {\n        end += len\n        if (end < 0) end = 0\n    } else if (end > len) {\n        end = len\n    }\n\n    if (end < start) end = start\n\n    var newBuf\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end)\n        newBuf.__proto__ = Buffer.prototype\n    } else {\n        var sliceLen = end - start\n        newBuf = new Buffer(sliceLen, undefined)\n        for (var i = 0; i < sliceLen; ++i) {\n            newBuf[i] = this[i + start]\n        }\n    }\n\n    return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0)\n        throw new RangeError('offset is not uint')\n    if (offset + ext > length)\n        throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE(\n    offset,\n    byteLength,\n    noAssert,\n) {\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n    var val = this[offset]\n    var mul = 1\n    var i = 0\n    while (++i < byteLength && (mul *= 0x100)) {\n        val += this[offset + i] * mul\n    }\n\n    return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE(\n    offset,\n    byteLength,\n    noAssert,\n) {\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) {\n        checkOffset(offset, byteLength, this.length)\n    }\n\n    var val = this[offset + --byteLength]\n    var mul = 1\n    while (byteLength > 0 && (mul *= 0x100)) {\n        val += this[offset + --byteLength] * mul\n    }\n\n    return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length)\n    return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length)\n    return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length)\n    return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n\n    return (\n        (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) +\n        this[offset + 3] * 0x1000000\n    )\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n\n    return (\n        this[offset] * 0x1000000 +\n        ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3])\n    )\n}\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n    var val = this[offset]\n    var mul = 1\n    var i = 0\n    while (++i < byteLength && (mul *= 0x100)) {\n        val += this[offset + i] * mul\n    }\n    mul *= 0x80\n\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n    return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n    var i = byteLength\n    var mul = 1\n    var val = this[offset + --i]\n    while (i > 0 && (mul *= 0x100)) {\n        val += this[offset + --i] * mul\n    }\n    mul *= 0x80\n\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n    return val\n}\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length)\n    if (!(this[offset] & 0x80)) return this[offset]\n    return (0xff - this[offset] + 1) * -1\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length)\n    var val = this[offset] | (this[offset + 1] << 8)\n    return val & 0x8000 ? val | 0xffff0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length)\n    var val = this[offset + 1] | (this[offset] << 8)\n    return val & 0x8000 ? val | 0xffff0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n\n    return (\n        this[offset] |\n        (this[offset + 1] << 8) |\n        (this[offset + 2] << 16) |\n        (this[offset + 3] << 24)\n    )\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n\n    return (\n        (this[offset] << 24) |\n        (this[offset + 1] << 16) |\n        (this[offset + 2] << 8) |\n        this[offset + 3]\n    )\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n    return ieee754read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n    return ieee754read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length)\n    return ieee754read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length)\n    return ieee754read(this, offset, false, 52, 8)\n}\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!internalIsBuffer(buf))\n        throw new TypeError('\"buffer\" argument must be a Buffer instance')\n    if (value > max || value < min)\n        throw new RangeError('\"value\" argument is out of bounds')\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE(\n    value,\n    offset,\n    byteLength,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1\n        checkInt(this, value, offset, byteLength, maxBytes, 0)\n    }\n\n    var mul = 1\n    var i = 0\n    this[offset] = value & 0xff\n    while (++i < byteLength && (mul *= 0x100)) {\n        this[offset + i] = (value / mul) & 0xff\n    }\n\n    return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE(\n    value,\n    offset,\n    byteLength,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1\n        checkInt(this, value, offset, byteLength, maxBytes, 0)\n    }\n\n    var i = byteLength - 1\n    var mul = 1\n    this[offset + i] = value & 0xff\n    while (--i >= 0 && (mul *= 0x100)) {\n        this[offset + i] = (value / mul) & 0xff\n    }\n\n    return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n    this[offset] = value & 0xff\n    return offset + 1\n}\n\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffff + value + 1\n    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n        buf[offset + i] =\n            (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            ((littleEndian ? i : 1 - i) * 8)\n    }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(\n    value,\n    offset,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff\n        this[offset + 1] = value >>> 8\n    } else {\n        objectWriteUInt16(this, value, offset, true)\n    }\n    return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(\n    value,\n    offset,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8\n        this[offset + 1] = value & 0xff\n    } else {\n        objectWriteUInt16(this, value, offset, false)\n    }\n    return offset + 2\n}\n\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffffffff + value + 1\n    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n        buf[offset + i] = (value >>> ((littleEndian ? i : 3 - i) * 8)) & 0xff\n    }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(\n    value,\n    offset,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset + 3] = value >>> 24\n        this[offset + 2] = value >>> 16\n        this[offset + 1] = value >>> 8\n        this[offset] = value & 0xff\n    } else {\n        objectWriteUInt32(this, value, offset, true)\n    }\n    return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(\n    value,\n    offset,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24\n        this[offset + 1] = value >>> 16\n        this[offset + 2] = value >>> 8\n        this[offset + 3] = value & 0xff\n    } else {\n        objectWriteUInt32(this, value, offset, false)\n    }\n    return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE(\n    value,\n    offset,\n    byteLength,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1)\n\n        checkInt(this, value, offset, byteLength, limit - 1, -limit)\n    }\n\n    var i = 0\n    var mul = 1\n    var sub = 0\n    this[offset] = value & 0xff\n    while (++i < byteLength && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1\n        }\n        this[offset + i] = (((value / mul) >> 0) - sub) & 0xff\n    }\n\n    return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE(\n    value,\n    offset,\n    byteLength,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1)\n\n        checkInt(this, value, offset, byteLength, limit - 1, -limit)\n    }\n\n    var i = byteLength - 1\n    var mul = 1\n    var sub = 0\n    this[offset + i] = value & 0xff\n    while (--i >= 0 && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1\n        }\n        this[offset + i] = (((value / mul) >> 0) - sub) & 0xff\n    }\n\n    return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n    if (value < 0) value = 0xff + value + 1\n    this[offset] = value & 0xff\n    return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff\n        this[offset + 1] = value >>> 8\n    } else {\n        objectWriteUInt16(this, value, offset, true)\n    }\n    return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8\n        this[offset + 1] = value & 0xff\n    } else {\n        objectWriteUInt16(this, value, offset, false)\n    }\n    return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff\n        this[offset + 1] = value >>> 8\n        this[offset + 2] = value >>> 16\n        this[offset + 3] = value >>> 24\n    } else {\n        objectWriteUInt32(this, value, offset, true)\n    }\n    return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n    if (value < 0) value = 0xffffffff + value + 1\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24\n        this[offset + 1] = value >>> 16\n        this[offset + 2] = value >>> 8\n        this[offset + 3] = value & 0xff\n    } else {\n        objectWriteUInt32(this, value, offset, false)\n    }\n    return offset + 4\n}\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\n    if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(\n            buf,\n            value,\n            offset,\n            4,\n            3.4028234663852886e38,\n            -3.4028234663852886e38,\n        )\n    }\n    ieee754write(buf, value, offset, littleEndian, 23, 4)\n    return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(\n            buf,\n            value,\n            offset,\n            8,\n            1.7976931348623157e308,\n            -1.7976931348623157e308,\n        )\n    }\n    ieee754write(buf, value, offset, littleEndian, 52, 8)\n    return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(\n    value,\n    offset,\n    noAssert,\n) {\n    return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(\n    value,\n    offset,\n    noAssert,\n) {\n    return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start) start = 0\n    if (!end && end !== 0) end = this.length\n    if (targetStart >= target.length) targetStart = target.length\n    if (!targetStart) targetStart = 0\n    if (end > 0 && end < start) end = start\n\n    // Copy 0 bytes; we're done\n    if (end === start) return 0\n    if (target.length === 0 || this.length === 0) return 0\n\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError('targetStart out of bounds')\n    }\n    if (start < 0 || start >= this.length)\n        throw new RangeError('sourceStart out of bounds')\n    if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n    // Are we oob?\n    if (end > this.length) end = this.length\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start\n    }\n\n    var len = end - start\n    var i\n\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for (i = len - 1; i >= 0; --i) {\n            target[i + targetStart] = this[i + start]\n        }\n    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for (i = 0; i < len; ++i) {\n            target[i + targetStart] = this[i + start]\n        }\n    } else {\n        Uint8Array.prototype.set.call(\n            target,\n            this.subarray(start, start + len),\n            targetStart,\n        )\n    }\n\n    return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n        if (typeof start === 'string') {\n            encoding = start\n            start = 0\n            end = this.length\n        } else if (typeof end === 'string') {\n            encoding = end\n            end = this.length\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0)\n            if (code < 256) {\n                val = code\n            }\n        }\n        if (encoding !== undefined && typeof encoding !== 'string') {\n            throw new TypeError('encoding must be a string')\n        }\n        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n            throw new TypeError('Unknown encoding: ' + encoding)\n        }\n    } else if (typeof val === 'number') {\n        val = val & 255\n    }\n\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError('Out of range index')\n    }\n\n    if (end <= start) {\n        return this\n    }\n\n    start = start >>> 0\n    end = end === undefined ? this.length : end >>> 0\n\n    if (!val) val = 0\n\n    var i\n    if (typeof val === 'number') {\n        for (i = start; i < end; ++i) {\n            this[i] = val\n        }\n    } else {\n        var bytes = internalIsBuffer(val)\n            ? val\n            : utf8ToBytes(new Buffer(val, encoding).toString())\n        var len = bytes.length\n        for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len]\n        }\n    }\n\n    return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean(str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return ''\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while (str.length % 4 !== 0) {\n        str = str + '='\n    }\n    return str\n}\n\nfunction stringtrim(str) {\n    if (str.trim) return str.trim()\n    return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex(n) {\n    if (n < 16) return '0' + n.toString(16)\n    return n.toString(16)\n}\n\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity\n    var codePoint\n    var length = string.length\n    var leadSurrogate = null\n    var bytes = []\n\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i)\n\n        // is surrogate component\n        if (codePoint > 0xd7ff && codePoint < 0xe000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xdbff) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)\n                    continue\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)\n                    continue\n                }\n\n                // valid lead\n                leadSurrogate = codePoint\n\n                continue\n            }\n\n            // 2 leads in a row\n            if (codePoint < 0xdc00) {\n                if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)\n                leadSurrogate = codePoint\n                continue\n            }\n\n            // valid surrogate pair\n            codePoint =\n                (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +\n                0x10000\n        } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)\n        }\n\n        leadSurrogate = null\n\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break\n            bytes.push(codePoint)\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break\n            bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80)\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break\n            bytes.push(\n                (codePoint >> 0xc) | 0xe0,\n                ((codePoint >> 0x6) & 0x3f) | 0x80,\n                (codePoint & 0x3f) | 0x80,\n            )\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break\n            bytes.push(\n                (codePoint >> 0x12) | 0xf0,\n                ((codePoint >> 0xc) & 0x3f) | 0x80,\n                ((codePoint >> 0x6) & 0x3f) | 0x80,\n                (codePoint & 0x3f) | 0x80,\n            )\n        } else {\n            throw new Error('Invalid code point')\n        }\n    }\n\n    return bytes\n}\n\nfunction asciiToBytes(str) {\n    var byteArray = []\n    for (var i = 0; i < str.length; ++i) {\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xff)\n    }\n    return byteArray\n}\n\nfunction utf16leToBytes(str, units) {\n    var c, hi, lo\n    var byteArray = []\n    for (var i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break\n\n        c = str.charCodeAt(i)\n        hi = c >> 8\n        lo = c % 256\n        byteArray.push(lo)\n        byteArray.push(hi)\n    }\n\n    return byteArray\n}\n\nfunction base64ToBytes(str) {\n    return base64toByteArray(base64clean(str))\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length) break\n        dst[i + offset] = src[i]\n    }\n    return i\n}\n\nfunction isnan(val) {\n    return val !== val // eslint-disable-line no-self-compare\n}\n\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n    return (\n        obj != null &&\n        (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n    )\n}\n\nfunction isFastBuffer(obj) {\n    return (\n        !!obj.constructor &&\n        typeof obj.constructor.isBuffer === 'function' &&\n        obj.constructor.isBuffer(obj)\n    )\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer(obj) {\n    return (\n        typeof obj.readFloatLE === 'function' &&\n        typeof obj.slice === 'function' &&\n        isFastBuffer(obj.slice(0, 0))\n    )\n}\n\nfunction ieee754read(buffer, offset, isLE, mLen, nBytes) {\n    var e, m\n    var eLen = nBytes * 8 - mLen - 1\n    var eMax = (1 << eLen) - 1\n    var eBias = eMax >> 1\n    var nBits = -7\n    var i = isLE ? nBytes - 1 : 0\n    var d = isLE ? -1 : 1\n    var s = buffer[offset + i]\n\n    i += d\n\n    e = s & ((1 << -nBits) - 1)\n    s >>= -nBits\n    nBits += eLen\n    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    m = e & ((1 << -nBits) - 1)\n    e >>= -nBits\n    nBits += mLen\n    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    if (e === 0) {\n        e = 1 - eBias\n    } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity\n    } else {\n        m = m + Math.pow(2, mLen)\n        e = e - eBias\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nfunction ieee754write(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c\n    var eLen = nBytes * 8 - mLen - 1\n    var eMax = (1 << eLen) - 1\n    var eBias = eMax >> 1\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0\n    var i = isLE ? 0 : nBytes - 1\n    var d = isLE ? 1 : -1\n    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n    value = Math.abs(value)\n\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0\n        e = eMax\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2)\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--\n            c *= 2\n        }\n        if (e + eBias >= 1) {\n            value += rt / c\n        } else {\n            value += rt * Math.pow(2, 1 - eBias)\n        }\n        if (value * c >= 2) {\n            e++\n            c /= 2\n        }\n\n        if (e + eBias >= eMax) {\n            m = 0\n            e = eMax\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen)\n            e = e + eBias\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n            e = 0\n        }\n    }\n\n    for (\n        ;\n        mLen >= 8;\n        buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8\n    ) {}\n\n    e = (e << mLen) | m\n    eLen += mLen\n    for (\n        ;\n        eLen > 0;\n        buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8\n    ) {}\n\n    buffer[offset + i - d] |= s * 128\n}\n", "export { Buffer } from '_node-buffer-polyfill_.js'\n", "'use strict';\n\nvar domain;\n\n// This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\nfunction EventHandlers() {}\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nexport default EventEmitter;\nexport {EventEmitter};\n\n// nodejs oddity\n// require('events') === require('events').EventEmitter\nEventEmitter.EventEmitter = EventEmitter\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active && !(this instanceof domain.Domain)) {\n      this.domain = domain.active;\n    }\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var needDomainExit = false;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    er = arguments[1];\n    if (domain) {\n      if (!er)\n        er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  if (needDomainExit)\n    domain.exit();\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] :\n                                          [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n                            existing.length + ' ' + type + ' listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n  function g() {\n    target.removeListener(type, g);\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n  g.listener = listener;\n  return g;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || (list.listener && list.listener === listener)) {\n        if (--this._eventsCount === 0)\n          this._events = new EventHandlers();\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length; i-- > 0;) {\n          if (list[i] === listener ||\n              (list[i].listener && list[i].listener === listener)) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (list.length === 1) {\n          list[0] = undefined;\n          if (--this._eventsCount === 0) {\n            this._events = new EventHandlers();\n            return this;\n          } else {\n            delete events[type];\n          }\n        } else {\n          spliceOne(list, position);\n        }\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = new EventHandlers();\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = new EventHandlers();\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        for (var i = 0, key; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = new EventHandlers();\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        do {\n          this.removeListener(type, listeners[listeners.length - 1]);\n        } while (listeners[0]);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n    ret = [];\n  else {\n    evlistener = events[type];\n    if (!evlistener)\n      ret = [];\n    else if (typeof evlistener === 'function')\n      ret = [evlistener.listener || evlistener];\n    else\n      ret = unwrapListeners(evlistener);\n  }\n\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n  while (i--)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n", "\nconst polyfill = require('events')\n\nif (polyfill && polyfill.default) {\n    module.exports = polyfill.default\n    for (let k in polyfill) {\n        module.exports[k] = polyfill[k]\n    }\n} else if (polyfill)  {\n    module.exports = polyfill\n}\n\n\n", "module.exports = require('events').EventEmitter;\n", "var lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar inited = false;\nfunction init () {\n  inited = true;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;\n}\n\nfunction toByteArray (b64) {\n  if (!inited) {\n    init();\n  }\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = (tmp >> 16) & 0xFF;\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  if (!inited) {\n    init();\n  }\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[(tmp << 4) & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n    output += lookup[tmp >> 10];\n    output += lookup[(tmp >> 4) & 0x3F];\n    output += lookup[(tmp << 2) & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('')\n}\n\nfunction read (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nfunction write (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n}\n\nvar toString = {}.toString;\n\nvar isArray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : true;\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nvar _kMaxLength = kMaxLength();\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr\n};\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n};\n\nfunction allocUnsafe (that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n};\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (internalIsBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0;\n  }\n  return Buffer.alloc(+length)\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n};\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!internalIsBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer\n};\n\nfunction byteLength (string, encoding) {\n  if (internalIsBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap (b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this\n};\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this\n};\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this\n};\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0;\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n};\n\nBuffer.prototype.equals = function equals (b) {\n  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n};\n\nBuffer.prototype.inspect = function inspect () {\n  var str = '';\n  var max = INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>'\n};\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!internalIsBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset;  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1);\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (internalIsBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n};\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n};\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed;\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n};\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return fromByteArray(buf)\n  } else {\n    return fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    );\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset]\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8)\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1]\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n};\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, true, 23, 4)\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, false, 23, 4)\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, true, 52, 8)\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, false, 52, 8)\n};\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 1] = (value >>> 8);\n    this[offset] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 3] = (value >>> 24);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4);\n  }\n  write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n};\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8);\n  }\n  write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    );\n  }\n\n  return len\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = internalIsBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray\n}\n\n\nfunction base64ToBytes (str) {\n  return toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i];\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n}\n\nfunction isFastBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n}\n\nexport { Buffer, INSPECT_MAX_BYTES, SlowBuffer, isBuffer, _kMaxLength as kMaxLength };\n", "\nconst polyfill = require('buffer')\n\nif (polyfill && polyfill.default) {\n    module.exports = polyfill.default\n    for (let k in polyfill) {\n        module.exports[k] = polyfill[k]\n    }\n} else if (polyfill)  {\n    module.exports = polyfill\n}\n\n\n", "// shim for using process in browser\n// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\nvar cachedSetTimeout = defaultSetTimout;\nvar cachedClearTimeout = defaultClearTimeout;\nif (typeof global.setTimeout === 'function') {\n    cachedSetTimeout = setTimeout;\n}\nif (typeof global.clearTimeout === 'function') {\n    cachedClearTimeout = clearTimeout;\n}\n\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nfunction nextTick(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nvar title = 'browser';\nvar platform = 'browser';\nvar browser = true;\nvar env = {};\nvar argv = [];\nvar version = ''; // empty string to avoid regexp issues\nvar versions = {};\nvar release = {};\nvar config = {};\n\nfunction noop() {}\n\nvar on = noop;\nvar addListener = noop;\nvar once = noop;\nvar off = noop;\nvar removeListener = noop;\nvar removeAllListeners = noop;\nvar emit = noop;\n\nfunction binding(name) {\n    throw new Error('process.binding is not supported');\n}\n\nfunction cwd () { return '/' }\nfunction chdir (dir) {\n    throw new Error('process.chdir is not supported');\n}function umask() { return 0; }\n\n// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\nvar performance = global.performance || {};\nvar performanceNow =\n  performance.now        ||\n  performance.mozNow     ||\n  performance.msNow      ||\n  performance.oNow       ||\n  performance.webkitNow  ||\n  function(){ return (new Date()).getTime() };\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nfunction hrtime(previousTimestamp){\n  var clocktime = performanceNow.call(performance)*1e-3;\n  var seconds = Math.floor(clocktime);\n  var nanoseconds = Math.floor((clocktime%1)*1e9);\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0];\n    nanoseconds = nanoseconds - previousTimestamp[1];\n    if (nanoseconds<0) {\n      seconds--;\n      nanoseconds += 1e9;\n    }\n  }\n  return [seconds,nanoseconds]\n}\n\nvar startTime = new Date();\nfunction uptime() {\n  var currentTime = new Date();\n  var dif = currentTime - startTime;\n  return dif / 1000;\n}\n\nvar browser$1 = {\n  nextTick: nextTick,\n  title: title,\n  browser: browser,\n  env: env,\n  argv: argv,\n  version: version,\n  versions: versions,\n  on: on,\n  addListener: addListener,\n  once: once,\n  off: off,\n  removeListener: removeListener,\n  removeAllListeners: removeAllListeners,\n  emit: emit,\n  binding: binding,\n  cwd: cwd,\n  chdir: chdir,\n  umask: umask,\n  hrtime: hrtime,\n  platform: platform,\n  release: release,\n  config: config,\n  uptime: uptime\n};\n\nexport default browser$1;\nexport { addListener, argv, binding, browser, chdir, config, cwd, emit, env, hrtime, nextTick, off, on, once, platform, release, removeAllListeners, removeListener, title, umask, uptime, version, versions };\n", "\nvar inherits;\nif (typeof Object.create === 'function'){\n  inherits = function inherits(ctor, superCtor) {\n    // implementation from standard node.js 'util' module\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  inherits = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\nexport default inherits;\n", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nimport process from 'process';\nvar formatRegExp = /%[sdj%]/g;\nexport function format(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexport function deprecate(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexport function debuglog(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = 0;\n      debugs[set] = function() {\n        var msg = format.apply(null, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nexport function inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    _extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexport function isArray(ar) {\n  return Array.isArray(ar);\n}\n\nexport function isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\n\nexport function isNull(arg) {\n  return arg === null;\n}\n\nexport function isNullOrUndefined(arg) {\n  return arg == null;\n}\n\nexport function isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nexport function isString(arg) {\n  return typeof arg === 'string';\n}\n\nexport function isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\n\nexport function isUndefined(arg) {\n  return arg === void 0;\n}\n\nexport function isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\n\nexport function isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nexport function isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\n\nexport function isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\n\nexport function isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nexport function isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\n\nexport function isBuffer(maybeBuf) {\n  return Buffer.isBuffer(maybeBuf);\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexport function log() {\n  console.log('%s - %s', timestamp(), format.apply(null, arguments));\n}\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nimport inherits from './inherits';\nexport {inherits}\n\nexport function _extend(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport default {\n  inherits: inherits,\n  _extend: _extend,\n  log: log,\n  isBuffer: isBuffer,\n  isPrimitive: isPrimitive,\n  isFunction: isFunction,\n  isError: isError,\n  isDate: isDate,\n  isObject: isObject,\n  isRegExp: isRegExp,\n  isUndefined: isUndefined,\n  isSymbol: isSymbol,\n  isString: isString,\n  isNumber: isNumber,\n  isNullOrUndefined: isNullOrUndefined,\n  isNull: isNull,\n  isBoolean: isBoolean,\n  isArray: isArray,\n  inspect: inspect,\n  deprecate: deprecate,\n  format: format,\n  debuglog: debuglog\n}\n", "\nconst polyfill = require('util')\n\nif (polyfill && polyfill.default) {\n    module.exports = polyfill.default\n    for (let k in polyfill) {\n        module.exports[k] = polyfill[k]\n    }\n} else if (polyfill)  {\n    module.exports = polyfill\n}\n\n\n", "'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();", "'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};", "'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n", "'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};", "if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n", "\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});", "/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}", "// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;", "'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;", "module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nmodule.exports = Transform;\n\nvar _require$codes = require('../errors').codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = require('./_stream_duplex');\n\nrequire('inherits')(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\nrequire('inherits')(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};", "// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = require('../../../errors').codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;", "exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n", "const Transform = require('readable-stream').Transform\n\nmodule.exports = class Blake extends Transform {\n  constructor (engine, options) {\n    super(options)\n\n    this._engine = engine\n    this._finalized = false\n  }\n\n  _transform (chunk, encoding, callback) {\n    let error = null\n    try {\n      this.update(chunk, encoding)\n    } catch (err) {\n      error = err\n    }\n\n    callback(error)\n  }\n\n  _flush (callback) {\n    let error = null\n    try {\n      this.push(this.digest())\n    } catch (err) {\n      error = err\n    }\n\n    callback(error)\n  }\n\n  update (data, encoding) {\n    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')\n    if (this._finalized) throw new Error('Digest already called')\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\n\n    this._engine.update(data)\n\n    return this\n  }\n\n  digest (encoding) {\n    if (this._finalized) throw new Error('Digest already called')\n    this._finalized = true\n\n    let digest = this._engine.digest()\n    if (encoding !== undefined) digest = digest.toString(encoding)\n\n    return digest\n  }\n}\n", "const Blake = require('./blake')\n\nmodule.exports = (engines) => {\n  const getEngine = (algorithm) => {\n    const hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm\n    switch (hash) {\n      case 'blake224': return engines.Blake224\n      case 'blake256': return engines.Blake256\n      case 'blake384': return engines.Blake384\n      case 'blake512': return engines.Blake512\n\n      default: throw new Error('Invald algorithm: ' + algorithm)\n    }\n  }\n\n  return (algorithm, options) => {\n    const Engine = getEngine(algorithm)\n    return new Blake(new Engine(), options)\n  }\n}\n", "class Blake {\n  _lengthCarry (arr) {\n    for (let j = 0; j < arr.length; ++j) {\n      if (arr[j] < 0x0100000000) break\n      arr[j] -= 0x0100000000\n      arr[j + 1] += 1\n    }\n  }\n\n  update (data) {\n    const block = this._block\n    let offset = 0\n\n    while (this._blockOffset + data.length - offset >= block.length) {\n      for (let i = this._blockOffset; i < block.length;) block[i++] = data[offset++]\n\n      this._length[0] += block.length * 8\n      this._lengthCarry(this._length)\n\n      this._compress()\n      this._blockOffset = 0\n    }\n\n    while (offset < data.length) block[this._blockOffset++] = data[offset++]\n  }\n}\n\nBlake.sigma = [\n  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n  [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],\n  [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],\n  [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],\n  [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],\n  [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9],\n  [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11],\n  [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10],\n  [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5],\n  [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0],\n  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n  [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],\n  [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],\n  [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],\n  [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],\n  [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]\n]\n\nBlake.u256 = [\n  0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,\n  0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,\n  0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,\n  0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917\n]\n\nBlake.u512 = [\n  0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,\n  0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,\n  0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,\n  0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,\n  0x9216d5d9, 0x8979fb1b, 0xd1310ba6, 0x98dfb5ac,\n  0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96,\n  0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7,\n  0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69\n]\n\nBlake.padding = Buffer.from([\n  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n])\n\nmodule.exports = Blake\n", "const Blake = require('./blake')\n\nconst zo = Buffer.from([0x01])\nconst oo = Buffer.from([0x81])\n\nconst rot = (x, n) => ((x << (32 - n)) | (x >>> n)) >>> 0\n\nfunction g (v, m, i, a, b, c, d, e) {\n  const sigma = Blake.sigma\n  const u256 = Blake.u256\n\n  v[a] = (v[a] + ((m[sigma[i][e]] ^ u256[sigma[i][e + 1]]) >>> 0) + v[b]) >>> 0\n  v[d] = rot(v[d] ^ v[a], 16)\n  v[c] = (v[c] + v[d]) >>> 0\n  v[b] = rot(v[b] ^ v[c], 12)\n  v[a] = (v[a] + ((m[sigma[i][e + 1]] ^ u256[sigma[i][e]]) >>> 0) + v[b]) >>> 0\n  v[d] = rot(v[d] ^ v[a], 8)\n  v[c] = (v[c] + v[d]) >>> 0\n  v[b] = rot(v[b] ^ v[c], 7)\n}\n\nmodule.exports = class Blake256 extends Blake {\n  constructor () {\n    super()\n\n    this._h = [\n      0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n      0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n    ]\n\n    this._s = [0, 0, 0, 0]\n\n    this._block = Buffer.alloc(64)\n    this._blockOffset = 0\n    this._length = [0, 0]\n\n    this._nullt = false\n\n    this._zo = zo\n    this._oo = oo\n  }\n\n  _compress () {\n    const u256 = Blake.u256\n    const v = new Array(16)\n    const m = new Array(16)\n    let i\n\n    for (i = 0; i < 16; ++i) m[i] = this._block.readUInt32BE(i * 4)\n    for (i = 0; i < 8; ++i) v[i] = this._h[i] >>> 0\n    for (i = 8; i < 12; ++i) v[i] = (this._s[i - 8] ^ u256[i - 8]) >>> 0\n    for (i = 12; i < 16; ++i) v[i] = u256[i - 8]\n\n    if (!this._nullt) {\n      v[12] = (v[12] ^ this._length[0]) >>> 0\n      v[13] = (v[13] ^ this._length[0]) >>> 0\n      v[14] = (v[14] ^ this._length[1]) >>> 0\n      v[15] = (v[15] ^ this._length[1]) >>> 0\n    }\n\n    for (i = 0; i < 14; ++i) {\n      /* column step */\n      g(v, m, i, 0, 4, 8, 12, 0)\n      g(v, m, i, 1, 5, 9, 13, 2)\n      g(v, m, i, 2, 6, 10, 14, 4)\n      g(v, m, i, 3, 7, 11, 15, 6)\n      /* diagonal step */\n      g(v, m, i, 0, 5, 10, 15, 8)\n      g(v, m, i, 1, 6, 11, 12, 10)\n      g(v, m, i, 2, 7, 8, 13, 12)\n      g(v, m, i, 3, 4, 9, 14, 14)\n    }\n\n    for (i = 0; i < 16; ++i) this._h[i % 8] = (this._h[i % 8] ^ v[i]) >>> 0\n    for (i = 0; i < 8; ++i) this._h[i] = (this._h[i] ^ this._s[i % 4]) >>> 0\n  }\n\n  _padding () {\n    let lo = this._length[0] + this._blockOffset * 8\n    let hi = this._length[1]\n    if (lo >= 0x0100000000) {\n      lo -= 0x0100000000\n      hi += 1\n    }\n\n    const msglen = Buffer.alloc(8)\n    msglen.writeUInt32BE(hi, 0)\n    msglen.writeUInt32BE(lo, 4)\n\n    if (this._blockOffset === 55) {\n      this._length[0] -= 8\n      this.update(this._oo)\n    } else {\n      if (this._blockOffset < 55) {\n        if (this._blockOffset === 0) this._nullt = true\n        this._length[0] -= (55 - this._blockOffset) * 8\n        this.update(Blake.padding.slice(0, 55 - this._blockOffset))\n      } else {\n        this._length[0] -= (64 - this._blockOffset) * 8\n        this.update(Blake.padding.slice(0, 64 - this._blockOffset))\n        this._length[0] -= 55 * 8\n        this.update(Blake.padding.slice(1, 1 + 55))\n        this._nullt = true\n      }\n\n      this.update(this._zo)\n      this._length[0] -= 8\n    }\n\n    this._length[0] -= 64\n    this.update(msglen)\n  }\n\n  digest () {\n    this._padding()\n\n    const buffer = Buffer.alloc(32)\n    for (let i = 0; i < 8; ++i) buffer.writeUInt32BE(this._h[i], i * 4)\n    return buffer\n  }\n}\n", "const Blake256 = require('./blake256')\n\nconst zo = Buffer.from([0x00])\nconst oo = Buffer.from([0x80])\n\nmodule.exports = class Blake224 extends Blake256 {\n  constructor () {\n    super()\n\n    this._h = [\n      0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n      0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n    ]\n\n    this._zo = zo\n    this._oo = oo\n  }\n\n  digest () {\n    this._padding()\n\n    const buffer = Buffer.alloc(28)\n    for (let i = 0; i < 7; ++i) buffer.writeUInt32BE(this._h[i], i * 4)\n    return buffer\n  }\n}\n", "const Blake = require('./blake')\n\nconst zo = Buffer.from([0x01])\nconst oo = Buffer.from([0x81])\n\nfunction rot (v, i, j, n) {\n  let hi = v[i * 2] ^ v[j * 2]\n  let lo = v[i * 2 + 1] ^ v[j * 2 + 1]\n\n  if (n >= 32) {\n    lo = lo ^ hi\n    hi = lo ^ hi\n    lo = lo ^ hi\n    n -= 32\n  }\n\n  if (n === 0) {\n    v[i * 2] = hi >>> 0\n    v[i * 2 + 1] = lo >>> 0\n  } else {\n    v[i * 2] = ((hi >>> n) | (lo << (32 - n))) >>> 0\n    v[i * 2 + 1] = ((lo >>> n) | (hi << (32 - n))) >>> 0\n  }\n}\n\nfunction g (v, m, i, a, b, c, d, e) {\n  const sigma = Blake.sigma\n  const u512 = Blake.u512\n  let lo\n\n  // v[a] += (m[sigma[i][e]] ^ u512[sigma[i][e+1]]) + v[b];\n  lo = v[a * 2 + 1] + ((m[sigma[i][e] * 2 + 1] ^ u512[sigma[i][e + 1] * 2 + 1]) >>> 0) + v[b * 2 + 1]\n  v[a * 2] = (v[a * 2] + ((m[sigma[i][e] * 2] ^ u512[sigma[i][e + 1] * 2]) >>> 0) + v[b * 2] + ~~(lo / 0x0100000000)) >>> 0\n  v[a * 2 + 1] = lo >>> 0\n\n  // v[d] = ROT( v[d] ^ v[a],32);\n  rot(v, d, a, 32)\n\n  // v[c] += v[d];\n  lo = v[c * 2 + 1] + v[d * 2 + 1]\n  v[c * 2] = (v[c * 2] + v[d * 2] + ~~(lo / 0x0100000000)) >>> 0\n  v[c * 2 + 1] = lo >>> 0\n\n  // v[b] = ROT( v[b] ^ v[c],25);\n  rot(v, b, c, 25)\n\n  // v[a] += (m[sigma[i][e+1]] ^ u512[sigma[i][e]])+v[b];\n  lo = v[a * 2 + 1] + ((m[sigma[i][e + 1] * 2 + 1] ^ u512[sigma[i][e] * 2 + 1]) >>> 0) + v[b * 2 + 1]\n  v[a * 2] = (v[a * 2] + ((m[sigma[i][e + 1] * 2] ^ u512[sigma[i][e] * 2]) >>> 0) + v[b * 2] + ~~(lo / 0x0100000000)) >>> 0\n  v[a * 2 + 1] = lo >>> 0\n\n  // v[d] = ROT( v[d] ^ v[a],16);\n  rot(v, d, a, 16)\n\n  // v[c] += v[d];\n  lo = v[c * 2 + 1] + v[d * 2 + 1]\n  v[c * 2] = (v[c * 2] + v[d * 2] + ~~(lo / 0x0100000000)) >>> 0\n  v[c * 2 + 1] = lo >>> 0\n\n  // v[b] = ROT( v[b] ^ v[c],11)\n  rot(v, b, c, 11)\n}\n\nmodule.exports = class Blake512 extends Blake {\n  constructor () {\n    super()\n\n    this._h = [\n      0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b,\n      0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n      0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f,\n      0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179\n    ]\n\n    this._s = [0, 0, 0, 0, 0, 0, 0, 0]\n\n    this._block = Buffer.alloc(128)\n    this._blockOffset = 0\n    this._length = [0, 0, 0, 0]\n\n    this._nullt = false\n\n    this._zo = zo\n    this._oo = oo\n  }\n\n  _compress () {\n    const u512 = Blake.u512\n    const v = new Array(32)\n    const m = new Array(32)\n    let i\n\n    for (i = 0; i < 32; ++i) m[i] = this._block.readUInt32BE(i * 4)\n    for (i = 0; i < 16; ++i) v[i] = this._h[i] >>> 0\n    for (i = 16; i < 24; ++i) v[i] = (this._s[i - 16] ^ u512[i - 16]) >>> 0\n    for (i = 24; i < 32; ++i) v[i] = u512[i - 16]\n\n    if (!this._nullt) {\n      v[24] = (v[24] ^ this._length[1]) >>> 0\n      v[25] = (v[25] ^ this._length[0]) >>> 0\n      v[26] = (v[26] ^ this._length[1]) >>> 0\n      v[27] = (v[27] ^ this._length[0]) >>> 0\n      v[28] = (v[28] ^ this._length[3]) >>> 0\n      v[29] = (v[29] ^ this._length[2]) >>> 0\n      v[30] = (v[30] ^ this._length[3]) >>> 0\n      v[31] = (v[31] ^ this._length[2]) >>> 0\n    }\n\n    for (i = 0; i < 16; ++i) {\n      /* column step */\n      g(v, m, i, 0, 4, 8, 12, 0)\n      g(v, m, i, 1, 5, 9, 13, 2)\n      g(v, m, i, 2, 6, 10, 14, 4)\n      g(v, m, i, 3, 7, 11, 15, 6)\n      /* diagonal step */\n      g(v, m, i, 0, 5, 10, 15, 8)\n      g(v, m, i, 1, 6, 11, 12, 10)\n      g(v, m, i, 2, 7, 8, 13, 12)\n      g(v, m, i, 3, 4, 9, 14, 14)\n    }\n\n    for (i = 0; i < 16; ++i) {\n      this._h[(i % 8) * 2] = (this._h[(i % 8) * 2] ^ v[i * 2]) >>> 0\n      this._h[(i % 8) * 2 + 1] = (this._h[(i % 8) * 2 + 1] ^ v[i * 2 + 1]) >>> 0\n    }\n\n    for (i = 0; i < 8; ++i) {\n      this._h[i * 2] = (this._h[i * 2] ^ this._s[(i % 4) * 2]) >>> 0\n      this._h[i * 2 + 1] = (this._h[i * 2 + 1] ^ this._s[(i % 4) * 2 + 1]) >>> 0\n    }\n  }\n\n  _padding () {\n    const len = this._length.slice()\n    len[0] += this._blockOffset * 8\n    this._lengthCarry(len)\n\n    const msglen = Buffer.alloc(16)\n    for (let i = 0; i < 4; ++i) msglen.writeUInt32BE(len[3 - i], i * 4)\n\n    if (this._blockOffset === 111) {\n      this._length[0] -= 8\n      this.update(this._oo)\n    } else {\n      if (this._blockOffset < 111) {\n        if (this._blockOffset === 0) this._nullt = true\n        this._length[0] -= (111 - this._blockOffset) * 8\n        this.update(Blake.padding.slice(0, 111 - this._blockOffset))\n      } else {\n        this._length[0] -= (128 - this._blockOffset) * 8\n        this.update(Blake.padding.slice(0, 128 - this._blockOffset))\n        this._length[0] -= 111 * 8\n        this.update(Blake.padding.slice(1, 1 + 111))\n        this._nullt = true\n      }\n\n      this.update(this._zo)\n      this._length[0] -= 8\n    }\n\n    this._length[0] -= 128\n    this.update(msglen)\n  }\n\n  digest () {\n    this._padding()\n\n    const buffer = Buffer.alloc(64)\n    for (let i = 0; i < 16; ++i) buffer.writeUInt32BE(this._h[i], i * 4)\n    return buffer\n  }\n}\n", "const Blake512 = require('./blake512')\n\nconst zo = Buffer.from([0x00])\nconst oo = Buffer.from([0x80])\n\nmodule.exports = class Blake384 extends Blake512 {\n  constructor () {\n    super()\n\n    this._h = [\n      0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507,\n      0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n      0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511,\n      0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4\n    ]\n\n    this._zo = zo\n    this._oo = oo\n  }\n\n  digest () {\n    this._padding()\n\n    const buffer = Buffer.alloc(48)\n    for (let i = 0; i < 12; ++i) buffer.writeUInt32BE(this._h[i], i * 4)\n    return buffer\n  }\n}\n", "module.exports = {\n  Blake224: require('./blake224'),\n  Blake256: require('./blake256'),\n  Blake384: require('./blake384'),\n  Blake512: require('./blake512')\n}\n", "module.exports = require('./lib/api')(require('./lib'))\n", "export default {};\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexports.bigInt2BytesLE = function bigInt2BytesLE(_a, len) {\n    const b = Array(len);\n    let v = BigInt(_a);\n    for (let i=0; i<len; i++) {\n        b[i] = Number(v & 0xFFn);\n        v = v >> 8n;\n    }\n    return b;\n};\n\nexports.bigInt2U32LE = function bigInt2BytesLE(_a, len) {\n    const b = Array(len);\n    let v = BigInt(_a);\n    for (let i=0; i<len; i++) {\n        b[i] = Number(v & 0xFFFFFFFFn);\n        v = v >> 32n;\n    }\n    return b;\n};\n\nexports.isOcamNum = function(a) {\n    if (!Array.isArray(a)) return false;\n    if (a.length != 3) return false;\n    if (typeof a[0] !== \"number\") return false;\n    if (typeof a[1] !== \"number\") return false;\n    if (!Array.isArray(a[2])) return false;\n    return true;\n};\n\n\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildInt(module, n64, _prefix) {\n\n    const prefix = _prefix || \"int\";\n    if (module.modules[prefix]) return prefix;  // already builded\n    module.modules[prefix] = {};\n\n    const n32 = n64*2;\n    const n8 = n64*8;\n\n    function buildCopy() {\n        const f = module.addFunction(prefix+\"_copy\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pr\"),\n                    i*8,\n                    c.i64_load(\n                        c.getLocal(\"px\"),\n                        i*8\n                    )\n                )\n            );\n        }\n    }\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pr\"),\n                    i*8,\n                    c.i64_const(0)\n                )\n            );\n        }\n    }\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.i64_store(\n                c.getLocal(\"pr\"),\n                0,\n                c.i64_const(1)\n            )\n        );\n        for (let i=1; i<n64; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pr\"),\n                    i*8,\n                    c.i64_const(0)\n                )\n            );\n        }\n    }\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix+\"_isZero\");\n        f.addParam(\"px\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        function getCompCode(n) {\n            if (n==0) {\n                return  c.ret(c.i64_eqz(\n                    c.i64_load(c.getLocal(\"px\"))\n                ));\n            }\n            return c.if(\n                c.i64_eqz(\n                    c.i64_load(c.getLocal(\"px\"), n*8 )\n                ),\n                getCompCode(n-1),\n                c.ret(c.i32_const(0))\n            );\n        }\n\n        f.addCode(getCompCode(n64-1));\n        f.addCode(c.ret(c.i32_const(0)));\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix+\"_eq\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"py\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        function getCompCode(n) {\n            if (n==0) {\n                return  c.ret(c.i64_eq(\n                    c.i64_load(c.getLocal(\"px\")),\n                    c.i64_load(c.getLocal(\"py\"))\n                ));\n            }\n            return c.if(\n                c.i64_eq(\n                    c.i64_load(c.getLocal(\"px\"), n*8 ),\n                    c.i64_load(c.getLocal(\"py\"), n*8 )\n                ),\n                getCompCode(n-1),\n                c.ret(c.i32_const(0))\n            );\n        }\n\n        f.addCode(getCompCode(n64-1));\n        f.addCode(c.ret(c.i32_const(0)));\n    }\n\n\n\n    function buildGte() {\n        const f = module.addFunction(prefix+\"_gte\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"py\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        function getCompCode(n) {\n            if (n==0) {\n                return  c.ret(c.i64_ge_u(\n                    c.i64_load(c.getLocal(\"px\")),\n                    c.i64_load(c.getLocal(\"py\"))\n                ));\n            }\n            return c.if(\n                c.i64_lt_u(\n                    c.i64_load(c.getLocal(\"px\"), n*8 ),\n                    c.i64_load(c.getLocal(\"py\"), n*8 )\n                ),\n                c.ret(c.i32_const(0)),\n                c.if(\n                    c.i64_gt_u(\n                        c.i64_load(c.getLocal(\"px\"), n*8 ),\n                        c.i64_load(c.getLocal(\"py\"), n*8 )\n                    ),\n                    c.ret(c.i32_const(1)),\n                    getCompCode(n-1)\n                )\n            );\n        }\n\n        f.addCode(getCompCode(n64-1));\n        f.addCode(c.ret(c.i32_const(0)));\n    }\n\n\n\n    function buildAdd() {\n\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"c\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_add(\n                c.i64_load32_u(c.getLocal(\"x\")),\n                c.i64_load32_u(c.getLocal(\"y\"))\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"r\"),\n            c.getLocal(\"c\"),\n        ));\n\n        for (let i=1; i<n32; i++) {\n            f.addCode(c.setLocal( \"c\",\n                c.i64_add(\n                    c.i64_add(\n                        c.i64_load32_u(c.getLocal(\"x\"), 4*i),\n                        c.i64_load32_u(c.getLocal(\"y\"), 4*i)\n                    ),\n                    c.i64_shr_u (c.getLocal(\"c\"), c.i64_const(32))\n                )\n            ));\n\n            f.addCode(c.i64_store32(\n                c.getLocal(\"r\"),\n                i*4,\n                c.getLocal(\"c\")\n            ));\n        }\n\n        f.addCode(c.i32_wrap_i64(c.i64_shr_u (c.getLocal(\"c\"), c.i64_const(32))));\n    }\n\n\n    function buildSub() {\n\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"c\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_sub(\n                c.i64_load32_u(c.getLocal(\"x\")),\n                c.i64_load32_u(c.getLocal(\"y\"))\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"r\"),\n            c.i64_and(\n                c.getLocal(\"c\"),\n                c.i64_const(\"0xFFFFFFFF\")\n            )\n        ));\n\n        for (let i=1; i<n32; i++) {\n            f.addCode(c.setLocal( \"c\",\n                c.i64_add(\n                    c.i64_sub(\n                        c.i64_load32_u(c.getLocal(\"x\"), 4*i),\n                        c.i64_load32_u(c.getLocal(\"y\"), 4*i)\n                    ),\n                    c.i64_shr_s (c.getLocal(\"c\"), c.i64_const(32))\n                )\n            ));\n\n            f.addCode(c.i64_store32(\n                c.getLocal(\"r\"),\n                i*4,\n                c.i64_and( c.getLocal(\"c\"), c.i64_const(\"0xFFFFFFFF\"))\n            ));\n        }\n\n        f.addCode(c.i32_wrap_i64 ( c.i64_shr_s (c.getLocal(\"c\"), c.i64_const(32))));\n    }\n\n\n    function buildMul() {\n\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n            f.addLocal(\"y\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const loadX = [];\n        const loadY = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadY[j]) {\n                Y = c.teeLocal(\"y\"+j, c.i64_load32_u( c.getLocal(\"y\"), j*4));\n                loadY[j] = true;\n            } else {\n                Y = c.getLocal(\"y\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            for (let i=Math.max(0, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n\n            }\n\n            f.addCode(\n                c.i64_store32(\n                    c.getLocal(\"r\"),\n                    k*4,\n                    c.getLocal(c0)\n                )\n            );\n            [c0, c1] = [c1, c0];\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_shr_u(\n                        c.getLocal(c0),\n                        c.i64_const(32)\n                    )\n                )\n            );\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4*2-4,\n                c.getLocal(c0)\n            )\n        );\n\n    }\n\n\n\n    function buildSquare() {\n\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n        f.addLocal(\"c0_old\", \"i64\");\n        f.addLocal(\"c1_old\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const loadX = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadX[j]) {\n                Y = c.teeLocal(\"x\"+j, c.i64_load32_u( c.getLocal(\"x\"), j*4));\n                loadX[j] = true;\n            } else {\n                Y = c.getLocal(\"x\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n        let c0_old = \"c0_old\";\n        let c1_old = \"c1_old\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            f.addCode(\n                c.setLocal(c0, c.i64_const(0)),\n                c.setLocal(c1, c.i64_const(0)),\n            );\n\n            for (let i=Math.max(0, k-n32+1); (i<((k+1)>>1) )&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Multiply by 2\n            f.addCode(\n                c.setLocal(c0,\n                    c.i64_shl(\n                        c.i64_and(\n                            c.getLocal(c0),\n                            c.i64_const(0xFFFFFFFF)\n                        ),\n                        c.i64_const(1)\n                    )\n                )\n            );\n\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_add(\n                        c.i64_shl(\n                            c.getLocal(c1),\n                            c.i64_const(1)\n                        ),\n                        c.i64_shr_u(\n                            c.getLocal(c0),\n                            c.i64_const(32)\n                        )\n                    )\n                )\n            );\n\n            if (k%2 == 0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(k>>1, k>>1)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Add the old carry\n\n            if (k>0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            c.i64_and(\n                                c.getLocal(c0_old),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.i64_add(\n                                c.getLocal(c1),\n                                c.i64_shr_u(\n                                    c.getLocal(c0),\n                                    c.i64_const(32)\n                                )\n                            ),\n                            c.getLocal(c1_old)\n                        )\n                    )\n                );\n            }\n\n            f.addCode(\n                c.i64_store32(\n                    c.getLocal(\"r\"),\n                    k*4,\n                    c.getLocal(c0)\n                )\n            );\n\n            f.addCode(\n                c.setLocal(\n                    c0_old,\n                    c.getLocal(c1)\n                ),\n                c.setLocal(\n                    c1_old,\n                    c.i64_shr_u(\n                        c.getLocal(c0_old),\n                        c.i64_const(32)\n                    )\n                )\n            );\n\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4*2-4,\n                c.getLocal(c0_old)\n            )\n        );\n\n    }\n\n\n    function buildSquareOld() {\n        const f = module.addFunction(prefix+\"_squareOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(prefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"x\"), c.getLocal(\"r\")));\n    }\n\n    function _buildMul1() {\n        const f = module.addFunction(prefix+\"__mul1\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"y\", \"i64\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"c\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_mul(\n                c.i64_load32_u(c.getLocal(\"px\"), 0, 0),\n                c.getLocal(\"y\")\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"pr\"),\n            0,\n            0,\n            c.getLocal(\"c\"),\n        ));\n\n        for (let i=1; i<n32; i++) {\n            f.addCode(c.setLocal( \"c\",\n                c.i64_add(\n                    c.i64_mul(\n                        c.i64_load32_u(c.getLocal(\"px\"), 4*i, 0),\n                        c.getLocal(\"y\")\n                    ),\n                    c.i64_shr_u (c.getLocal(\"c\"), c.i64_const(32))\n                )\n            ));\n\n            f.addCode(c.i64_store32(\n                c.getLocal(\"pr\"),\n                i*4,\n                0,\n                c.getLocal(\"c\")\n            ));\n        }\n    }\n\n    function _buildAdd1() {\n        const f = module.addFunction(prefix+\"__add1\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i64\");\n        f.addLocal(\"c\", \"i64\");\n        f.addLocal(\"px\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\"px\", c.getLocal(\"x\")));\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_add(\n                c.i64_load32_u(c.getLocal(\"px\"), 0, 0),\n                c.getLocal(\"y\")\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"px\"),\n            0,\n            0,\n            c.getLocal(\"c\"),\n        ));\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_shr_u(\n                c.getLocal(\"c\"),\n                c.i64_const(32)\n            )\n        ));\n\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.i64_eqz(c.getLocal(\"c\"))\n            ),\n            c.setLocal(\n                \"px\",\n                c.i32_add(\n                    c.getLocal(\"px\"),\n                    c.i32_const(4)\n                )\n            ),\n\n            c.setLocal(\n                \"c\",\n                c.i64_add(\n                    c.i64_load32_u(c.getLocal(\"px\"), 0, 0),\n                    c.getLocal(\"c\")\n                )\n            ),\n\n            c.i64_store32(\n                c.getLocal(\"px\"),\n                0,\n                0,\n                c.getLocal(\"c\"),\n            ),\n\n            c.setLocal(\n                \"c\",\n                c.i64_shr_u(\n                    c.getLocal(\"c\"),\n                    c.i64_const(32)\n                )\n            ),\n\n            c.br(0)\n        )));\n    }\n\n\n    function buildDiv() {\n        _buildMul1();\n        _buildAdd1();\n\n        const f = module.addFunction(prefix+\"_div\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"c\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"rr\", \"i32\");\n        f.addLocal(\"cc\", \"i32\");\n        f.addLocal(\"eX\", \"i32\");\n        f.addLocal(\"eY\", \"i32\");\n        f.addLocal(\"sy\", \"i64\");\n        f.addLocal(\"sx\", \"i64\");\n        f.addLocal(\"ec\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Y = c.i32_const(module.alloc(n8));\n        const Caux = c.i32_const(module.alloc(n8));\n        const Raux = c.i32_const(module.alloc(n8));\n        const C = c.getLocal(\"cc\");\n        const R = c.getLocal(\"rr\");\n        const pr1 = module.alloc(n8*2);\n        const R1 = c.i32_const(pr1);\n        const R2 = c.i32_const(pr1+n8);\n\n        // Ic c is 0 then store it in an auxiliary buffer\n        f.addCode(c.if(\n            c.getLocal(\"c\"),\n            c.setLocal(\"cc\", c.getLocal(\"c\")),\n            c.setLocal(\"cc\", Caux)\n        ));\n\n        // Ic r is 0 then store it in an auxiliary buffer\n        f.addCode(c.if(\n            c.getLocal(\"r\"),\n            c.setLocal(\"rr\", c.getLocal(\"r\")),\n            c.setLocal(\"rr\", Raux)\n        ));\n\n        // Copy\n        f.addCode(c.call(prefix + \"_copy\", c.getLocal(\"x\"), R));\n        f.addCode(c.call(prefix + \"_copy\", c.getLocal(\"y\"), Y));\n        f.addCode(c.call(prefix + \"_zero\", C));\n        f.addCode(c.call(prefix + \"_zero\", R1));\n\n\n        f.addCode(c.setLocal(\"eX\", c.i32_const(n8-1)));\n        f.addCode(c.setLocal(\"eY\", c.i32_const(n8-1)));\n\n        // while (eY>3)&&(Y[eY]==0) ey--;\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.i32_or(\n                    c.i32_load8_u(\n                        c.i32_add(Y , c.getLocal(\"eY\")),\n                        0,\n                        0\n                    ),\n                    c.i32_eq(\n                        c.getLocal(\"eY\"),\n                        c.i32_const(3)\n                    )\n                )\n            ),\n            c.setLocal(\"eY\", c.i32_sub(c.getLocal(\"eY\"), c.i32_const(1))),\n            c.br(0)\n        )));\n\n        f.addCode(\n            c.setLocal(\n                \"sy\",\n                c.i64_add(\n                    c.i64_load32_u(\n                        c.i32_sub(\n                            c.i32_add( Y, c.getLocal(\"eY\")),\n                            c.i32_const(3)\n                        ),\n                        0,\n                        0\n                    ),\n                    c.i64_const(1)\n                )\n            )\n        );\n\n        // Force a divide by 0 if quotien is 0\n        f.addCode(\n            c.if(\n                c.i64_eq(\n                    c.getLocal(\"sy\"),\n                    c.i64_const(1)\n                ),\n                c.drop(c.i64_div_u(c.i64_const(0), c.i64_const(0)))\n            )\n        );\n\n        f.addCode(c.block(c.loop(\n\n            // while (eX>7)&&(Y[eX]==0) ex--;\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_or(\n                        c.i32_load8_u(\n                            c.i32_add(R , c.getLocal(\"eX\")),\n                            0,\n                            0\n                        ),\n                        c.i32_eq(\n                            c.getLocal(\"eX\"),\n                            c.i32_const(7)\n                        )\n                    )\n                ),\n                c.setLocal(\"eX\", c.i32_sub(c.getLocal(\"eX\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            c.setLocal(\n                \"sx\",\n                c.i64_load(\n                    c.i32_sub(\n                        c.i32_add( R, c.getLocal(\"eX\")),\n                        c.i32_const(7)\n                    ),\n                    0,\n                    0\n                )\n            ),\n\n            c.setLocal(\n                \"sx\",\n                c.i64_div_u(\n                    c.getLocal(\"sx\"),\n                    c.getLocal(\"sy\")\n                )\n            ),\n            c.setLocal(\n                \"ec\",\n                c.i32_sub(\n                    c.i32_sub(\n                        c.getLocal(\"eX\"),\n                        c.getLocal(\"eY\")\n                    ),\n                    c.i32_const(4)\n                )\n            ),\n\n            // While greater than 32 bits or ec is neg, shr and inc exp\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_and(\n                        c.i64_eqz(\n                            c.i64_and(\n                                c.getLocal(\"sx\"),\n                                c.i64_const(\"0xFFFFFFFF00000000\")\n                            )\n                        ),\n                        c.i32_ge_s(\n                            c.getLocal(\"ec\"),\n                            c.i32_const(0)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"sx\",\n                    c.i64_shr_u(\n                        c.getLocal(\"sx\"),\n                        c.i64_const(8)\n                    )\n                ),\n\n                c.setLocal(\n                    \"ec\",\n                    c.i32_add(\n                        c.getLocal(\"ec\"),\n                        c.i32_const(1)\n                    )\n                ),\n                c.br(0)\n            )),\n\n            c.if(\n                c.i64_eqz(c.getLocal(\"sx\")),\n                [\n                    ...c.br_if(\n                        2,\n                        c.i32_eqz(c.call(prefix + \"_gte\", R, Y))\n                    ),\n                    ...c.setLocal(\"sx\", c.i64_const(1)),\n                    ...c.setLocal(\"ec\", c.i32_const(0))\n                ]\n            ),\n\n            c.call(prefix + \"__mul1\", Y, c.getLocal(\"sx\"), R2),\n            c.drop(c.call(\n                prefix + \"_sub\",\n                R,\n                c.i32_sub(R2, c.getLocal(\"ec\")),\n                R\n            )),\n            c.call(\n                prefix + \"__add1\",\n                c.i32_add(C, c.getLocal(\"ec\")),\n                c.getLocal(\"sx\")\n            ),\n            c.br(0)\n        )));\n    }\n\n    function buildInverseMod() {\n\n        const f = module.addFunction(prefix+\"_inverseMod\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"pm\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"t\", \"i32\");\n        f.addLocal(\"newt\", \"i32\");\n        f.addLocal(\"r\", \"i32\");\n        f.addLocal(\"qq\", \"i32\");\n        f.addLocal(\"qr\", \"i32\");\n        f.addLocal(\"newr\", \"i32\");\n        f.addLocal(\"swp\", \"i32\");\n        f.addLocal(\"x\", \"i32\");\n        f.addLocal(\"signt\", \"i32\");\n        f.addLocal(\"signnewt\", \"i32\");\n        f.addLocal(\"signx\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux1 = c.i32_const(module.alloc(n8));\n        const aux2 = c.i32_const(module.alloc(n8));\n        const aux3 = c.i32_const(module.alloc(n8));\n        const aux4 = c.i32_const(module.alloc(n8));\n        const aux5 = c.i32_const(module.alloc(n8));\n        const aux6 = c.i32_const(module.alloc(n8));\n        const mulBuff = c.i32_const(module.alloc(n8*2));\n        const aux7 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"t\", aux1),\n            c.call(prefix + \"_zero\", aux1),\n            c.setLocal(\"signt\", c.i32_const(0)),\n        );\n\n        f.addCode(\n            c.setLocal(\"r\", aux2),\n            c.call(prefix + \"_copy\", c.getLocal(\"pm\"), aux2)\n        );\n\n        f.addCode(\n            c.setLocal(\"newt\", aux3),\n            c.call(prefix + \"_one\", aux3),\n            c.setLocal(\"signnewt\", c.i32_const(0)),\n        );\n\n        f.addCode(\n            c.setLocal(\"newr\", aux4),\n            c.call(prefix + \"_copy\", c.getLocal(\"px\"), aux4)\n        );\n\n\n\n\n        f.addCode(c.setLocal(\"qq\", aux5));\n        f.addCode(c.setLocal(\"qr\", aux6));\n        f.addCode(c.setLocal(\"x\", aux7));\n\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.call(prefix + \"_isZero\", c.getLocal(\"newr\") )\n            ),\n            c.call(prefix + \"_div\", c.getLocal(\"r\"), c.getLocal(\"newr\"), c.getLocal(\"qq\"), c.getLocal(\"qr\")),\n\n            c.call(prefix + \"_mul\", c.getLocal(\"qq\"), c.getLocal(\"newt\"), mulBuff),\n\n            c.if(\n                c.getLocal(\"signt\"),\n                c.if(\n                    c.getLocal(\"signnewt\"),\n                    c.if (\n                        c.call(prefix + \"_gte\", mulBuff, c.getLocal(\"t\")),\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(0))\n                        ],\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", c.getLocal(\"t\"), mulBuff, c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(1))\n                        ],\n                    ),\n                    [\n                        ...c.drop(c.call(prefix + \"_add\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                        ...c.setLocal(\"signx\", c.i32_const(1))\n                    ]\n                ),\n                c.if(\n                    c.getLocal(\"signnewt\"),\n                    [\n                        ...c.drop(c.call(prefix + \"_add\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                        ...c.setLocal(\"signx\", c.i32_const(0))\n                    ],\n                    c.if (\n                        c.call(prefix + \"_gte\", c.getLocal(\"t\"), mulBuff),\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", c.getLocal(\"t\"), mulBuff, c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(0))\n                        ],\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(1))\n                        ]\n                    )\n                )\n            ),\n\n            c.setLocal(\"swp\", c.getLocal(\"t\")),\n            c.setLocal(\"t\", c.getLocal(\"newt\")),\n            c.setLocal(\"newt\", c.getLocal(\"x\")),\n            c.setLocal(\"x\", c.getLocal(\"swp\")),\n\n            c.setLocal(\"signt\", c.getLocal(\"signnewt\")),\n            c.setLocal(\"signnewt\", c.getLocal(\"signx\")),\n\n            c.setLocal(\"swp\", c.getLocal(\"r\")),\n            c.setLocal(\"r\", c.getLocal(\"newr\")),\n            c.setLocal(\"newr\", c.getLocal(\"qr\")),\n            c.setLocal(\"qr\", c.getLocal(\"swp\")),\n\n            c.br(0)\n        )));\n\n        f.addCode(c.if(\n            c.getLocal(\"signt\"),\n            c.drop(c.call(prefix + \"_sub\", c.getLocal(\"pm\"), c.getLocal(\"t\"), c.getLocal(\"pr\"))),\n            c.call(prefix + \"_copy\", c.getLocal(\"t\"), c.getLocal(\"pr\"))\n        ));\n    }\n\n\n    buildCopy();\n    buildZero();\n    buildIsZero();\n    buildOne();\n    buildEq();\n    buildGte();\n    buildAdd();\n    buildSub();\n    buildMul();\n    buildSquare();\n    buildSquareOld();\n    buildDiv();\n    buildInverseMod();\n    module.exportFunction(prefix+\"_copy\");\n    module.exportFunction(prefix+\"_zero\");\n    module.exportFunction(prefix+\"_one\");\n    module.exportFunction(prefix+\"_isZero\");\n    module.exportFunction(prefix+\"_eq\");\n    module.exportFunction(prefix+\"_gte\");\n    module.exportFunction(prefix+\"_add\");\n    module.exportFunction(prefix+\"_sub\");\n    module.exportFunction(prefix+\"_mul\");\n    module.exportFunction(prefix+\"_square\");\n    module.exportFunction(prefix+\"_squareOld\");\n    module.exportFunction(prefix+\"_div\");\n    module.exportFunction(prefix+\"_inverseMod\");\n\n    return prefix;\n};\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildTimesScalar(module, fnName, elementLen, opAB, opAA, opCopy, opInit) {\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"base\", \"i32\");\n    f.addParam(\"scalar\", \"i32\");\n    f.addParam(\"scalarLength\", \"i32\");\n    f.addParam(\"r\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"b\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const aux = c.i32_const(module.alloc(elementLen));\n\n    f.addCode(\n        c.if(\n            c.i32_eqz(c.getLocal(\"scalarLength\")),\n            [\n                ...c.call(opInit, c.getLocal(\"r\")),\n                ...c.ret([])\n            ]\n        )\n    );\n    f.addCode(c.call(opCopy, c.getLocal(\"base\"), aux));\n    f.addCode(c.call(opInit, c.getLocal(\"r\")));\n    f.addCode(c.setLocal(\"i\", c.getLocal(\"scalarLength\")));\n    f.addCode(c.block(c.loop(\n        c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n\n        c.setLocal(\n            \"b\",\n            c.i32_load8_u(\n                c.i32_add(\n                    c.getLocal(\"scalar\"),\n                    c.getLocal(\"i\")\n                )\n            )\n        ),\n        ...innerLoop(),\n        c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n        c.br(0)\n    )));\n\n\n    function innerLoop() {\n        const code = [];\n        for (let i=0; i<8; i++) {\n            code.push(\n                ...c.call(opAA, c.getLocal(\"r\"), c.getLocal(\"r\")),\n                ...c.if(\n                    c.i32_ge_u( c.getLocal(\"b\"), c.i32_const(0x80 >> i)),\n                    [\n                        ...c.setLocal(\n                            \"b\",\n                            c.i32_sub(\n                                c.getLocal(\"b\"),\n                                c.i32_const(0x80 >> i)\n                            )\n                        ),\n                        ...c.call(opAB, c.getLocal(\"r\"),aux, c.getLocal(\"r\"))\n                    ]\n                )\n            );\n        }\n        return code;\n    }\n\n};\n", "\nmodule.exports = buildBatchInverse;\n\nfunction buildBatchInverse(module, prefix) {\n\n\n    const n8 = module.modules[prefix].n64*8;\n\n    const f = module.addFunction(prefix+\"_batchInverse\");\n    f.addParam(\"pIn\", \"i32\");\n    f.addParam(\"inStep\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addParam(\"outStep\", \"i32\");\n    f.addLocal(\"itAux\", \"i32\");\n    f.addLocal(\"itIn\", \"i32\");\n    f.addLocal(\"itOut\",\"i32\");\n    f.addLocal(\"i\",\"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const AUX = c.i32_const(module.alloc(n8));\n\n\n    // Alloc Working space for accumulated umltiplications\n    f.addCode(\n        c.setLocal(\"itAux\", c.i32_load( c.i32_const(0) )),\n        c.i32_store(\n            c.i32_const(0),\n            c.i32_add(\n                c.getLocal(\"itAux\"),\n                c.i32_mul(\n                    c.i32_add(\n                        c.getLocal(\"n\"),\n                        c.i32_const(1)\n                    ),\n                    c.i32_const(n8)\n                )\n            )\n        )\n    );\n\n    f.addCode(\n\n        // aux[0] = a;\n        c.call(prefix+\"_one\", c.getLocal(\"itAux\")),\n        // for (i=0;i<n;i++) aux[i] = aux[i-1]*in[i]\n        c.setLocal(\"itIn\", c.getLocal(\"pIn\")),\n        c.setLocal(\"itAux\", c.i32_add(c.getLocal(\"itAux\"), c.i32_const(n8))),\n        c.setLocal(\"i\", c.i32_const(0)),\n\n        c.block(c.loop(\n            c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n            c.if(\n                c.call(prefix+\"_isZero\", c.getLocal(\"itIn\")),\n                c.call(\n                    prefix + \"_copy\",\n                    c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    c.getLocal(\"itAux\")\n                ),\n                c.call(\n                    prefix+\"_mul\",\n                    c.getLocal(\"itIn\"),\n                    c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    c.getLocal(\"itAux\")\n                )\n            ),\n            c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.getLocal(\"inStep\"))),\n            c.setLocal(\"itAux\", c.i32_add(c.getLocal(\"itAux\"), c.i32_const(n8))),\n            c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        )),\n\n        // point to the last\n        c.setLocal(\"itIn\", c.i32_sub(c.getLocal(\"itIn\"), c.getLocal(\"inStep\"))),\n        c.setLocal(\"itAux\", c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8))),\n        // itOut = pOut + (n-1)*stepOut   // Point to the last\n        c.setLocal(\n            \"itOut\",\n            c.i32_add(\n                c.getLocal(\"pOut\"),\n                c.i32_mul(\n                    c.i32_sub(c.getLocal(\"n\"), c.i32_const(1)),\n                    c.getLocal(\"outStep\"),\n                )\n            )\n        ),\n\n        // aux[n-1] = 1/aux[n-1]\n        c.call(prefix+\"_inverse\", c.getLocal(\"itAux\"), c.getLocal(\"itAux\") ),\n\n        c.block(c.loop(\n            c.br_if(1, c.i32_eqz( c.getLocal(\"i\"))),\n            c.if(\n                c.call(prefix+\"_isZero\", c.getLocal(\"itIn\")),\n                [\n                    ...c.call(\n                        prefix + \"_copy\",\n                        c.getLocal(\"itAux\"),\n                        c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    ),\n                    ...c.call(\n                        prefix + \"_zero\",\n                        c.getLocal(\"itOut\")\n                    )\n                ],[\n                    ...c.call(prefix + \"_copy\", c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)), AUX),\n                    ...c.call(\n                        prefix+\"_mul\",\n                        c.getLocal(\"itAux\"),\n                        c.getLocal(\"itIn\"),\n                        c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    ),\n                    ...c.call(\n                        prefix+\"_mul\",\n                        c.getLocal(\"itAux\"),\n                        AUX,\n                        c.getLocal(\"itOut\")\n                    )\n                ]\n            ),\n            c.setLocal(\"itIn\", c.i32_sub(c.getLocal(\"itIn\"), c.getLocal(\"inStep\"))),\n            c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.getLocal(\"outStep\"))),\n            c.setLocal(\"itAux\", c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8))),\n            c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        ))\n\n    );\n\n\n    // Recover Old memory\n    f.addCode(\n        c.i32_store(\n            c.i32_const(0),\n            c.getLocal(\"itAux\")\n        )\n    );\n\n}\n", "\n\nmodule.exports = buildBatchConvertion;\n\nfunction buildBatchConvertion(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {\n    if (typeof reverse === \"undefined\") {\n        // Set the reverse in a way that allows to use the same buffer as in/out.\n        if (sizeIn < sizeOut) {\n            reverse = true;\n        } else {\n            reverse = false;\n        }\n    }\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"pIn\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"itIn\", \"i32\");\n    f.addLocal(\"itOut\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    if (reverse) {\n        f.addCode(\n            c.setLocal(\"itIn\",\n                c.i32_add(\n                    c.getLocal(\"pIn\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeIn)\n                    )\n                )\n            ),\n            c.setLocal(\"itOut\",\n                c.i32_add(\n                    c.getLocal(\"pOut\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeOut)\n                    )\n                )\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn\", c.i32_sub(c.getLocal(\"itIn\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    } else {\n        f.addCode(\n            c.setLocal(\"itIn\", c.getLocal(\"pIn\")),\n            c.setLocal(\"itOut\", c.getLocal(\"pOut\")),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    }\n}\n", "\n\nmodule.exports = buildBatchConvertion;\n\nfunction buildBatchConvertion(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {\n    if (typeof reverse === \"undefined\") {\n        // Set the reverse in a way that allows to use the same buffer as in/out.\n        if (sizeIn < sizeOut) {\n            reverse = true;\n        } else {\n            reverse = false;\n        }\n    }\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"pIn1\", \"i32\");\n    f.addParam(\"pIn2\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"itIn1\", \"i32\");\n    f.addLocal(\"itIn2\", \"i32\");\n    f.addLocal(\"itOut\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    if (reverse) {\n        f.addCode(\n            c.setLocal(\"itIn1\",\n                c.i32_add(\n                    c.getLocal(\"pIn1\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeIn)\n                    )\n                )\n            ),\n            c.setLocal(\"itIn2\",\n                c.i32_add(\n                    c.getLocal(\"pIn2\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeIn)\n                    )\n                )\n            ),\n            c.setLocal(\"itOut\",\n                c.i32_add(\n                    c.getLocal(\"pOut\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeOut)\n                    )\n                )\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn1\"), c.getLocal(\"itIn2\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn1\", c.i32_sub(c.getLocal(\"itIn1\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itIn2\", c.i32_sub(c.getLocal(\"itIn2\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    } else {\n        f.addCode(\n            c.setLocal(\"itIn1\", c.getLocal(\"pIn1\")),\n            c.setLocal(\"itIn2\", c.getLocal(\"pIn2\")),\n            c.setLocal(\"itOut\", c.getLocal(\"pOut\")),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn1\"), c.getLocal(\"itIn2\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn1\", c.i32_add(c.getLocal(\"itIn1\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itIn2\", c.i32_add(c.getLocal(\"itIn2\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    }\n}\n", "// Many of these utilities are from the `big-integer` library,\n// but adjusted to only work with native BigInt type\n// Ref https://github.com/peterolson/BigInteger.js/blob/e5d2154d3c417069c51e7116bafc3b91d0b9fe41/BigInteger.js\n// Originally licensed The Unlicense\n\nfunction compare(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction square(n) {\n    return n * n;\n}\n\nfunction isOdd(n) {\n    return n % 2n !== 0n;\n}\n\nfunction isEven(n) {\n    return n % 2n === 0n;\n}\n\nfunction isNegative(n) {\n    return n < 0n;\n}\n\nfunction isPositive(n) {\n    return n > 0n;\n}\n\nfunction bitLength(n) {\n    if (isNegative(n)) {\n        return n.toString(2).length - 1; // discard the - sign\n    } else {\n        return n.toString(2).length;\n    }\n}\n\nfunction abs(n) {\n    return n < 0n ? -n : n;\n}\n\nfunction isUnit(n) {\n    return abs(n) === 1n;\n}\n\nfunction modInv(a, n) {\n    var t = 0n, newT = 1n, r = n, newR = abs(a), q, lastT, lastR;\n    while (newR !== 0n) {\n        q = r / newR;\n        lastT = t;\n        lastR = r;\n        t = newT;\n        r = newR;\n        newT = lastT - (q * newT);\n        newR = lastR - (q * newR);\n    }\n    if (!isUnit(r)) throw new Error(a.toString() + \" and \" + n.toString() + \" are not co-prime\");\n    if (compare(t, 0n) === -1) {\n        t = t + n;\n    }\n    if (isNegative(a)) {\n        return -t;\n    }\n    return t;\n}\n\nfunction modPow(n, exp, mod) {\n    if (mod === 0n) throw new Error(\"Cannot take modPow with modulus 0\");\n    var r = 1n,\n        base = n % mod;\n    if (isNegative(exp)) {\n        exp = exp * -1n;\n        base = modInv(base, mod);\n    }\n    while (isPositive(exp)) {\n        if (base === 0n) return 0n;\n        if (isOdd(exp)) r = r * base % mod;\n        exp = exp / 2n;\n        base = square(base) % mod;\n    }\n    return r;\n}\n\nfunction compareAbs(a, b) {\n    a = a >= 0n ? a : -a;\n    b = b >= 0n ? b : -b;\n    return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction isDivisibleBy(a, n) {\n    if (n === 0n) return false;\n    if (isUnit(n)) return true;\n    if (compareAbs(n, 2n) === 0) return isEven(a);\n    return a % n === 0n;\n}\n\nfunction isBasicPrime(v) {\n    var n = abs(v);\n    if (isUnit(n)) return false;\n    if (n === 2n || n === 3n || n === 5n) return true;\n    if (isEven(n) || isDivisibleBy(n, 3n) || isDivisibleBy(n, 5n)) return false;\n    if (n < 49n) return true;\n    // we don't know if it's prime: let the other functions figure it out\n}\n\nfunction prev(n) {\n    return n - 1n;\n}\n\nfunction millerRabinTest(n, a) {\n    var nPrev = prev(n),\n        b = nPrev,\n        r = 0,\n        d, i, x;\n    while (isEven(b)) b = b / 2n, r++;\n    next: for (i = 0; i < a.length; i++) {\n        if (n < a[i]) continue;\n        x = modPow(BigInt(a[i]), b, n);\n        if (isUnit(x) || x === nPrev) continue;\n        for (d = r - 1; d != 0; d--) {\n            x = square(x) % n;\n            if (isUnit(x)) return false;\n            if (x === nPrev) continue next;\n        }\n        return false;\n    }\n    return true;\n}\n\nfunction isPrime(p) {\n    var isPrime = isBasicPrime(p);\n    if (isPrime !== undefined) return isPrime;\n    var n = abs(p);\n    var bits = bitLength(n);\n    if (bits <= 64)\n        return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\n    var logN = Math.log(2) * Number(bits);\n    var t = Math.ceil(logN);\n    for (var a = [], i = 0; i < t; i++) {\n        a.push(BigInt(i + 2));\n    }\n    return millerRabinTest(n, a);\n}\n\nmodule.exports.bitLength = bitLength;\nmodule.exports.isOdd = isOdd;\nmodule.exports.isNegative = isNegative;\nmodule.exports.abs = abs;\nmodule.exports.isUnit = isUnit;\nmodule.exports.compare = compare;\nmodule.exports.modInv = modInv;\nmodule.exports.modPow = modPow;\nmodule.exports.isPrime = isPrime;\nmodule.exports.square = square;\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst buildInt = require(\"./build_int.js\");\nconst utils = require(\"./utils.js\");\nconst buildExp = require(\"./build_timesscalar\");\nconst buildBatchInverse = require(\"./build_batchinverse\");\nconst buildBatchConvertion = require(\"./build_batchconvertion\");\nconst buildBatchOp = require(\"./build_batchop\");\nconst { bitLength, modInv, modPow, isPrime, isOdd, square } = require(\"./bigint.js\");\n\nmodule.exports = function buildF1m(module, _q, _prefix, _intPrefix) {\n    const q = BigInt(_q);\n    const n64 = Math.floor((bitLength(q - 1n) - 1)/64) +1;\n    const n32 = n64*2;\n    const n8 = n64*8;\n\n    const prefix = _prefix || \"f1m\";\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const intPrefix = buildInt(module, n64, _intPrefix);\n    const pq = module.alloc(n8, utils.bigInt2BytesLE(q, n8));\n\n    const pR2 = module.alloc(utils.bigInt2BytesLE(square(1n << BigInt(n64*64)) % q, n8));\n    const pOne = module.alloc(utils.bigInt2BytesLE((1n << BigInt(n64*64)) % q, n8));\n    const pZero = module.alloc(utils.bigInt2BytesLE(0n, n8));\n    const _minusOne = q - 1n;\n    const _e = _minusOne >> 1n; // e = (p-1)/2\n    const pe = module.alloc(n8, utils.bigInt2BytesLE(_e, n8));\n\n    const _ePlusOne = _e + 1n; // e = (p-1)/2\n    const pePlusOne = module.alloc(n8, utils.bigInt2BytesLE(_ePlusOne, n8));\n\n    module.modules[prefix] = {\n        pq: pq,\n        pR2: pR2,\n        n64: n64,\n        q: q,\n        pOne: pOne,\n        pZero: pZero,\n        pePlusOne: pePlusOne\n    };\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(intPrefix + \"_copy\", c.i32_const(pOne), c.getLocal(\"pr\")));\n    }\n\n    function buildAdd() {\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.call(intPrefix+\"_add\", c.getLocal(\"x\"),  c.getLocal(\"y\"), c.getLocal(\"r\")),\n                c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                c.if(\n                    c.call(intPrefix+\"_gte\", c.getLocal(\"r\"), c.i32_const(pq)  ),\n                    c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                )\n            )\n        );\n    }\n\n    function buildSub() {\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.call(intPrefix+\"_sub\", c.getLocal(\"x\"),  c.getLocal(\"y\"), c.getLocal(\"r\")),\n                c.drop(c.call(intPrefix+\"_add\", c.getLocal(\"r\"),  c.i32_const(pq), c.getLocal(\"r\")))\n            )\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix+\"_neg\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(prefix + \"_sub\", c.i32_const(pZero), c.getLocal(\"x\"), c.getLocal(\"r\"))\n        );\n    }\n\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(prefix + \"_fromMontgomery\", c.getLocal(\"x\"), AUX),\n            c.call(intPrefix + \"_gte\", AUX, c.i32_const(pePlusOne) )\n        );\n    }\n\n    function buildSign() {\n        const f = module.addFunction(prefix+\"_sign\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if (\n                c.call(intPrefix + \"_isZero\", c.getLocal(\"x\")),\n                c.ret(c.i32_const(0))\n            ),\n            c.call(prefix + \"_fromMontgomery\", c.getLocal(\"x\"), AUX),\n            c.if(\n                c.call(intPrefix + \"_gte\", AUX, c.i32_const(pePlusOne)),\n                c.ret(c.i32_const(-1))\n            ),\n            c.ret(c.i32_const(1))\n        );\n    }\n\n\n    function buildMReduct() {\n        const carries = module.alloc(n32*n32*8);\n\n        const f = module.addFunction(prefix+\"_mReduct\");\n        f.addParam(\"t\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"np32\", \"i64\");\n        f.addLocal(\"c\", \"i64\");\n        f.addLocal(\"m\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));\n\n        f.addCode(c.setLocal(\"np32\", c.i64_const(np32)));\n\n        for (let i=0; i<n32; i++) {\n            f.addCode(c.setLocal(\"c\", c.i64_const(0)));\n\n            f.addCode(\n                c.setLocal(\n                    \"m\",\n                    c.i64_and(\n                        c.i64_mul(\n                            c.i64_load32_u(c.getLocal(\"t\"), i*4),\n                            c.getLocal(\"np32\")\n                        ),\n                        c.i64_const(\"0xFFFFFFFF\")\n                    )\n                )\n            );\n\n            for (let j=0; j<n32; j++) {\n\n                f.addCode(\n                    c.setLocal(\"c\",\n                        c.i64_add(\n                            c.i64_add(\n                                c.i64_load32_u(c.getLocal(\"t\"), (i+j)*4),\n                                c.i64_shr_u(c.getLocal(\"c\"), c.i64_const(32))\n                            ),\n                            c.i64_mul(\n                                c.i64_load32_u(c.i32_const(pq), j*4),\n                                c.getLocal(\"m\")\n                            )\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.i64_store32(\n                        c.getLocal(\"t\"),\n                        (i+j)*4,\n                        c.getLocal(\"c\")\n                    )\n                );\n            }\n\n            f.addCode(\n                c.i64_store32(\n                    c.i32_const(carries),\n                    i*4,\n                    c.i64_shr_u(c.getLocal(\"c\"), c.i64_const(32))\n                )\n            );\n        }\n\n        f.addCode(\n            c.call(\n                prefix+\"_add\",\n                c.i32_const(carries),\n                c.i32_add(\n                    c.getLocal(\"t\"),\n                    c.i32_const(n32*4)\n                ),\n                c.getLocal(\"r\")\n            )\n        );\n    }\n\n\n\n    function buildMul() {\n\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n        f.addLocal(\"np32\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n            f.addLocal(\"y\"+i, \"i64\");\n            f.addLocal(\"m\"+i, \"i64\");\n            f.addLocal(\"q\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));\n\n        f.addCode(c.setLocal(\"np32\", c.i64_const(np32)));\n\n\n        const loadX = [];\n        const loadY = [];\n        const loadQ = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadY[j]) {\n                Y = c.teeLocal(\"y\"+j, c.i64_load32_u( c.getLocal(\"y\"), j*4));\n                loadY[j] = true;\n            } else {\n                Y = c.getLocal(\"y\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        function mulqm(i, j) {\n            let Q,M;\n            if (!loadQ[i]) {\n                Q = c.teeLocal(\"q\"+i, c.i64_load32_u(c.i32_const(0), pq+i*4 ));\n                loadQ[i] = true;\n            } else {\n                Q = c.getLocal(\"q\"+i);\n            }\n            M = c.getLocal(\"m\"+j);\n\n            return c.i64_mul( Q, M );\n        }\n\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            for (let i=Math.max(0, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n\n            for (let i=Math.max(1, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n            if (k<n32) {\n                f.addCode(\n                    c.setLocal(\n                        \"m\"+k,\n                        c.i64_and(\n                            c.i64_mul(\n                                c.i64_and(\n                                    c.getLocal(c0),\n                                    c.i64_const(0xFFFFFFFF)\n                                ),\n                                c.getLocal(\"np32\")\n                            ),\n                            c.i64_const(\"0xFFFFFFFF\")\n                        )\n                    )\n                );\n\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(0,k)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n\n            if (k>=n32) {\n                f.addCode(\n                    c.i64_store32(\n                        c.getLocal(\"r\"),\n                        (k-n32)*4,\n                        c.getLocal(c0)\n                    )\n                );\n            }\n            [c0, c1] = [c1, c0];\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_shr_u(\n                        c.getLocal(c0),\n                        c.i64_const(32)\n                    )\n                )\n            );\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4-4,\n                c.getLocal(c0)\n            )\n        );\n\n        f.addCode(\n            c.if(\n                c.i32_wrap_i64(c.getLocal(c1)),\n                c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                c.if(\n                    c.call(intPrefix+\"_gte\", c.getLocal(\"r\"), c.i32_const(pq)  ),\n                    c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                )\n            )\n        );\n    }\n\n\n    function buildSquare() {\n\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n        f.addLocal(\"c0_old\", \"i64\");\n        f.addLocal(\"c1_old\", \"i64\");\n        f.addLocal(\"np32\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n            f.addLocal(\"m\"+i, \"i64\");\n            f.addLocal(\"q\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));\n\n        f.addCode(c.setLocal(\"np32\", c.i64_const(np32)));\n\n\n        const loadX = [];\n        const loadQ = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadX[j]) {\n                Y = c.teeLocal(\"x\"+j, c.i64_load32_u( c.getLocal(\"x\"), j*4));\n                loadX[j] = true;\n            } else {\n                Y = c.getLocal(\"x\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        function mulqm(i, j) {\n            let Q,M;\n            if (!loadQ[i]) {\n                Q = c.teeLocal(\"q\"+i, c.i64_load32_u(c.i32_const(0), pq+i*4 ));\n                loadQ[i] = true;\n            } else {\n                Q = c.getLocal(\"q\"+i);\n            }\n            M = c.getLocal(\"m\"+j);\n\n            return c.i64_mul( Q, M );\n        }\n\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n        let c0_old = \"c0_old\";\n        let c1_old = \"c1_old\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            f.addCode(\n                c.setLocal(c0, c.i64_const(0)),\n                c.setLocal(c1, c.i64_const(0)),\n            );\n            for (let i=Math.max(0, k-n32+1); (i<((k+1)>>1) )&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Multiply by 2\n            f.addCode(\n                c.setLocal(c0,\n                    c.i64_shl(\n                        c.i64_and(\n                            c.getLocal(c0),\n                            c.i64_const(0xFFFFFFFF)\n                        ),\n                        c.i64_const(1)\n                    )\n                )\n            );\n\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_add(\n                        c.i64_shl(\n                            c.getLocal(c1),\n                            c.i64_const(1)\n                        ),\n                        c.i64_shr_u(\n                            c.getLocal(c0),\n                            c.i64_const(32)\n                        )\n                    )\n                )\n            );\n\n            if (k%2 == 0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(k>>1, k>>1)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Add the old carry\n\n            if (k>0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            c.i64_and(\n                                c.getLocal(c0_old),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.i64_add(\n                                c.getLocal(c1),\n                                c.i64_shr_u(\n                                    c.getLocal(c0),\n                                    c.i64_const(32)\n                                )\n                            ),\n                            c.getLocal(c1_old)\n                        )\n                    )\n                );\n            }\n\n\n            for (let i=Math.max(1, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n            if (k<n32) {\n                f.addCode(\n                    c.setLocal(\n                        \"m\"+k,\n                        c.i64_and(\n                            c.i64_mul(\n                                c.i64_and(\n                                    c.getLocal(c0),\n                                    c.i64_const(0xFFFFFFFF)\n                                ),\n                                c.getLocal(\"np32\")\n                            ),\n                            c.i64_const(\"0xFFFFFFFF\")\n                        )\n                    )\n                );\n\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(0,k)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            if (k>=n32) {\n                f.addCode(\n                    c.i64_store32(\n                        c.getLocal(\"r\"),\n                        (k-n32)*4,\n                        c.getLocal(c0)\n                    )\n                );\n            }\n            f.addCode(\n                c.setLocal(\n                    c0_old,\n                    c.getLocal(c1)\n                ),\n                c.setLocal(\n                    c1_old,\n                    c.i64_shr_u(\n                        c.getLocal(c0_old),\n                        c.i64_const(32)\n                    )\n                )\n            );\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4-4,\n                c.getLocal(c0_old)\n            )\n        );\n\n        f.addCode(\n            c.if(\n                c.i32_wrap_i64(c.getLocal(c1_old)),\n                c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                c.if(\n                    c.call(intPrefix+\"_gte\", c.getLocal(\"r\"), c.i32_const(pq)  ),\n                    c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                )\n            )\n        );\n    }\n\n\n    function buildSquareOld() {\n        const f = module.addFunction(prefix+\"_squareOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(prefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"x\"), c.getLocal(\"r\")));\n    }\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix+\"_toMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(prefix+\"_mul\", c.getLocal(\"x\"), c.i32_const(pR2), c.getLocal(\"r\")));\n    }\n\n    function buildFromMontgomery() {\n\n        const pAux2 = module.alloc(n8*2);\n\n        const f = module.addFunction(prefix+\"_fromMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(intPrefix + \"_copy\", c.getLocal(\"x\"), c.i32_const(pAux2) ));\n        f.addCode(c.call(intPrefix + \"_zero\", c.i32_const(pAux2 + n8) ));\n        f.addCode(c.call(prefix+\"_mReduct\", c.i32_const(pAux2), c.getLocal(\"r\")));\n    }\n\n    function buildInverse() {\n\n        const f = module.addFunction(prefix+ \"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(prefix + \"_fromMontgomery\", c.getLocal(\"x\"), c.getLocal(\"r\")));\n        f.addCode(c.call(intPrefix + \"_inverseMod\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\")));\n        f.addCode(c.call(prefix + \"_toMontgomery\", c.getLocal(\"r\"), c.getLocal(\"r\")));\n    }\n\n    // Calculate various valuse needed for sqrt\n\n\n    let _nqr = 2n;\n    if (isPrime(q)) {\n        while (modPow(_nqr, _e, q) !== _minusOne) _nqr = _nqr + 1n;\n    }\n\n    let s2 = 0;\n    let _t = _minusOne;\n\n    while ((!isOdd(_t))&&(_t !== 0n)) {\n        s2++;\n        _t = _t >> 1n;\n    }\n    const pt = module.alloc(n8, utils.bigInt2BytesLE(_t, n8));\n\n    const _nqrToT = modPow(_nqr, _t, q);\n    const pNqrToT = module.alloc(utils.bigInt2BytesLE((_nqrToT << BigInt(n64*64)) % q, n8));\n\n    const _tPlusOneOver2 = (_t + 1n) >> 1n;\n    const ptPlusOneOver2 = module.alloc(n8, utils.bigInt2BytesLE(_tPlusOneOver2, n8));\n\n    function buildSqrt() {\n\n        const f = module.addFunction(prefix+ \"_sqrt\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"m\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const ONE = c.i32_const(pOne);\n        const C = c.i32_const(module.alloc(n8));\n        const T = c.i32_const(module.alloc(n8));\n        const R = c.i32_const(module.alloc(n8));\n        const SQ = c.i32_const(module.alloc(n8));\n        const B = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n\n            // If (n==0) return 0\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"n\")),\n                c.ret(\n                    c.call(prefix + \"_zero\", c.getLocal(\"r\"))\n                )\n            ),\n\n            c.setLocal(\"m\", c.i32_const(s2)),\n            c.call(prefix + \"_copy\", c.i32_const(pNqrToT), C),\n            c.call(prefix + \"_exp\", c.getLocal(\"n\"), c.i32_const(pt), c.i32_const(n8), T),\n            c.call(prefix + \"_exp\", c.getLocal(\"n\"), c.i32_const(ptPlusOneOver2), c.i32_const(n8), R),\n\n            c.block(c.loop(\n                c.br_if(1, c.call(prefix + \"_eq\", T, ONE)),\n\n                c.call(prefix + \"_square\", T, SQ),\n                c.setLocal(\"i\", c.i32_const(1)),\n                c.block(c.loop(\n                    c.br_if(1, c.call(prefix + \"_eq\", SQ, ONE)),\n                    c.call(prefix + \"_square\", SQ, SQ),\n                    c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n\n                c.call(prefix + \"_copy\", C, B),\n                c.setLocal(\"j\", c.i32_sub(c.i32_sub( c.getLocal(\"m\"), c.getLocal(\"i\")), c.i32_const(1)) ),\n                c.block(c.loop(\n                    c.br_if(1, c.i32_eqz(c.getLocal(\"j\"))),\n                    c.call(prefix + \"_square\", B, B),\n                    c.setLocal(\"j\", c.i32_sub(c.getLocal(\"j\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n\n                c.setLocal(\"m\", c.getLocal(\"i\")),\n                c.call(prefix + \"_square\", B, C),\n                c.call(prefix + \"_mul\", T, C, T),\n                c.call(prefix + \"_mul\", R, B, R),\n\n                c.br(0)\n            )),\n\n            c.if(\n                c.call(prefix + \"_isNegative\", R),\n                c.call(prefix + \"_neg\", R, c.getLocal(\"r\")),\n                c.call(prefix + \"_copy\", R, c.getLocal(\"r\")),\n            )\n        );\n    }\n\n    function buildIsSquare() {\n        const f = module.addFunction(prefix+\"_isSquare\");\n        f.addParam(\"n\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const ONE = c.i32_const(pOne);\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"n\")),\n                c.ret(c.i32_const(1))\n            ),\n            c.call(prefix + \"_exp\", c.getLocal(\"n\"), c.i32_const(pe), c.i32_const(n8), AUX),\n            c.call(prefix + \"_eq\", AUX, ONE)\n        );\n    }\n\n\n    function buildLoad() {\n        const f = module.addFunction(prefix+\"_load\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"p\", \"i32\");\n        f.addLocal(\"l\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        const c = f.getCodeBuilder();\n\n        const R = c.i32_const(module.alloc(n8));\n        const pAux = module.alloc(n8);\n        const AUX = c.i32_const(pAux);\n\n        f.addCode(\n            c.call(intPrefix + \"_zero\", c.getLocal(\"r\")),\n            c.setLocal(\"i\", c.i32_const(n8)),\n            c.setLocal(\"p\", c.getLocal(\"scalar\")),\n            c.block(c.loop(\n                c.br_if(1, c.i32_gt_u(c.getLocal(\"i\"), c.getLocal(\"scalarLen\"))),\n\n                c.if(\n                    c.i32_eq(c.getLocal(\"i\"), c.i32_const(n8)),\n                    c.call(prefix + \"_one\", R),\n                    c.call(prefix + \"_mul\", R, c.i32_const(pR2), R)\n                ),\n                c.call(prefix + \"_mul\", c.getLocal(\"p\"), R, AUX),\n                c.call(prefix + \"_add\", c.getLocal(\"r\"), AUX, c.getLocal(\"r\")),\n\n                c.setLocal(\"p\", c.i32_add(c.getLocal(\"p\"), c.i32_const(n8))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(n8))),\n                c.br(0)\n            )),\n\n            c.setLocal(\"l\", c.i32_rem_u( c.getLocal(\"scalarLen\"), c.i32_const(n8))),\n            c.if(c.i32_eqz(c.getLocal(\"l\")), c.ret([])),\n            c.call(intPrefix + \"_zero\", AUX),\n            c.setLocal(\"j\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq(c.getLocal(\"j\"), c.getLocal(\"l\"))),\n\n                c.i32_store8(\n                    c.getLocal(\"j\"),\n                    pAux,\n                    c.i32_load8_u(c.getLocal(\"p\")),\n                ),\n                c.setLocal(\"p\", c.i32_add(c.getLocal(\"p\"), c.i32_const(1))),\n                c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            c.if(\n                c.i32_eq(c.getLocal(\"i\"), c.i32_const(n8)),\n                c.call(prefix + \"_one\", R),\n                c.call(prefix + \"_mul\", R, c.i32_const(pR2), R)\n            ),\n            c.call(prefix + \"_mul\", AUX, R, AUX),\n            c.call(prefix + \"_add\", c.getLocal(\"r\"), AUX, c.getLocal(\"r\")),\n        );\n    }\n\n    function buildTimesScalar() {\n        const f = module.addFunction(prefix+\"_timesScalar\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(prefix + \"_load\", c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), AUX),\n            c.call(prefix + \"_toMontgomery\", AUX, AUX),\n            c.call(prefix + \"_mul\", c.getLocal(\"x\"), AUX, c.getLocal(\"r\")),\n        );\n    }\n\n    function buildIsOne() {\n        const f = module.addFunction(prefix+\"_isOne\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(\n            c.ret(c.call(intPrefix + \"_eq\", c.getLocal(\"x\"), c.i32_const(pOne)))\n        );\n    }\n\n\n    module.exportFunction(intPrefix + \"_copy\", prefix+\"_copy\");\n    module.exportFunction(intPrefix + \"_zero\", prefix+\"_zero\");\n    module.exportFunction(intPrefix + \"_isZero\", prefix+\"_isZero\");\n    module.exportFunction(intPrefix + \"_eq\", prefix+\"_eq\");\n\n    buildIsOne();\n    buildAdd();\n    buildSub();\n    buildNeg();\n    buildMReduct();\n    buildMul();\n    buildSquare();\n    buildSquareOld();\n    buildToMontgomery();\n    buildFromMontgomery();\n    buildIsNegative();\n    buildSign();\n    buildInverse();\n    buildOne();\n    buildLoad();\n    buildTimesScalar();\n    buildBatchInverse(module, prefix);\n    buildBatchConvertion(module, prefix + \"_batchToMontgomery\", prefix + \"_toMontgomery\", n8, n8);\n    buildBatchConvertion(module, prefix + \"_batchFromMontgomery\", prefix + \"_fromMontgomery\", n8, n8);\n    buildBatchConvertion(module, prefix + \"_batchNeg\", prefix + \"_neg\", n8, n8);\n    buildBatchOp(module, prefix + \"_batchAdd\", prefix + \"_add\", n8, n8);\n    buildBatchOp(module, prefix + \"_batchSub\", prefix + \"_sub\", n8, n8);\n    buildBatchOp(module, prefix + \"_batchMul\", prefix + \"_mul\", n8, n8);\n\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_isNegative\");\n    module.exportFunction(prefix + \"_isOne\");\n    module.exportFunction(prefix + \"_sign\");\n    module.exportFunction(prefix + \"_mReduct\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_squareOld\");\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_inverse\");\n    module.exportFunction(prefix + \"_one\");\n    module.exportFunction(prefix + \"_load\");\n    module.exportFunction(prefix + \"_timesScalar\");\n    buildExp(\n        module,\n        prefix + \"_exp\",\n        n8,\n        prefix + \"_mul\",\n        prefix + \"_square\",\n        intPrefix + \"_copy\",\n        prefix + \"_one\",\n    );\n    module.exportFunction(prefix + \"_exp\");\n    module.exportFunction(prefix + \"_batchInverse\");\n    if (isPrime(q)) {\n        buildSqrt();\n        buildIsSquare();\n        module.exportFunction(prefix + \"_sqrt\");\n        module.exportFunction(prefix + \"_isSquare\");\n    }\n    module.exportFunction(prefix + \"_batchToMontgomery\");\n    module.exportFunction(prefix + \"_batchFromMontgomery\");\n    // console.log(module.functionIdxByName);\n\n    return prefix;\n};\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst buildF1m =require(\"./build_f1m.js\");\nconst { bitLength } = require(\"./bigint.js\");\n\nmodule.exports = function buildF1(module, _q, _prefix, _f1mPrefix, _intPrefix) {\n\n    const q = BigInt(_q);\n    const n64 = Math.floor((bitLength(q - 1n) - 1)/64) +1;\n    const n8 = n64*8;\n\n    const prefix = _prefix || \"f1\";\n    if (module.modules[prefix]) return prefix;  // already builded\n    module.modules[prefix] = {\n        n64: n64\n    };\n\n    const intPrefix = _intPrefix || \"int\";\n    const f1mPrefix = buildF1m(module, q, _f1mPrefix, intPrefix);\n\n\n    const pR2 =     module.modules[f1mPrefix].pR2;\n    const pq =     module.modules[f1mPrefix].pq;\n    const pePlusOne = module.modules[f1mPrefix].pePlusOne;\n\n    function buildMul() {\n        const pAux1 = module.alloc(n8);\n\n        const f = module.addFunction(prefix+ \"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(f1mPrefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"y\"), c.i32_const(pAux1)));\n        f.addCode(c.call(f1mPrefix + \"_mul\", c.i32_const(pAux1), c.i32_const(pR2), c.getLocal(\"r\")));\n    }\n\n    function buildSquare() {\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(prefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"x\"), c.getLocal(\"r\")));\n    }\n\n\n    function buildInverse() {\n\n        const f = module.addFunction(prefix+ \"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(intPrefix + \"_inverseMod\", c.getLocal(\"x\"), c.i32_const(pq), c.getLocal(\"r\")));\n    }\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(intPrefix + \"_gte\", c.getLocal(\"x\"), c.i32_const(pePlusOne) )\n        );\n    }\n\n\n    buildMul();\n    buildSquare();\n    buildInverse();\n    buildIsNegative();\n    module.exportFunction(f1mPrefix + \"_add\", prefix + \"_add\");\n    module.exportFunction(f1mPrefix + \"_sub\", prefix + \"_sub\");\n    module.exportFunction(f1mPrefix + \"_neg\", prefix + \"_neg\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_inverse\");\n    module.exportFunction(prefix + \"_isNegative\");\n    module.exportFunction(f1mPrefix + \"_copy\", prefix+\"_copy\");\n    module.exportFunction(f1mPrefix + \"_zero\", prefix+\"_zero\");\n    module.exportFunction(f1mPrefix + \"_one\", prefix+\"_one\");\n    module.exportFunction(f1mPrefix + \"_isZero\", prefix+\"_isZero\");\n    module.exportFunction(f1mPrefix + \"_eq\", prefix+\"_eq\");\n\n    return prefix;\n};\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst buildExp = require(\"./build_timesscalar\");\nconst buildBatchInverse = require(\"./build_batchinverse\");\nconst utils = require(\"./utils.js\");\n\nmodule.exports = function buildF2m(module, mulNonResidueFn, prefix, f1mPrefix) {\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const f1n8 = module.modules[f1mPrefix].n64*8;\n    const q = module.modules[f1mPrefix].q;\n\n    module.modules[prefix] = {\n        n64: module.modules[f1mPrefix].n64*2\n    };\n\n    function buildAdd() {\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_add\", x0, y0, r0),\n            c.call(f1mPrefix+\"_add\", x1, y1, r1),\n        );\n    }\n\n    function buildTimesScalar() {\n        const f = module.addFunction(prefix+\"_timesScalar\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_timesScalar\", x0, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r0),\n            c.call(f1mPrefix+\"_timesScalar\", x1, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r1),\n        );\n    }\n\n    function buildSub() {\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_sub\", x0, y0, r0),\n            c.call(f1mPrefix+\"_sub\", x1, y1, r1),\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix+\"_neg\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_neg\", x0, r0),\n            c.call(f1mPrefix+\"_neg\", x1, r1),\n        );\n    }\n\n    function buildConjugate() {\n        const f = module.addFunction(prefix+\"_conjugate\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, r0),\n            c.call(f1mPrefix+\"_neg\", x1, r1),\n        );\n    }\n\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.if(\n                c.call(f1mPrefix+\"_isZero\", x1),\n                c.ret(c.call(f1mPrefix+\"_isNegative\", x0))\n            ),\n            c.ret(c.call(f1mPrefix+\"_isNegative\", x1))\n        );\n    }\n\n    function buildMul() {\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        const A = c.i32_const(module.alloc(f1n8));\n        const B = c.i32_const(module.alloc(f1n8));\n        const C = c.i32_const(module.alloc(f1n8));\n        const D = c.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n            c.call(f1mPrefix + \"_mul\", x0, y0, A),             // A = x0*y0\n            c.call(f1mPrefix + \"_mul\", x1, y1, B),             // B = x1*y1\n\n            c.call(f1mPrefix + \"_add\", x0, x1, C),             // C = x0 + x1\n            c.call(f1mPrefix + \"_add\", y0, y1, D),             // D = y0 + y1\n            c.call(f1mPrefix + \"_mul\", C, D, C),               // C = (x0 + x1)*(y0 + y1) = x0*y0+x0*y1+x1*y0+x1*y1\n\n            //  c.call(f1mPrefix + \"_mul\", B, c.i32_const(pNonResidue), r0),  // r0 = nr*(x1*y1)\n            c.call(mulNonResidueFn, B, r0),  // r0 = nr*(x1*y1)\n            c.call(f1mPrefix + \"_add\", A, r0, r0),             // r0 = x0*y0 + nr*(x1*y1)\n            c.call(f1mPrefix + \"_add\", A, B, r1),             // r1 = x0*y0+x1*y1\n            c.call(f1mPrefix + \"_sub\", C, r1, r1)              // r1 = x0*y0+x0*y1+x1*y0+x1*y1 - x0*y0+x1*y1 = x0*y1+x1*y0\n        );\n\n    }\n\n    function buildMul1() {\n        const f = module.addFunction(prefix+\"_mul1\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y = c.getLocal(\"y\");\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n\n        f.addCode(\n            c.call(f1mPrefix + \"_mul\", x0, y, r0),             // A = x0*y\n            c.call(f1mPrefix + \"_mul\", x1, y, r1),             // B = x1*y\n        );\n    }\n\n    function buildSquare() {\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        const AB = c.i32_const(module.alloc(f1n8));\n        const APB = c.i32_const(module.alloc(f1n8));\n        const APNB = c.i32_const(module.alloc(f1n8));\n        const ABPNAB = c.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n            // AB = x0*y1\n            c.call(f1mPrefix + \"_mul\", x0, x1, AB),\n\n            // APB = x0+y1\n            c.call(f1mPrefix + \"_add\", x0, x1, APB),\n\n            // APBN0 = x0 + nr*x1\n            c.call(mulNonResidueFn, x1, APNB),\n            c.call(f1mPrefix + \"_add\", x0, APNB, APNB),\n\n            // ABPNAB = ab + nr*ab\n            c.call(mulNonResidueFn, AB, ABPNAB),\n            c.call(f1mPrefix + \"_add\", ABPNAB, AB, ABPNAB),\n\n            // r0 = APB * APNB - ABPNAB\n            c.call(f1mPrefix + \"_mul\", APB, APNB, r0),\n            c.call(f1mPrefix + \"_sub\", r0, ABPNAB, r0),\n\n            // r1 = AB + AB\n            c.call(f1mPrefix + \"_add\", AB, AB, r1),\n        );\n\n    }\n\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix+\"_toMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_toMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_toMontgomery\", x1, r1)\n        );\n    }\n\n    function buildFromMontgomery() {\n        const f = module.addFunction(prefix+\"_fromMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_fromMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_fromMontgomery\", x1, r1)\n        );\n    }\n\n    function buildCopy() {\n        const f = module.addFunction(prefix+\"_copy\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, r0),\n            c.call(f1mPrefix+\"_copy\", x1, r1)\n        );\n    }\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_zero\", x0),\n            c.call(f1mPrefix+\"_zero\", x1)\n        );\n    }\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_one\", x0),\n            c.call(f1mPrefix+\"_zero\", x1)\n        );\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix+\"_eq\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.call(f1mPrefix+\"_eq\", x0, y0),\n                c.call(f1mPrefix+\"_eq\", x1, y1)\n            )\n        );\n    }\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix+\"_isZero\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.call(f1mPrefix+\"_isZero\", x0),\n                c.call(f1mPrefix+\"_isZero\", x1)\n            )\n        );\n    }\n\n    function buildInverse() {\n        const f = module.addFunction(prefix+\"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        const t0 = c.i32_const(module.alloc(f1n8));\n        const t1 = c.i32_const(module.alloc(f1n8));\n        const t2 = c.i32_const(module.alloc(f1n8));\n        const t3 = c.i32_const(module.alloc(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_square\", x0, t0),\n            c.call(f1mPrefix+\"_square\", x1, t1),\n            // c.call(f1mPrefix+\"_mul\", t1, c.i32_const(pNonResidue), t2),\n            c.call(mulNonResidueFn, t1, t2),\n\n            c.call(f1mPrefix+\"_sub\", t0, t2, t2),\n            c.call(f1mPrefix+\"_inverse\", t2, t3),\n\n            c.call(f1mPrefix+\"_mul\", x0, t3, r0),\n            c.call(f1mPrefix+\"_mul\", x1, t3, r1),\n            c.call(f1mPrefix+\"_neg\", r1, r1),\n        );\n    }\n\n\n    function buildSign() {\n        const f = module.addFunction(prefix+\"_sign\");\n        f.addParam(\"x\", \"i32\");\n        f.addLocal(\"s\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.setLocal(\"s\" , c.call( f1mPrefix + \"_sign\", x1)),\n            c.if(\n                c.getLocal(\"s\"),\n                c.ret(c.getLocal(\"s\"))\n            ),\n            c.ret(c.call( f1mPrefix + \"_sign\", x0))\n        );\n    }\n\n    function buildIsOne() {\n        const f = module.addFunction(prefix+\"_isOne\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.ret(c.i32_and(\n                c.call(f1mPrefix + \"_isOne\", x0),\n                c.call(f1mPrefix + \"_isZero\", x1),\n            ))\n        );\n    }\n\n\n    // Check here: https://eprint.iacr.org/2012/685.pdf\n    // Alg 9adj\n    function buildSqrt() {\n\n        const f = module.addFunction(prefix+\"_sqrt\");\n        f.addParam(\"a\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        // BigInt can't take `undefined` so we use `|| 0`\n        const e34 = c.i32_const(module.alloc(utils.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8 )));\n        // BigInt can't take `undefined` so we use `|| 0`\n        const e12 = c.i32_const(module.alloc(utils.bigInt2BytesLE((BigInt(q || 0) - 1n) / 2n, f1n8 )));\n\n        const a = c.getLocal(\"a\");\n        const a1 = c.i32_const(module.alloc(f1n8*2));\n        const alpha = c.i32_const(module.alloc(f1n8*2));\n        const a0 = c.i32_const(module.alloc(f1n8*2));\n        const pn1 = module.alloc(f1n8*2);\n        const n1 = c.i32_const(pn1);\n        const n1a = c.i32_const(pn1);\n        const n1b = c.i32_const(pn1+f1n8);\n        const x0 = c.i32_const(module.alloc(f1n8*2));\n        const b = c.i32_const(module.alloc(f1n8*2));\n\n        f.addCode(\n\n            c.call(prefix + \"_one\", n1),\n            c.call(prefix + \"_neg\", n1, n1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_exp\", a, e34, c.i32_const(f1n8), a1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_square\", a1, alpha),\n            c.call(prefix + \"_mul\", a, alpha, alpha),\n\n            // const a0 = F.mul(F.frobenius(1, alfa), alfa);\n            c.call(prefix + \"_conjugate\", alpha, a0),\n            c.call(prefix + \"_mul\", a0, alpha, a0),\n\n            // if (F.eq(a0, F.negone)) return null;\n            c.if(c.call(prefix + \"_eq\",a0,n1), c.unreachable() ),\n\n            // const x0 = F.mul(a1, a);\n            c.call(prefix + \"_mul\", a1, a, x0),\n\n            // if (F.eq(alfa, F.negone)) {\n            c.if(\n                c.call(prefix + \"_eq\", alpha, n1),\n                [\n                    // x = F.mul(x0, [F.F.zero, F.F.one]);\n                    ...c.call(f1mPrefix + \"_zero\", n1a),\n                    ...c.call(f1mPrefix + \"_one\", n1b),\n                    ...c.call(prefix + \"_mul\", n1, x0, c.getLocal(\"pr\")),\n                ],\n                [\n                    // const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n                    ...c.call(prefix + \"_one\", b),\n                    ...c.call(prefix + \"_add\", b, alpha, b),\n                    ...c.call(prefix + \"_exp\", b, e12, c.i32_const(f1n8), b),\n\n                    // x = F.mul(b, x0);\n                    ...c.call(prefix + \"_mul\", b, x0, c.getLocal(\"pr\")),\n                ]\n            )\n        );\n\n    }\n\n\n    function buildIsSquare() {\n\n        const f = module.addFunction(prefix+\"_isSquare\");\n        f.addParam(\"a\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        // BigInt can't take `undefined` so we use `|| 0`\n        const e34 = c.i32_const(module.alloc(utils.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8 )));\n\n        const a = c.getLocal(\"a\");\n        const a1 = c.i32_const(module.alloc(f1n8*2));\n        const alpha = c.i32_const(module.alloc(f1n8*2));\n        const a0 = c.i32_const(module.alloc(f1n8*2));\n        const pn1 = module.alloc(f1n8*2);\n        const n1 = c.i32_const(pn1);\n\n        f.addCode(\n\n            c.call(prefix + \"_one\", n1),\n            c.call(prefix + \"_neg\", n1, n1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_exp\", a, e34, c.i32_const(f1n8), a1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_square\", a1, alpha),\n            c.call(prefix + \"_mul\", a, alpha, alpha),\n\n            // const a0 = F.mul(F.frobenius(1, alfa), alfa);\n            c.call(prefix + \"_conjugate\", alpha, a0),\n            c.call(prefix + \"_mul\", a0, alpha, a0),\n\n            // if (F.eq(a0, F.negone)) return null;\n            c.if(\n                c.call(\n                    prefix + \"_eq\",\n                    a0,\n                    n1\n                ),\n                c.ret(c.i32_const(0))\n            ),\n            c.ret(c.i32_const(1))\n        );\n\n    }\n\n\n    buildIsZero();\n    buildIsOne();\n    buildZero();\n    buildOne();\n    buildCopy();\n    buildMul();\n    buildMul1();\n    buildSquare();\n    buildAdd();\n    buildSub();\n    buildNeg();\n    buildConjugate();\n    buildToMontgomery();\n    buildFromMontgomery();\n    buildEq();\n    buildInverse();\n    buildTimesScalar();\n    buildSign();\n    buildIsNegative();\n\n    module.exportFunction(prefix + \"_isZero\");\n    module.exportFunction(prefix + \"_isOne\");\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_one\");\n    module.exportFunction(prefix + \"_copy\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_mul1\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_sign\");\n    module.exportFunction(prefix + \"_conjugate\");\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_eq\");\n    module.exportFunction(prefix + \"_inverse\");\n    buildBatchInverse(module, prefix);\n    buildExp(\n        module,\n        prefix + \"_exp\",\n        f1n8*2,\n        prefix + \"_mul\",\n        prefix + \"_square\",\n        prefix + \"_copy\",\n        prefix + \"_one\",\n    );\n    buildSqrt();\n    buildIsSquare();\n\n    module.exportFunction(prefix + \"_exp\");\n    module.exportFunction(prefix + \"_timesScalar\");\n    module.exportFunction(prefix + \"_batchInverse\");\n    module.exportFunction(prefix + \"_sqrt\");\n    module.exportFunction(prefix + \"_isSquare\");\n    module.exportFunction(prefix + \"_isNegative\");\n\n\n    return prefix;\n};\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst buildExp = require(\"./build_timesscalar\");\nconst buildBatchInverse = require(\"./build_batchinverse\");\n\nmodule.exports = function buildF3m(module, mulNonResidueFn, prefix, f1mPrefix) {\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const f1n8 = module.modules[f1mPrefix].n64*8;\n    module.modules[prefix] = {\n        n64: module.modules[f1mPrefix].n64*3\n    };\n\n    function buildAdd() {\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const y2 = c.i32_add(c.getLocal(\"y\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_add\", x0, y0, r0),\n            c.call(f1mPrefix+\"_add\", x1, y1, r1),\n            c.call(f1mPrefix+\"_add\", x2, y2, r2),\n        );\n    }\n\n    function buildTimesScalar() {\n        const f = module.addFunction(prefix+\"_timesScalar\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_timesScalar\", x0, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r0),\n            c.call(f1mPrefix+\"_timesScalar\", x1, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r1),\n            c.call(f1mPrefix+\"_timesScalar\", x2, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r2),\n        );\n    }\n\n\n    function buildSub() {\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const y2 = c.i32_add(c.getLocal(\"y\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_sub\", x0, y0, r0),\n            c.call(f1mPrefix+\"_sub\", x1, y1, r1),\n            c.call(f1mPrefix+\"_sub\", x2, y2, r2),\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix+\"_neg\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_neg\", x0, r0),\n            c.call(f1mPrefix+\"_neg\", x1, r1),\n            c.call(f1mPrefix+\"_neg\", x2, r2),\n        );\n    }\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.if(\n                c.call(f1mPrefix+\"_isZero\", x2),\n                c.if(\n                    c.call(f1mPrefix+\"_isZero\", x1),\n                    c.ret(c.call(f1mPrefix+\"_isNegative\", x0)),\n                    c.ret(c.call(f1mPrefix+\"_isNegative\", x1))\n                )\n            ),\n            c.ret(c.call(f1mPrefix+\"_isNegative\", x2))\n        );\n    }\n\n\n    function buildMul() {\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const cd = f.getCodeBuilder();\n\n        const a = cd.getLocal(\"x\");\n        const b = cd.i32_add(cd.getLocal(\"x\"), cd.i32_const(f1n8));\n        const c = cd.i32_add(cd.getLocal(\"x\"), cd.i32_const(2*f1n8));\n        const A = cd.getLocal(\"y\");\n        const B = cd.i32_add(cd.getLocal(\"y\"), cd.i32_const(f1n8));\n        const C = cd.i32_add(cd.getLocal(\"y\"), cd.i32_const(2*f1n8));\n        const r0 = cd.getLocal(\"r\");\n        const r1 = cd.i32_add(cd.getLocal(\"r\"), cd.i32_const(f1n8));\n        const r2 = cd.i32_add(cd.getLocal(\"r\"), cd.i32_const(2*f1n8));\n\n        const aA = cd.i32_const(module.alloc(f1n8));\n        const bB = cd.i32_const(module.alloc(f1n8));\n        const cC = cd.i32_const(module.alloc(f1n8));\n        const a_b = cd.i32_const(module.alloc(f1n8));\n        const A_B = cd.i32_const(module.alloc(f1n8));\n        const a_c = cd.i32_const(module.alloc(f1n8));\n        const A_C = cd.i32_const(module.alloc(f1n8));\n        const b_c = cd.i32_const(module.alloc(f1n8));\n        const B_C = cd.i32_const(module.alloc(f1n8));\n        const aA_bB = cd.i32_const(module.alloc(f1n8));\n        const aA_cC = cd.i32_const(module.alloc(f1n8));\n        const bB_cC = cd.i32_const(module.alloc(f1n8));\n        const AUX = cd.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n            cd.call(f1mPrefix + \"_mul\", a, A, aA),\n            cd.call(f1mPrefix + \"_mul\", b, B, bB),\n            cd.call(f1mPrefix + \"_mul\", c, C, cC),\n\n            cd.call(f1mPrefix + \"_add\", a, b, a_b),\n            cd.call(f1mPrefix + \"_add\", A, B, A_B),\n            cd.call(f1mPrefix + \"_add\", a, c, a_c),\n            cd.call(f1mPrefix + \"_add\", A, C, A_C),\n            cd.call(f1mPrefix + \"_add\", b, c, b_c),\n            cd.call(f1mPrefix + \"_add\", B, C, B_C),\n\n            cd.call(f1mPrefix + \"_add\", aA, bB, aA_bB),\n            cd.call(f1mPrefix + \"_add\", aA, cC, aA_cC),\n            cd.call(f1mPrefix + \"_add\", bB, cC, bB_cC),\n\n            cd.call(f1mPrefix + \"_mul\", b_c, B_C, r0),\n            cd.call(f1mPrefix + \"_sub\", r0, bB_cC, r0),\n            cd.call(mulNonResidueFn, r0, r0),\n            cd.call(f1mPrefix + \"_add\", aA, r0, r0),\n\n            cd.call(f1mPrefix + \"_mul\", a_b, A_B, r1),\n            cd.call(f1mPrefix + \"_sub\", r1, aA_bB, r1),\n            cd.call(mulNonResidueFn, cC, AUX),\n            cd.call(f1mPrefix + \"_add\", r1, AUX, r1),\n\n            cd.call(f1mPrefix + \"_mul\", a_c, A_C, r2),\n            cd.call(f1mPrefix + \"_sub\", r2, aA_cC, r2),\n            cd.call(f1mPrefix + \"_add\", r2, bB, r2),\n        );\n\n    }\n\n    function buildSquare() {\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const A = c.getLocal(\"x\");\n        const B = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const C = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        const s0 = c.i32_const(module.alloc(f1n8));\n        const ab = c.i32_const(module.alloc(f1n8));\n        const s1 = c.i32_const(module.alloc(f1n8));\n        const s2 = c.i32_const(module.alloc(f1n8));\n        const bc = c.i32_const(module.alloc(f1n8));\n        const s3 = c.i32_const(module.alloc(f1n8));\n        const s4 = c.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n\n            c.call(f1mPrefix + \"_square\", A, s0),\n            c.call(f1mPrefix + \"_mul\", A, B, ab),\n            c.call(f1mPrefix + \"_add\", ab, ab, s1),\n\n            c.call(f1mPrefix + \"_sub\", A, B, s2),\n            c.call(f1mPrefix + \"_add\", s2, C, s2),\n            c.call(f1mPrefix + \"_square\", s2, s2),\n\n            c.call(f1mPrefix + \"_mul\", B, C, bc),\n            c.call(f1mPrefix + \"_add\", bc, bc, s3),\n\n            c.call(f1mPrefix + \"_square\", C, s4),\n\n            c.call(mulNonResidueFn, s3, r0),\n            c.call(f1mPrefix + \"_add\", s0, r0, r0),\n\n            c.call(mulNonResidueFn, s4, r1),\n            c.call(f1mPrefix + \"_add\", s1, r1, r1),\n\n            c.call(f1mPrefix + \"_add\", s0, s4, r2),\n            c.call(f1mPrefix + \"_sub\", s3, r2, r2),\n            c.call(f1mPrefix + \"_add\", s2, r2, r2),\n            c.call(f1mPrefix + \"_add\", s1, r2, r2),\n        );\n\n    }\n\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix+\"_toMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_toMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_toMontgomery\", x1, r1),\n            c.call(f1mPrefix+\"_toMontgomery\", x2, r2)\n        );\n    }\n\n    function buildFromMontgomery() {\n        const f = module.addFunction(prefix+\"_fromMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_fromMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_fromMontgomery\", x1, r1),\n            c.call(f1mPrefix+\"_fromMontgomery\", x2, r2)\n        );\n    }\n\n    function buildCopy() {\n        const f = module.addFunction(prefix+\"_copy\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, r0),\n            c.call(f1mPrefix+\"_copy\", x1, r1),\n            c.call(f1mPrefix+\"_copy\", x2, r2),\n        );\n    }\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_zero\", x0),\n            c.call(f1mPrefix+\"_zero\", x1),\n            c.call(f1mPrefix+\"_zero\", x2),\n        );\n    }\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_one\", x0),\n            c.call(f1mPrefix+\"_zero\", x1),\n            c.call(f1mPrefix+\"_zero\", x2),\n        );\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix+\"_eq\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const y2 = c.i32_add(c.getLocal(\"y\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.i32_and(\n                    c.call(f1mPrefix+\"_eq\", x0, y0),\n                    c.call(f1mPrefix+\"_eq\", x1, y1),\n                ),\n                c.call(f1mPrefix+\"_eq\", x2, y2)\n            )\n        );\n    }\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix+\"_isZero\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.i32_and(\n                    c.call(f1mPrefix+\"_isZero\", x0),\n                    c.call(f1mPrefix+\"_isZero\", x1)\n                ),\n                c.call(f1mPrefix+\"_isZero\", x2)\n            )\n        );\n    }\n\n    function buildInverse() {\n        const f = module.addFunction(prefix+\"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        const t0 = c.i32_const(module.alloc(f1n8));\n        const t1 = c.i32_const(module.alloc(f1n8));\n        const t2 = c.i32_const(module.alloc(f1n8));\n        const t3 = c.i32_const(module.alloc(f1n8));\n        const t4 = c.i32_const(module.alloc(f1n8));\n        const t5 = c.i32_const(module.alloc(f1n8));\n        const c0 = c.i32_const(module.alloc(f1n8));\n        const c1 = c.i32_const(module.alloc(f1n8));\n        const c2 = c.i32_const(module.alloc(f1n8));\n        const t6 = c.i32_const(module.alloc(f1n8));\n        const AUX = c.i32_const(module.alloc(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_square\", x0, t0),\n            c.call(f1mPrefix+\"_square\", x1, t1),\n            c.call(f1mPrefix+\"_square\", x2, t2),\n            c.call(f1mPrefix+\"_mul\", x0, x1, t3),\n            c.call(f1mPrefix+\"_mul\", x0, x2, t4),\n            c.call(f1mPrefix+\"_mul\", x1, x2, t5),\n\n            c.call(mulNonResidueFn, t5, c0),\n            c.call(f1mPrefix+\"_sub\", t0, c0, c0),\n\n            c.call(mulNonResidueFn, t2, c1),\n            c.call(f1mPrefix+\"_sub\", c1, t3, c1),\n\n            c.call(f1mPrefix+\"_sub\", t1, t4, c2),\n\n            c.call(f1mPrefix+\"_mul\", x2, c1, t6),\n            c.call(f1mPrefix+\"_mul\", x1, c2, AUX),\n            c.call(f1mPrefix+\"_add\", t6, AUX, t6),\n            c.call(mulNonResidueFn, t6, t6),\n            c.call(f1mPrefix+\"_mul\", x0, c0, AUX),\n            c.call(f1mPrefix+\"_add\", AUX, t6, t6),\n\n            c.call(f1mPrefix+\"_inverse\", t6, t6),\n\n            c.call(f1mPrefix+\"_mul\", t6, c0, r0),\n            c.call(f1mPrefix+\"_mul\", t6, c1, r1),\n            c.call(f1mPrefix+\"_mul\", t6, c2, r2)\n        );\n    }\n\n\n    function buildSign() {\n        const f = module.addFunction(prefix+\"_sign\");\n        f.addParam(\"x\", \"i32\");\n        f.addLocal(\"s\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.setLocal(\"s\" , c.call( f1mPrefix + \"_sign\", x2)),\n            c.if(\n                c.getLocal(\"s\"),\n                c.ret(c.getLocal(\"s\"))\n            ),\n            c.setLocal(\"s\" , c.call( f1mPrefix + \"_sign\", x1)),\n            c.if(\n                c.getLocal(\"s\"),\n                c.ret(c.getLocal(\"s\"))\n            ),\n            c.ret(c.call( f1mPrefix + \"_sign\", x0))\n        );\n    }\n\n    function buildIsOne() {\n        const f = module.addFunction(prefix+\"_isOne\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8*2));\n\n        f.addCode(\n            c.ret(\n                c.i32_and(\n                    c.i32_and(\n                        c.call(f1mPrefix + \"_isOne\", x0),\n                        c.call(f1mPrefix + \"_isZero\", x1)\n                    ),\n                    c.call(f1mPrefix + \"_isZero\", x2)\n                )\n            )\n        );\n    }\n\n    buildIsZero();\n    buildIsOne();\n    buildZero();\n    buildOne();\n    buildCopy();\n    buildMul();\n    buildSquare();\n    buildAdd();\n    buildSub();\n    buildNeg();\n    buildSign();\n    buildToMontgomery();\n    buildFromMontgomery();\n    buildEq();\n    buildInverse();\n    buildTimesScalar();\n    buildIsNegative();\n\n    module.exportFunction(prefix + \"_isZero\");\n    module.exportFunction(prefix + \"_isOne\");\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_one\");\n    module.exportFunction(prefix + \"_copy\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_sign\");\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_eq\");\n    module.exportFunction(prefix + \"_inverse\");\n    buildBatchInverse(module, prefix);\n    buildExp(\n        module,\n        prefix + \"_exp\",\n        f1n8*3,\n        prefix + \"_mul\",\n        prefix + \"_square\",\n        prefix + \"_copy\",\n        prefix + \"_one\"\n    );\n    module.exportFunction(prefix + \"_exp\");\n    module.exportFunction(prefix + \"_timesScalar\");\n    module.exportFunction(prefix + \"_batchInverse\");\n    module.exportFunction(prefix + \"_isNegative\");\n\n    return prefix;\n};\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildTimesScalarNAF(module, fnName, elementLen, opAB, opAA, opAmB, opCopy, opInit) {\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"base\", \"i32\");\n    f.addParam(\"scalar\", \"i32\");\n    f.addParam(\"scalarLength\", \"i32\");\n    f.addParam(\"r\", \"i32\");\n    f.addLocal(\"old0\", \"i32\");\n    f.addLocal(\"nbits\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"last\", \"i32\");\n    f.addLocal(\"cur\", \"i32\");\n    f.addLocal(\"carry\", \"i32\");\n    f.addLocal(\"p\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const aux = c.i32_const(module.alloc(elementLen));\n\n    function getBit(IDX) {\n        return c.i32_and(\n            c.i32_shr_u(\n                c.i32_load(\n                    c.i32_add(\n                        c.getLocal(\"scalar\"),\n                        c.i32_and(\n                            c.i32_shr_u(\n                                IDX,\n                                c.i32_const(3)\n                            ),\n                            c.i32_const(0xFFFFFFFC)\n                        )\n                    )\n                ),\n                c.i32_and(\n                    IDX,\n                    c.i32_const(0x1F)\n                )\n            ),\n            c.i32_const(1)\n        );\n    }\n\n    function pushBit(b) {\n        return [\n            ...c.i32_store8(\n                c.getLocal(\"p\"),\n                c.i32_const(b)\n            ),\n            ...c.setLocal(\n                \"p\",\n                c.i32_add(\n                    c.getLocal(\"p\"),\n                    c.i32_const(1)\n                )\n            )\n        ];\n    }\n\n    f.addCode(\n        c.if(\n            c.i32_eqz(c.getLocal(\"scalarLength\")),\n            [\n                ...c.call(opInit, c.getLocal(\"r\")),\n                ...c.ret([])\n            ]\n        ),\n        c.setLocal(\"nbits\", c.i32_shl(c.getLocal(\"scalarLength\"), c.i32_const(3))),\n        c.setLocal(\"old0\", c.i32_load(c.i32_const(0))),\n        c.setLocal(\"p\", c.getLocal(\"old0\")),\n        c.i32_store(\n            c.i32_const(0),\n            c.i32_and(\n                c.i32_add(\n                    c.i32_add(\n                        c.getLocal(\"old0\"),\n                        c.i32_const(32)\n                    ),\n                    c.getLocal(\"nbits\")\n                ),\n                c.i32_const(0xFFFFFFF8)\n            )\n        ),\n        c.setLocal(\"i\", c.i32_const(1)),\n\n        c.setLocal(\"last\",getBit(c.i32_const(0))),\n        c.setLocal(\"carry\",c.i32_const(0)),\n\n        c.block(c.loop(\n            c.br_if(1, c.i32_eq( c.getLocal(\"i\"), c.getLocal(\"nbits\"))),\n\n            c.setLocal(\"cur\", getBit(c.getLocal(\"i\"))),\n            c.if( c.getLocal(\"last\"),\n                c.if( c.getLocal(\"cur\"),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(1)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(255)\n                        ],\n                    ),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(255)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(1)\n                        ],\n                    ),\n                ),\n                c.if( c.getLocal(\"cur\"),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(0)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(1)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(0)\n                        ],\n                    ),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(1)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(0)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(0)\n                        ],\n                    ),\n                )\n            ),\n            c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        )),\n\n        c.if( c.getLocal(\"last\"),\n            c.if(c.getLocal(\"carry\"),\n                [\n                    ...pushBit(255),\n                    ...pushBit(0),\n                    ...pushBit(1)\n                ]\n                ,\n                [\n                    ...pushBit(1)\n                ],\n            ),\n            c.if(c.getLocal(\"carry\"),\n                [\n                    ...pushBit(0),\n                    ...pushBit(1)\n                ]\n            ),\n        ),\n\n        c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n\n        // p already points to the last bit\n\n        c.call(opCopy, c.getLocal(\"base\"), aux),\n\n        c.call(opInit, c.getLocal(\"r\")),\n\n        c.block(c.loop(\n\n\n            c.call(opAA, c.getLocal(\"r\"), c.getLocal(\"r\")),\n\n\n            c.setLocal(\"cur\",\n                c.i32_load8_u(\n                    c.getLocal(\"p\")\n                )\n            ),\n\n            c.if(\n                c.getLocal(\"cur\"),\n                c.if(\n                    c.i32_eq(c.getLocal(\"cur\"), c.i32_const(1)),\n                    c.call(opAB,  c.getLocal(\"r\"), aux, c.getLocal(\"r\")),\n                    c.call(opAmB, c.getLocal(\"r\"), aux, c.getLocal(\"r\")),\n                )\n            ),\n\n            c.br_if(1, c.i32_eq( c.getLocal(\"old0\"), c.getLocal(\"p\"))),\n            c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n            c.br(0)\n\n        )),\n\n        c.i32_store( c.i32_const(0), c.getLocal(\"old0\"))\n\n    );\n\n};\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildMultiexp(module, prefix, fnName, opAdd, n8b) {\n\n    const n64g = module.modules[prefix].n64;\n    const n8g = n64g*8;\n\n    function buildGetChunk() {\n        const f = module.addFunction(fnName + \"_getChunk\");\n        f.addParam(\"pScalar\", \"i32\");\n        f.addParam(\"scalarSize\", \"i32\");  // Number of bytes of the scalar\n        f.addParam(\"startBit\", \"i32\");  // Bit to start extract\n        f.addParam(\"chunkSize\", \"i32\");  // Chunk size in bits\n        f.addLocal(\"bitsToEnd\", \"i32\");\n        f.addLocal(\"mask\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\"bitsToEnd\",\n                c.i32_sub(\n                    c.i32_mul(\n                        c.getLocal(\"scalarSize\"),\n                        c.i32_const(8)\n                    ),\n                    c.getLocal(\"startBit\")\n                )\n            ),\n            c.if(\n                c.i32_gt_s(\n                    c.getLocal(\"chunkSize\"),\n                    c.getLocal(\"bitsToEnd\")\n                ),\n                c.setLocal(\n                    \"mask\",\n                    c.i32_sub(\n                        c.i32_shl(\n                            c.i32_const(1),\n                            c.getLocal(\"bitsToEnd\")\n                        ),\n                        c.i32_const(1)\n                    )\n                ),\n                c.setLocal(\n                    \"mask\",\n                    c.i32_sub(\n                        c.i32_shl(\n                            c.i32_const(1),\n                            c.getLocal(\"chunkSize\")\n                        ),\n                        c.i32_const(1)\n                    )\n                )\n            ),\n            c.i32_and(\n                c.i32_shr_u(\n                    c.i32_load(\n                        c.i32_add(\n                            c.getLocal(\"pScalar\"),\n                            c.i32_shr_u(\n                                c.getLocal(\"startBit\"),\n                                c.i32_const(3)\n                            )\n                        ),\n                        0,  // offset\n                        0   // align to byte.\n                    ),\n                    c.i32_and(\n                        c.getLocal(\"startBit\"),\n                        c.i32_const(0x7)\n                    )\n                ),\n                c.getLocal(\"mask\")\n            )\n        );\n    }\n\n    function buildMutiexpChunk() {\n        const f = module.addFunction(fnName + \"_chunk\");\n        f.addParam(\"pBases\", \"i32\");\n        f.addParam(\"pScalars\", \"i32\");\n        f.addParam(\"scalarSize\", \"i32\");  // Number of points\n        f.addParam(\"n\", \"i32\");  // Number of points\n        f.addParam(\"startBit\", \"i32\");  // bit where it starts the chunk\n        f.addParam(\"chunkSize\", \"i32\");  // bit where it starts the chunk\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"nChunks\", \"i32\");\n        f.addLocal(\"itScalar\", \"i32\");\n        f.addLocal(\"endScalar\", \"i32\");\n        f.addLocal(\"itBase\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"nTable\", \"i32\");\n        f.addLocal(\"pTable\", \"i32\");\n        f.addLocal(\"idx\", \"i32\");\n        f.addLocal(\"pIdxTable\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.i32_eqz(c.getLocal(\"n\")),\n                [\n                    ...c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n\n            // Allocate memory\n\n            c.setLocal(\n                \"nTable\",\n                c.i32_shl(\n                    c.i32_const(1),\n                    c.getLocal(\"chunkSize\")\n                )\n            ),\n            c.setLocal(\"pTable\", c.i32_load( c.i32_const(0) )),\n            c.i32_store(\n                c.i32_const(0),\n                c.i32_add(\n                    c.getLocal(\"pTable\"),\n                    c.i32_mul(\n                        c.getLocal(\"nTable\"),\n                        c.i32_const(n8g)\n                    )\n                )\n            ),\n\n            // Reset Table\n            c.setLocal(\"j\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"j\"),\n                        c.getLocal(\"nTable\")\n                    )\n                ),\n\n                c.call(\n                    prefix + \"_zero\",\n                    c.i32_add(\n                        c.getLocal(\"pTable\"),\n                        c.i32_mul(\n                            c.getLocal(\"j\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            // Distribute elements\n            c.setLocal(\"itBase\", c.getLocal(\"pBases\")),\n            c.setLocal(\"itScalar\", c.getLocal(\"pScalars\")),\n            c.setLocal(\"endScalar\",\n                c.i32_add(\n                    c.getLocal(\"pScalars\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.getLocal(\"scalarSize\")\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"itScalar\"),\n                        c.getLocal(\"endScalar\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx\",\n                    c.call(fnName + \"_getChunk\",\n                        c.getLocal(\"itScalar\"),\n                        c.getLocal(\"scalarSize\"),\n                        c.getLocal(\"startBit\"),\n                        c.getLocal(\"chunkSize\")\n                    )\n                ),\n\n                c.if(\n                    c.getLocal(\"idx\"),\n                    [\n                        ...c.setLocal(\n                            \"pIdxTable\",\n                            c.i32_add(\n                                c.getLocal(\"pTable\"),\n                                c.i32_mul(\n                                    c.i32_sub(\n                                        c.getLocal(\"idx\"),\n                                        c.i32_const(1)\n                                    ),\n                                    c.i32_const(n8g)\n                                )\n                            )\n                        ),\n                        ...c.call(\n                            opAdd,\n                            c.getLocal(\"pIdxTable\"),\n                            c.getLocal(\"itBase\"),\n                            c.getLocal(\"pIdxTable\"),\n                        )\n                    ]\n                ),\n\n                c.setLocal(\"itScalar\", c.i32_add(c.getLocal(\"itScalar\"), c.getLocal(\"scalarSize\"))),\n                c.setLocal(\"itBase\", c.i32_add(c.getLocal(\"itBase\"), c.i32_const(n8b))),\n                c.br(0)\n            )),\n\n            c.call(fnName + \"_reduceTable\", c.getLocal(\"pTable\"), c.getLocal(\"chunkSize\")),\n            c.call(\n                prefix + \"_copy\",\n                c.getLocal(\"pTable\"),\n                c.getLocal(\"pr\")\n            ),\n\n\n            c.i32_store(\n                c.i32_const(0),\n                c.getLocal(\"pTable\")\n            )\n\n        );\n    }\n\n    function buildMultiexp() {\n        const f = module.addFunction(fnName);\n        f.addParam(\"pBases\", \"i32\");\n        f.addParam(\"pScalars\", \"i32\");\n        f.addParam(\"scalarSize\", \"i32\");  // Number of points\n        f.addParam(\"n\", \"i32\");  // Number of points\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"chunkSize\", \"i32\");\n        f.addLocal(\"nChunks\", \"i32\");\n        f.addLocal(\"itScalar\", \"i32\");\n        f.addLocal(\"endScalar\", \"i32\");\n        f.addLocal(\"itBase\", \"i32\");\n        f.addLocal(\"itBit\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"nTable\", \"i32\");\n        f.addLocal(\"pTable\", \"i32\");\n        f.addLocal(\"idx\", \"i32\");\n        f.addLocal(\"pIdxTable\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8g));\n\n        const pTSizes = module.alloc([\n            17, 17, 17, 17,   17, 17, 17, 17,\n            17, 17, 16, 16,   15, 14, 13, 13,\n            12, 11, 10,  9,    8,  7,  7,  6,\n            5 ,  4,  3,  2,    1,  1,  1,  1\n        ]);\n\n        f.addCode(\n            c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n            c.if(\n                c.i32_eqz(c.getLocal(\"n\")),\n                c.ret([])\n            ),\n            c.setLocal(\"chunkSize\", c.i32_load8_u( c.i32_clz(c.getLocal(\"n\")),  pTSizes )),\n            c.setLocal(\n                \"nChunks\",\n                c.i32_add(\n                    c.i32_div_u(\n                        c.i32_sub(\n                            c.i32_shl(\n                                c.getLocal(\"scalarSize\"),\n                                c.i32_const(3)\n                            ),\n                            c.i32_const(1)\n                        ),\n                        c.getLocal(\"chunkSize\")\n                    ),\n                    c.i32_const(1)\n                )\n            ),\n\n\n            // Allocate memory\n\n            c.setLocal(\n                \"itBit\",\n                c.i32_mul(\n                    c.i32_sub(\n                        c.getLocal(\"nChunks\"),\n                        c.i32_const(1)\n                    ),\n                    c.getLocal(\"chunkSize\")\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_lt_s(\n                        c.getLocal(\"itBit\"),\n                        c.i32_const(0)\n                    )\n                ),\n\n                // Double nChunk times\n                c.if(\n                    c.i32_eqz(c.call(prefix + \"_isZero\", c.getLocal(\"pr\"))),\n                    [\n                        ...c.setLocal(\"j\", c.i32_const(0)),\n                        ...c.block(c.loop(\n                            c.br_if(\n                                1,\n                                c.i32_eq(\n                                    c.getLocal(\"j\"),\n                                    c.getLocal(\"chunkSize\")\n                                )\n                            ),\n\n                            c.call(prefix + \"_double\", c.getLocal(\"pr\"), c.getLocal(\"pr\")),\n\n                            c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                            c.br(0)\n                        ))\n                    ]\n                ),\n\n                c.call(\n                    fnName + \"_chunk\",\n                    c.getLocal(\"pBases\"),\n                    c.getLocal(\"pScalars\"),\n                    c.getLocal(\"scalarSize\"),\n                    c.getLocal(\"n\"),\n                    c.getLocal(\"itBit\"),\n                    c.getLocal(\"chunkSize\"),\n                    aux\n                ),\n\n                c.call(\n                    prefix + \"_add\",\n                    c.getLocal(\"pr\"),\n                    aux,\n                    c.getLocal(\"pr\")\n                ),\n                c.setLocal(\"itBit\", c.i32_sub(c.getLocal(\"itBit\"), c.getLocal(\"chunkSize\"))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildReduceTable() {\n        const f = module.addFunction(fnName + \"_reduceTable\");\n        f.addParam(\"pTable\", \"i32\");\n        f.addParam(\"p\", \"i32\");  // Number of bits of the table\n        f.addLocal(\"half\", \"i32\");\n        f.addLocal(\"it1\", \"i32\");\n        f.addLocal(\"it2\", \"i32\");\n        f.addLocal(\"pAcc\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.i32_eq(c.getLocal(\"p\"), c.i32_const(1)),\n                c.ret([])\n            ),\n            c.setLocal(\n                \"half\",\n                c.i32_shl(\n                    c.i32_const(1),\n                    c.i32_sub(\n                        c.getLocal(\"p\"),\n                        c.i32_const(1)\n                    )\n                )\n            ),\n\n            c.setLocal(\"it1\", c.getLocal(\"pTable\")),\n            c.setLocal(\n                \"it2\",\n                c.i32_add(\n                    c.getLocal(\"pTable\"),\n                    c.i32_mul(\n                        c.getLocal(\"half\"),\n                        c.i32_const(n8g)\n                    )\n                )\n            ),\n            c.setLocal(\"pAcc\",\n                c.i32_sub(\n                    c.getLocal(\"it2\"),\n                    c.i32_const(n8g)\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"it1\"),\n                        c.getLocal(\"pAcc\")\n                    )\n                ),\n                c.call(\n                    prefix + \"_add\",\n                    c.getLocal(\"it1\"),\n                    c.getLocal(\"it2\"),\n                    c.getLocal(\"it1\")\n                ),\n                c.call(\n                    prefix + \"_add\",\n                    c.getLocal(\"pAcc\"),\n                    c.getLocal(\"it2\"),\n                    c.getLocal(\"pAcc\")\n                ),\n                c.setLocal(\"it1\", c.i32_add(c.getLocal(\"it1\"), c.i32_const(n8g))),\n                c.setLocal(\"it2\", c.i32_add(c.getLocal(\"it2\"), c.i32_const(n8g))),\n                c.br(0)\n            )),\n\n            c.call(\n                fnName + \"_reduceTable\",\n                c.getLocal(\"pTable\"),\n                c.i32_sub(\n                    c.getLocal(\"p\"),\n                    c.i32_const(1)\n                )\n            ),\n\n            c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eqz(c.getLocal(\"p\"))),\n                c.call(prefix + \"_double\", c.getLocal(\"pAcc\"), c.getLocal(\"pAcc\")),\n                c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            c.call(prefix + \"_add\", c.getLocal(\"pTable\"), c.getLocal(\"pAcc\"), c.getLocal(\"pTable\"))\n        );\n    }\n\n    buildGetChunk();\n    buildReduceTable();\n    buildMutiexpChunk();\n    buildMultiexp();\n\n    module.exportFunction(fnName);\n    module.exportFunction(fnName +\"_chunk\");\n\n\n};\n\n\n\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst buildTimesScalarNAF = require(\"./build_timesscalarnaf\");\n//const buildTimesScalar = require(\"./build_timesscalar\");\nconst buildBatchConvertion = require(\"./build_batchconvertion\");\nconst buildMultiexp = require(\"./build_multiexp\");\n\nmodule.exports = function buildCurve(module, prefix, prefixField, pB) {\n\n\n    const n64 = module.modules[prefixField].n64;\n    const n8 = n64*8;\n\n    if (module.modules[prefix]) return prefix;  // already builded\n    module.modules[prefix] = {\n        n64: n64*3\n    };\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix + \"_isZero\");\n        f.addParam(\"p1\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_isZero\",\n            c.i32_add(\n                c.getLocal(\"p1\"),\n                c.i32_const(n8*2)\n            )\n        ));\n    }\n    function buildIsZeroAffine() {\n        const f = module.addFunction(prefix + \"_isZeroAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.i32_and(\n                c.call(\n                    prefixField + \"_isZero\",\n                    c.getLocal(\"p1\")\n                ),\n                c.call(\n                    prefixField + \"_isZero\",\n                    c.i32_add(\n                        c.getLocal(\"p1\"),\n                        c.i32_const(n8)\n                    )\n                )\n            )\n        );\n    }\n\n    function buildCopy() {\n        const f = module.addFunction(prefix + \"_copy\");\n        f.addParam(\"ps\", \"i32\");\n        f.addParam(\"pd\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64*3; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pd\"),\n                    i*8,\n                    c.i64_load(\n                        c.getLocal(\"ps\"),\n                        i*8\n                    )\n                )\n            );\n        }\n    }\n\n\n    function buildCopyAffine() {\n        const f = module.addFunction(prefix + \"_copyAffine\");\n        f.addParam(\"ps\", \"i32\");\n        f.addParam(\"pd\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64*2; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pd\"),\n                    i*8,\n                    c.i64_load(\n                        c.getLocal(\"ps\"),\n                        i*8\n                    )\n                )\n            );\n        }\n\n    }\n\n\n    function buildZero() {\n        const f = module.addFunction(prefix + \"_zero\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.getLocal(\"pr\")\n        ));\n\n        f.addCode(c.call(\n            prefixField + \"_one\",\n            c.i32_add(\n                c.getLocal(\"pr\"),\n                c.i32_const(n8)\n            )\n        ));\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.i32_add(\n                c.getLocal(\"pr\"),\n                c.i32_const(n8*2)\n            )\n        ));\n    }\n\n\n    function buildZeroAffine() {\n        const f = module.addFunction(prefix + \"_zeroAffine\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.getLocal(\"pr\")\n        ));\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.i32_add(\n                c.getLocal(\"pr\"),\n                c.i32_const(n8)\n            )\n        ));\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix + \"_eq\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"z1\", \"i32\");\n        f.addLocal(\"z2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z2\", c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8*2))));\n        const z2 = c.getLocal(\"z2\");\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const Z2Z2 = c.i32_const(module.alloc(n8));\n        const U1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const Z2_cubed = c.i32_const(module.alloc(n8));\n        const S1 = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                c.ret( c.call(prefix + \"_isZero\", c.getLocal(\"p2\"))),\n            ),\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p2\")),\n                c.ret(c.i32_const(0))\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                c.ret(c.call(prefix + \"_eqMixed\", c.getLocal(\"p2\"), c.getLocal(\"p1\")))\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z2),\n                c.ret(c.call(prefix + \"_eqMixed\", c.getLocal(\"p1\"), c.getLocal(\"p2\")))\n            ),\n\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_square\", z2, Z2Z2),\n            c.call(prefixField + \"_mul\", x1, Z2Z2, U1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", z2, Z2Z2, Z2_cubed),\n            c.call(prefixField + \"_mul\", y1, Z2_cubed, S1),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", U1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", S1, S2),\n                    c.ret(c.i32_const(1))\n                )\n            ),\n            c.ret(c.i32_const(0))\n        );\n    }\n\n\n    function buildEqMixed() {\n        const f = module.addFunction(prefix + \"_eqMixed\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                c.ret( c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\"))),\n            ),\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\")),\n                c.ret(c.i32_const(0))\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                c.ret(c.call(prefix + \"_eqAffine\", c.getLocal(\"p1\"), c.getLocal(\"p2\")))\n            ),\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", x1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", y1, S2),\n                    c.ret(c.i32_const(1))\n                )\n            ),\n            c.ret(c.i32_const(0))\n        );\n    }\n\n    function buildDouble() {\n        const f = module.addFunction(prefix + \"_double\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const A = c.i32_const(module.alloc(n8));\n        const B = c.i32_const(module.alloc(n8));\n        const C = c.i32_const(module.alloc(n8));\n        const D = c.i32_const(module.alloc(n8));\n        const E = c.i32_const(module.alloc(n8));\n        const F = c.i32_const(module.alloc(n8));\n        const G = c.i32_const(module.alloc(n8));\n        const eightC = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z),\n                [\n                    ...c.ret(c.call(prefix + \"_doubleAffine\", c.getLocal(\"p1\"), c.getLocal(\"pr\"))),\n                    ...c.ret([])\n                ]\n            ),\n\n            c.call(prefixField + \"_square\", x, A),\n            c.call(prefixField + \"_square\", y, B),\n            c.call(prefixField + \"_square\", B, C),\n\n            c.call(prefixField + \"_add\", x, B, D),\n            c.call(prefixField + \"_square\", D, D),\n            c.call(prefixField + \"_sub\", D, A, D),\n            c.call(prefixField + \"_sub\", D, C, D),\n            c.call(prefixField + \"_add\", D, D, D),\n\n            c.call(prefixField + \"_add\", A, A, E),\n            c.call(prefixField + \"_add\", E, A, E),\n            c.call(prefixField + \"_square\", E, F),\n\n            c.call(prefixField + \"_mul\", y, z, G),\n\n            c.call(prefixField + \"_add\", D, D, x3),\n            c.call(prefixField + \"_sub\", F, x3, x3),\n\n            c.call(prefixField + \"_add\", C, C, eightC),\n            c.call(prefixField + \"_add\", eightC, eightC, eightC),\n            c.call(prefixField + \"_add\", eightC, eightC, eightC),\n\n            c.call(prefixField + \"_sub\", D, x3, y3),\n            c.call(prefixField + \"_mul\", y3, E, y3),\n            c.call(prefixField + \"_sub\", y3, eightC, y3),\n\n            c.call(prefixField + \"_add\", G, G, z3),\n        );\n    }\n\n\n    function buildDoubleAffine() {\n        const f = module.addFunction(prefix + \"_doubleAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const XX = c.i32_const(module.alloc(n8));\n        const YY = c.i32_const(module.alloc(n8));\n        const YYYY = c.i32_const(module.alloc(n8));\n        const S = c.i32_const(module.alloc(n8));\n        const M = c.i32_const(module.alloc(n8));\n        const eightYYYY = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_toJacobian\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n\n            // XX = X1^2\n            c.call(prefixField + \"_square\", x, XX),\n\n            // YY = Y1^2\n            c.call(prefixField + \"_square\", y, YY),\n\n            // YYYY = YY^2\n            c.call(prefixField + \"_square\", YY, YYYY),\n\n            // S = 2*((X1+YY)^2-XX-YYYY)\n            c.call(prefixField + \"_add\", x, YY, S),\n            c.call(prefixField + \"_square\", S, S),\n            c.call(prefixField + \"_sub\", S, XX, S),\n            c.call(prefixField + \"_sub\", S, YYYY, S),\n            c.call(prefixField + \"_add\", S, S, S),\n\n            // M = 3*XX+a  (Hera a=0)\n            c.call(prefixField + \"_add\", XX, XX, M),\n            c.call(prefixField + \"_add\", M, XX, M),\n\n            // Z3 = 2*Y1\n            c.call(prefixField + \"_add\", y, y, z3),\n\n            // T = M^2-2*S\n            // X3 = T\n            c.call(prefixField + \"_square\", M, x3),\n            c.call(prefixField + \"_sub\", x3, S, x3),\n            c.call(prefixField + \"_sub\", x3, S, x3),\n\n            // Y3 = M*(S-T)-8*YYYY\n            c.call(prefixField + \"_add\", YYYY, YYYY, eightYYYY),\n            c.call(prefixField + \"_add\", eightYYYY, eightYYYY, eightYYYY),\n            c.call(prefixField + \"_add\", eightYYYY, eightYYYY, eightYYYY),\n            c.call(prefixField + \"_sub\", S, x3, y3),\n            c.call(prefixField + \"_mul\", y3, M, y3),\n            c.call(prefixField + \"_sub\", y3, eightYYYY, y3),\n        );\n    }\n\n\n    function buildEqAffine() {\n        const f = module.addFunction(prefix + \"_eqAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.ret(c.i32_and(\n                c.call(\n                    prefixField + \"_eq\",\n                    c.getLocal(\"p1\"),\n                    c.getLocal(\"p2\")\n                ),\n                c.call(\n                    prefixField + \"_eq\",\n                    c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8)),\n                    c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8))\n                )\n            ))\n        );\n    }\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix + \"_toMontgomery\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_toMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<3; i++) {\n            f.addCode(c.call(\n                prefixField + \"_toMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n    function buildToMontgomeryAffine() {\n        const f = module.addFunction(prefix + \"_toMontgomeryAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_toMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<2; i++) {\n            f.addCode(c.call(\n                prefixField + \"_toMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n    function buildFromMontgomery() {\n        const f = module.addFunction(prefix + \"_fromMontgomery\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_fromMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<3; i++) {\n            f.addCode(c.call(\n                prefixField + \"_fromMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n\n    function buildFromMontgomeryAffine() {\n        const f = module.addFunction(prefix + \"_fromMontgomeryAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_fromMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<2; i++) {\n            f.addCode(c.call(\n                prefixField + \"_fromMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n    function buildAdd() {\n\n        const f = module.addFunction(prefix + \"_add\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"z1\", \"i32\");\n        f.addLocal(\"z2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z2\", c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8*2))));\n        const z2 = c.getLocal(\"z2\");\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const Z2Z2 = c.i32_const(module.alloc(n8));\n        const U1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const Z2_cubed = c.i32_const(module.alloc(n8));\n        const S1 = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n        const H = c.i32_const(module.alloc(n8));\n        const S2_minus_S1 = c.i32_const(module.alloc(n8));\n        const I = c.i32_const(module.alloc(n8));\n        const J = c.i32_const(module.alloc(n8));\n        const r = c.i32_const(module.alloc(n8));\n        const r2 = c.i32_const(module.alloc(n8));\n        const V = c.i32_const(module.alloc(n8));\n        const V2 = c.i32_const(module.alloc(n8));\n        const S1_J2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p2\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                [\n                    ...c.call(prefix + \"_addMixed\", x2, x1, x3),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z2),\n                [\n                    ...c.call(prefix + \"_addMixed\", x1, x2, x3),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_square\", z2, Z2Z2),\n            c.call(prefixField + \"_mul\", x1, Z2Z2, U1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", z2, Z2Z2, Z2_cubed),\n            c.call(prefixField + \"_mul\", y1, Z2_cubed, S1),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", U1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", S1, S2),\n                    [\n                        ...c.call(prefix + \"_double\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                        ...c.ret([])\n                    ]\n                )\n            ),\n\n            c.call(prefixField + \"_sub\", U2, U1, H),\n            c.call(prefixField + \"_sub\", S2, S1, S2_minus_S1),\n            c.call(prefixField + \"_add\", H, H, I),\n            c.call(prefixField + \"_square\", I, I),\n            c.call(prefixField + \"_mul\", H, I, J),\n            c.call(prefixField + \"_add\", S2_minus_S1, S2_minus_S1, r),\n            c.call(prefixField + \"_mul\", U1, I, V),\n            c.call(prefixField + \"_square\", r, r2),\n            c.call(prefixField + \"_add\", V, V, V2),\n\n            c.call(prefixField + \"_sub\", r2, J, x3),\n            c.call(prefixField + \"_sub\", x3, V2, x3),\n\n            c.call(prefixField + \"_mul\", S1, J, S1_J2),\n            c.call(prefixField + \"_add\", S1_J2, S1_J2, S1_J2),\n\n            c.call(prefixField + \"_sub\", V, x3, y3),\n            c.call(prefixField + \"_mul\", y3, r, y3),\n            c.call(prefixField + \"_sub\", y3, S1_J2, y3),\n\n            c.call(prefixField + \"_add\", z1, z2, z3),\n            c.call(prefixField + \"_square\", z3, z3),\n            c.call(prefixField + \"_sub\", z3, Z1Z1, z3),\n            c.call(prefixField + \"_sub\", z3, Z2Z2, z3),\n            c.call(prefixField + \"_mul\", z3, H, z3),\n        );\n\n    }\n\n\n    function buildAddMixed() {\n\n        const f = module.addFunction(prefix + \"_addMixed\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n        const H = c.i32_const(module.alloc(n8));\n        const HH = c.i32_const(module.alloc(n8));\n        const S2_minus_y1 = c.i32_const(module.alloc(n8));\n        const I = c.i32_const(module.alloc(n8));\n        const J = c.i32_const(module.alloc(n8));\n        const r = c.i32_const(module.alloc(n8));\n        const r2 = c.i32_const(module.alloc(n8));\n        const V = c.i32_const(module.alloc(n8));\n        const V2 = c.i32_const(module.alloc(n8));\n        const y1_J2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copyAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                    ...c.call(prefixField + \"_one\", c.i32_add(c.getLocal(\"pr\") , c.i32_const(n8*2))),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                [\n                    ...c.call(prefix + \"_addAffine\", x1, x2, x3),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", x1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", y1, S2),\n                    [\n                        ...c.call(prefix + \"_doubleAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                        ...c.ret([])\n                    ]\n                )\n            ),\n\n            c.call(prefixField + \"_sub\", U2, x1, H),\n            c.call(prefixField + \"_sub\", S2, y1, S2_minus_y1),\n            c.call(prefixField + \"_square\", H, HH),\n            c.call(prefixField + \"_add\", HH , HH, I),\n            c.call(prefixField + \"_add\", I , I, I),\n            c.call(prefixField + \"_mul\", H, I, J),\n            c.call(prefixField + \"_add\", S2_minus_y1, S2_minus_y1, r),\n            c.call(prefixField + \"_mul\", x1, I, V),\n            c.call(prefixField + \"_square\", r, r2),\n            c.call(prefixField + \"_add\", V, V, V2),\n\n            c.call(prefixField + \"_sub\", r2, J, x3),\n            c.call(prefixField + \"_sub\", x3, V2, x3),\n\n            c.call(prefixField + \"_mul\", y1, J, y1_J2),\n            c.call(prefixField + \"_add\", y1_J2, y1_J2, y1_J2),\n\n            c.call(prefixField + \"_sub\", V, x3, y3),\n            c.call(prefixField + \"_mul\", y3, r, y3),\n            c.call(prefixField + \"_sub\", y3, y1_J2, y3),\n\n            c.call(prefixField + \"_add\", z1, H, z3),\n            c.call(prefixField + \"_square\", z3, z3),\n            c.call(prefixField + \"_sub\", z3, Z1Z1, z3),\n            c.call(prefixField + \"_sub\", z3, HH, z3),\n        );\n    }\n\n\n    function buildAddAffine() {\n\n        const f = module.addFunction(prefix + \"_addAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const H = c.i32_const(module.alloc(n8));\n        const HH = c.i32_const(module.alloc(n8));\n        const y2_minus_y1 = c.i32_const(module.alloc(n8));\n        const I = c.i32_const(module.alloc(n8));\n        const J = c.i32_const(module.alloc(n8));\n        const r = c.i32_const(module.alloc(n8));\n        const r2 = c.i32_const(module.alloc(n8));\n        const V = c.i32_const(module.alloc(n8));\n        const V2 = c.i32_const(module.alloc(n8));\n        const y1_J2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copyAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                    ...c.call(prefixField + \"_one\", c.i32_add(c.getLocal(\"pr\") , c.i32_const(n8*2))),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\")),\n                [\n                    ...c.call(prefix + \"_copyAffine\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.call(prefixField + \"_one\", c.i32_add(c.getLocal(\"pr\") , c.i32_const(n8*2))),\n                    ...c.ret([])\n                ]\n            ),\n\n\n            c.if(\n                c.call(prefixField + \"_eq\", x1, x2),\n                c.if(\n                    c.call(prefixField + \"_eq\", y1, y2),\n                    [\n                        ...c.call(prefix + \"_doubleAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                        ...c.ret([])\n                    ]\n                )\n            ),\n\n            c.call(prefixField + \"_sub\", x2, x1, H),\n            c.call(prefixField + \"_sub\", y2, y1, y2_minus_y1),\n            c.call(prefixField + \"_square\", H, HH),\n            c.call(prefixField + \"_add\", HH , HH, I),\n            c.call(prefixField + \"_add\", I , I, I),\n            c.call(prefixField + \"_mul\", H, I, J),\n            c.call(prefixField + \"_add\", y2_minus_y1, y2_minus_y1, r),\n            c.call(prefixField + \"_mul\", x1, I, V),\n            c.call(prefixField + \"_square\", r, r2),\n            c.call(prefixField + \"_add\", V, V, V2),\n\n            c.call(prefixField + \"_sub\", r2, J, x3),\n            c.call(prefixField + \"_sub\", x3, V2, x3),\n\n            c.call(prefixField + \"_mul\", y1, J, y1_J2),\n            c.call(prefixField + \"_add\", y1_J2, y1_J2, y1_J2),\n\n            c.call(prefixField + \"_sub\", V, x3, y3),\n            c.call(prefixField + \"_mul\", y3, r, y3),\n            c.call(prefixField + \"_sub\", y3, y1_J2, y3),\n\n            c.call(prefixField + \"_add\", H, H, z3),\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix + \"_neg\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        f.addCode(\n            c.call(prefixField + \"_copy\", x, x3),\n            c.call(prefixField + \"_neg\", y, y3),\n            c.call(prefixField + \"_copy\", z, z3)\n        );\n    }\n\n\n    function buildNegAffine() {\n        const f = module.addFunction(prefix + \"_negAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n\n        f.addCode(\n            c.call(prefixField + \"_copy\", x, x3),\n            c.call(prefixField + \"_neg\", y, y3),\n        );\n    }\n\n\n    function buildSub() {\n        const f = module.addFunction(prefix + \"_sub\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8*3));\n\n        f.addCode(\n            c.call(prefix + \"_neg\", c.getLocal(\"p2\"), AUX),\n            c.call(prefix + \"_add\", c.getLocal(\"p1\"), AUX, c.getLocal(\"pr\")),\n        );\n    }\n\n    function buildSubMixed() {\n        const f = module.addFunction(prefix + \"_subMixed\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8*3));\n\n        f.addCode(\n            c.call(prefix + \"_negAffine\", c.getLocal(\"p2\"), AUX),\n            c.call(prefix + \"_addMixed\", c.getLocal(\"p1\"), AUX, c.getLocal(\"pr\")),\n        );\n    }\n\n\n    function buildSubAffine() {\n        const f = module.addFunction(prefix + \"_subAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8*3));\n\n        f.addCode(\n            c.call(prefix + \"_negAffine\", c.getLocal(\"p2\"), AUX),\n            c.call(prefix + \"_addAffine\", c.getLocal(\"p1\"), AUX, c.getLocal(\"pr\")),\n        );\n    }\n\n    // This sets Z to One\n    function buildNormalize() {\n        const f = module.addFunction(prefix + \"_normalize\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n\n        const Z_inv = c.i32_const(module.alloc(n8));\n        const Z2_inv = c.i32_const(module.alloc(n8));\n        const Z3_inv = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n                [\n                    ...c.call(prefixField + \"_inverse\", z, Z_inv),\n                    ...c.call(prefixField + \"_square\", Z_inv, Z2_inv),\n                    ...c.call(prefixField + \"_mul\", Z_inv, Z2_inv, Z3_inv),\n                    ...c.call(prefixField + \"_mul\", x, Z2_inv, x3),\n                    ...c.call(prefixField + \"_mul\", y, Z3_inv, y3),\n                    ...c.call(prefixField + \"_one\", z3),\n                ]\n            )\n        );\n    }\n\n\n    // Does not set Z.\n    function buildToAffine() {\n        const f = module.addFunction(prefix + \"_toAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n\n\n        const Z_inv = c.i32_const(module.alloc(n8));\n        const Z2_inv = c.i32_const(module.alloc(n8));\n        const Z3_inv = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefixField + \"_zero\", x3),\n                    ...c.call(prefixField + \"_zero\", y3),\n                ],\n                [\n                    ...c.call(prefixField + \"_inverse\", z, Z_inv),\n                    ...c.call(prefixField + \"_square\", Z_inv, Z2_inv),\n                    ...c.call(prefixField + \"_mul\", Z_inv, Z2_inv, Z3_inv),\n                    ...c.call(prefixField + \"_mul\", x, Z2_inv, x3),\n                    ...c.call(prefixField + \"_mul\", y, Z3_inv, y3),\n                ]\n            )\n        );\n    }\n\n\n    function buildToJacobian() {\n        const f = module.addFunction(prefix + \"_toJacobian\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p1\")),\n                c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n                [\n                    ...c.call(prefixField + \"_one\", z3),\n                    ...c.call(prefixField + \"_copy\", y, y3),\n                    ...c.call(prefixField + \"_copy\", x, x3)\n                ]\n            )\n        );\n    }\n\n    function buildBatchToAffine() {\n        const f = module.addFunction(prefix + \"_batchToAffine\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n        f.addLocal(\"pAux\", \"i32\");\n        f.addLocal(\"itIn\", \"i32\");\n        f.addLocal(\"itAux\", \"i32\");\n        f.addLocal(\"itOut\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const tmp = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"pAux\", c.i32_load( c.i32_const(0) )),\n            c.i32_store(\n                c.i32_const(0),\n                c.i32_add(\n                    c.getLocal(\"pAux\"),\n                    c.i32_mul(c.getLocal(\"n\"), c.i32_const(n8))\n                )\n            ),\n\n            c.call(\n                prefixField + \"_batchInverse\",\n                c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8*2)),\n                c.i32_const(n8*3),\n                c.getLocal(\"n\"),\n                c.getLocal(\"pAux\"),\n                c.i32_const(n8)\n            ),\n\n            c.setLocal(\"itIn\", c.getLocal(\"pIn\")),\n            c.setLocal(\"itAux\", c.getLocal(\"pAux\")),\n            c.setLocal(\"itOut\", c.getLocal(\"pOut\")),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.if(\n                    c.call(prefixField + \"_isZero\", c.getLocal(\"itAux\")),\n                    [\n                        ...c.call(prefixField + \"_zero\", c.getLocal(\"itOut\")),\n                        ...c.call(prefixField + \"_zero\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(n8)))\n                    ],\n                    [\n                        ...c.call(\n                            prefixField+\"_mul\",\n                            c.getLocal(\"itAux\"),\n                            c.i32_add(c.getLocal(\"itIn\"), c.i32_const(n8)),\n                            tmp,\n                        ),\n                        ...c.call(\n                            prefixField+\"_square\",\n                            c.getLocal(\"itAux\"),\n                            c.getLocal(\"itAux\")\n                        ),\n                        ...c.call(\n                            prefixField+\"_mul\",\n                            c.getLocal(\"itAux\"),\n                            c.getLocal(\"itIn\"),\n                            c.getLocal(\"itOut\"),\n                        ),\n                        ...c.call(\n                            prefixField+\"_mul\",\n                            c.getLocal(\"itAux\"),\n                            tmp,\n                            c.i32_add(c.getLocal(\"itOut\"), c.i32_const(n8)),\n                        ),\n                    ]\n                ),\n\n                c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.i32_const(n8*3))),\n                c.setLocal(\"itOut\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(n8*2))),\n                c.setLocal(\"itAux\", c.i32_add(c.getLocal(\"itAux\"), c.i32_const(n8))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n            c.i32_store(\n                c.i32_const(0),\n                c.getLocal(\"pAux\")\n            )\n        );\n    }\n\n\n    // This function is private and does not allow to OVERLAP buffers.\n    function buildReverseBytes() {\n        const f = module.addFunction(prefix + \"__reverseBytes\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n        f.addLocal(\"itOut\", \"i32\");\n        f.addLocal(\"itIn\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\n                \"itOut\",\n                c.i32_sub(\n                    c.i32_add(\n                        c.getLocal(\"pOut\"),\n                        c.getLocal(\"n\")\n                    ),\n                    c.i32_const(1)\n                )\n            ),\n            c.setLocal(\n                \"itIn\",\n                c.getLocal(\"pIn\")\n            ),\n            c.block(c.loop(\n                c.br_if(1, c.i32_lt_s( c.getLocal(\"itOut\"), c.getLocal(\"pOut\") )),\n                c.i32_store8(\n                    c.getLocal(\"itOut\"),\n                    c.i32_load8_u(c.getLocal(\"itIn\")),\n                ),\n                c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.i32_const(1))),\n                c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n\n    }\n\n    function buildLEMtoC() {\n        const f = module.addFunction(prefix + \"_LEMtoC\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const tmp = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"pIn\")),\n                [\n                    ...c.call(prefixField + \"_zero\", c.getLocal(\"pOut\")),\n                    ...c.i32_store8(\n                        c.getLocal(\"pOut\"),\n                        c.i32_const(0x40)\n                    ),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefixField + \"_fromMontgomery\", c.getLocal(\"pIn\"), tmp),\n            c.call(prefix + \"__reverseBytes\", tmp, c.i32_const(n8), c.getLocal(\"pOut\")),\n            c.if(\n                c.i32_eq(\n                    c.call(prefixField + \"_sign\", c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8))),\n                    c.i32_const(-1)\n                ),\n                c.i32_store8(\n                    c.getLocal(\"pOut\"),\n                    c.i32_or(\n                        c.i32_load8_u(c.getLocal(\"pOut\")),\n                        c.i32_const(0x80)\n                    )\n                )\n            ),\n        );\n    }\n\n    function buildLEMtoU() {\n        const f = module.addFunction(prefix + \"_LEMtoU\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const pTmp = module.alloc(n8*2);\n        const tmp = c.i32_const(pTmp);\n        const tmpX = c.i32_const(pTmp);\n        const tmpY = c.i32_const(pTmp + n8);\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"pIn\")),\n                [\n                    ...c.call(prefix + \"_zeroAffine\", c.getLocal(\"pOut\")),\n                    ...c.i32_store8(\n                        c.getLocal(\"pOut\"),\n                        c.i32_const(0x40)\n                    ),\n                    ...c.ret([])\n                ]\n            ),\n\n            c.call(prefix + \"_fromMontgomeryAffine\", c.getLocal(\"pIn\"), tmp),\n\n            c.call(prefix + \"__reverseBytes\", tmpX, c.i32_const(n8), c.getLocal(\"pOut\")),\n            c.call(prefix + \"__reverseBytes\", tmpY, c.i32_const(n8), c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8))),\n        );\n    }\n\n    function buildUtoLEM() {\n        const f = module.addFunction(prefix + \"_UtoLEM\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const pTmp = module.alloc(n8*2);\n        const tmp = c.i32_const(pTmp);\n        const tmpX = c.i32_const(pTmp);\n        const tmpY = c.i32_const(pTmp + n8);\n\n        f.addCode(\n            c.if(\n                c.i32_and(c.i32_load8_u(c.getLocal(\"pIn\")), c.i32_const(0x40)),\n                [\n                    ...c.call(prefix + \"_zeroAffine\", c.getLocal(\"pOut\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefix + \"__reverseBytes\", c.getLocal(\"pIn\"), c.i32_const(n8), tmpX),\n            c.call(prefix + \"__reverseBytes\", c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8)), c.i32_const(n8), tmpY),\n            c.call(prefix + \"_toMontgomeryAffine\", tmp,  c.getLocal(\"pOut\"))\n        );\n    }\n\n    function buildCtoLEM() {\n        const f = module.addFunction(prefix + \"_CtoLEM\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n        f.addLocal(\"firstByte\", \"i32\");\n        f.addLocal(\"greatest\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const pTmp = module.alloc(n8*2);\n        const tmpX = c.i32_const(pTmp);\n        const tmpY = c.i32_const(pTmp + n8);\n\n        f.addCode(\n            c.setLocal(\"firstByte\", c.i32_load8_u(c.getLocal(\"pIn\"))),\n            c.if(\n                c.i32_and(\n                    c.getLocal(\"firstByte\"),\n                    c.i32_const(0x40)\n                ),\n                [\n                    ...c.call(prefix + \"_zeroAffine\", c.getLocal(\"pOut\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.setLocal(\n                \"greatest\",\n                c.i32_and(\n                    c.getLocal(\"firstByte\"),\n                    c.i32_const(0x80)\n                )\n            ),\n\n            c.call(prefixField + \"_copy\", c.getLocal(\"pIn\"), tmpY),\n            c.i32_store8(tmpY, c.i32_and(c.getLocal(\"firstByte\"), c.i32_const(0x3F))),\n            c.call(prefix + \"__reverseBytes\", tmpY, c.i32_const(n8), tmpX),\n            c.call(prefixField + \"_toMontgomery\", tmpX, c.getLocal(\"pOut\")),\n\n            c.call(prefixField + \"_square\", c.getLocal(\"pOut\"), tmpY),\n            c.call(prefixField + \"_mul\", c.getLocal(\"pOut\"), tmpY,  tmpY),\n            c.call(prefixField + \"_add\", tmpY, c.i32_const(pB),  tmpY),\n\n            c.call(prefixField + \"_sqrt\", tmpY, tmpY),\n            c.call(prefixField + \"_neg\", tmpY, tmpX),\n\n            c.if(\n                c.i32_eq(\n                    c.call(prefixField + \"_sign\", tmpY),\n                    c.i32_const(-1)\n                ),\n                c.if(\n                    c.getLocal(\"greatest\"),\n                    c.call(prefixField + \"_copy\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8))),\n                    c.call(prefixField + \"_neg\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8)))\n                ),\n                c.if(\n                    c.getLocal(\"greatest\"),\n                    c.call(prefixField + \"_neg\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8))),\n                    c.call(prefixField + \"_copy\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8)))\n                ),\n            )\n\n        );\n    }\n\n    function buildInCurveAffine() {\n        const f = module.addFunction(prefix + \"_inCurveAffine\");\n        f.addParam(\"pIn\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"pIn\");\n        const y = c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8));\n\n        const y2 = c.i32_const(module.alloc(n8));\n        const x3b = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(prefixField + \"_square\", y, y2),\n            c.call(prefixField + \"_square\", x, x3b),\n            c.call(prefixField + \"_mul\", x, x3b, x3b),\n            c.call(prefixField + \"_add\", x3b, c.i32_const(pB), x3b),\n\n            c.ret(\n                c.call(prefixField + \"_eq\", y2, x3b)\n            )\n        );\n    }\n\n    function buildInCurve() {\n        const f = module.addFunction(prefix + \"_inCurve\");\n        f.addParam(\"pIn\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8*2));\n\n        f.addCode(\n            c.call(prefix + \"_toAffine\", c.getLocal(\"pIn\"), aux),\n\n            c.ret(\n                c.call(prefix + \"_inCurveAffine\", aux),\n            )\n        );\n    }\n\n    buildIsZeroAffine();\n    buildIsZero();\n    buildZeroAffine();\n    buildZero();\n    buildCopyAffine();\n    buildCopy();\n    buildToJacobian();\n    buildEqAffine();\n    buildEqMixed();\n    buildEq();\n    buildDoubleAffine();\n    buildDouble();\n    buildAddAffine();\n    buildAddMixed();\n    buildAdd();\n    buildNegAffine();\n    buildNeg();\n    buildSubAffine();\n    buildSubMixed();\n    buildSub();\n    buildFromMontgomeryAffine();\n    buildFromMontgomery();\n    buildToMontgomeryAffine();\n    buildToMontgomery();\n    buildToAffine();\n    buildInCurveAffine();\n    buildInCurve();\n\n    buildBatchToAffine();\n\n    buildNormalize();\n\n\n    buildReverseBytes();\n\n    buildLEMtoU();\n    buildLEMtoC();\n    buildUtoLEM();\n    buildCtoLEM();\n\n    buildBatchConvertion(module, prefix + \"_batchLEMtoU\", prefix + \"_LEMtoU\", n8*2, n8*2);\n    buildBatchConvertion(module, prefix + \"_batchLEMtoC\", prefix + \"_LEMtoC\", n8*2, n8);\n    buildBatchConvertion(module, prefix + \"_batchUtoLEM\", prefix + \"_UtoLEM\", n8*2, n8*2);\n    buildBatchConvertion(module, prefix + \"_batchCtoLEM\", prefix + \"_CtoLEM\", n8, n8*2, true);\n\n    buildBatchConvertion(module, prefix + \"_batchToJacobian\", prefix + \"_toJacobian\", n8*2, n8*3, true);\n\n    buildMultiexp(module, prefix, prefix + \"_multiexp\", prefix + \"_add\", n8*3);\n    buildMultiexp(module, prefix, prefix + \"_multiexpAffine\", prefix + \"_addMixed\", n8*2);\n\n    /*\n    buildTimesScalar(\n        module,\n        prefix + \"_timesScalarOld\",\n        n8*3,\n        prefix + \"_add\",\n        prefix + \"_double\",\n        prefix + \"_copy\",\n        prefix + \"_zero\",\n    );\n    */\n    buildTimesScalarNAF(\n        module,\n        prefix + \"_timesScalar\",\n        n8*3,\n        prefix + \"_add\",\n        prefix + \"_double\",\n        prefix + \"_sub\",\n        prefix + \"_copy\",\n        prefix + \"_zero\"\n    );\n\n    buildTimesScalarNAF(\n        module,\n        prefix + \"_timesScalarAffine\",\n        n8*2,\n        prefix + \"_addMixed\",\n        prefix + \"_double\",\n        prefix + \"_subMixed\",\n        prefix + \"_copyAffine\",\n        prefix + \"_zero\"\n    );\n\n    module.exportFunction(prefix + \"_isZero\");\n    module.exportFunction(prefix + \"_isZeroAffine\");\n\n    module.exportFunction(prefix + \"_eq\");\n    module.exportFunction(prefix + \"_eqMixed\");\n    module.exportFunction(prefix + \"_eqAffine\");\n\n    module.exportFunction(prefix + \"_copy\");\n    module.exportFunction(prefix + \"_copyAffine\");\n\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_zeroAffine\");\n\n    module.exportFunction(prefix + \"_double\");\n    module.exportFunction(prefix + \"_doubleAffine\");\n\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_addMixed\");\n    module.exportFunction(prefix + \"_addAffine\");\n\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_negAffine\");\n\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_subMixed\");\n    module.exportFunction(prefix + \"_subAffine\");\n\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_fromMontgomeryAffine\");\n\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomeryAffine\");\n\n    module.exportFunction(prefix + \"_timesScalar\");\n    module.exportFunction(prefix + \"_timesScalarAffine\");\n\n    module.exportFunction(prefix + \"_normalize\");\n\n    // Convertion functions\n    module.exportFunction(prefix + \"_LEMtoU\");\n    module.exportFunction(prefix + \"_LEMtoC\");\n    module.exportFunction(prefix + \"_UtoLEM\");\n    module.exportFunction(prefix + \"_CtoLEM\");\n\n    module.exportFunction(prefix + \"_batchLEMtoU\");\n    module.exportFunction(prefix + \"_batchLEMtoC\");\n    module.exportFunction(prefix + \"_batchUtoLEM\");\n    module.exportFunction(prefix + \"_batchCtoLEM\");\n\n    module.exportFunction(prefix + \"_toAffine\");\n    module.exportFunction(prefix + \"_toJacobian\");\n\n    module.exportFunction(prefix + \"_batchToAffine\");\n    module.exportFunction(prefix + \"_batchToJacobian\");\n\n    module.exportFunction(prefix + \"_inCurve\");\n    module.exportFunction(prefix + \"_inCurveAffine\");\n\n    /*\n    buildG1MulScalar(module, zq);\n    module.exportFunction(\"g1MulScalar\");\n    */\n\n    return prefix;\n};\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { isOdd, modInv, modPow } = require(\"./bigint.js\");\nconst utils = require(\"./utils.js\");\n\nmodule.exports = function buildFFT(module, prefix, gPrefix, fPrefix, opGtimesF) {\n\n    const n64f = module.modules[fPrefix].n64;\n    const n8f = n64f*8;\n\n    const n64g = module.modules[gPrefix].n64;\n    const n8g = n64g*8;\n\n    const q = module.modules[fPrefix].q;\n\n    let rem = q - 1n;\n    let maxBits = 0;\n    while (!isOdd(rem)) {\n        maxBits ++;\n        rem = rem >> 1n;\n    }\n\n    let nr = 2n;\n\n    while ( modPow(nr, q >> 1n, q) === 1n ) nr = nr + 1n;\n\n    // console.log(nr);\n\n    const w = new Array(maxBits+1);\n    w[maxBits] = modPow(nr, rem, q);\n\n    let n=maxBits-1;\n    while (n>=0) {\n        w[n] = modPow(w[n+1], 2n, q);\n        n--;\n    }\n\n    const bytes = [];\n    const R = (1n << BigInt(n8f*8)) % q;\n\n    for (let i=0; i<w.length; i++) {\n        const m = w[i] * R % q;\n        bytes.push(...utils.bigInt2BytesLE(m, n8f));\n    }\n\n    const ROOTs = module.alloc(bytes);\n\n    const i2 = new Array(maxBits+1);\n    i2[0] = 1n;\n\n    for (let i=1; i<=maxBits; i++) {\n        i2[i] = i2[i-1] * 2n;\n    }\n\n    const bytesi2 =[];\n    for (let i=0; i<=maxBits; i++) {\n        const m = modInv(i2[i], q) * R % q;\n        bytesi2.push(...utils.bigInt2BytesLE(m, n8f));\n    }\n\n    const INV2 = module.alloc(bytesi2);\n\n    const shift = modPow(nr, 2n, q);\n    const bytesShiftToSmallM =[];\n    const bytesSConst =[];\n    for (let i=0; i<=maxBits; i++) {\n        const shiftToSmallM = modPow(shift, 2n ** BigInt(i), q);\n        const sConst = modInv(q + 1n - shiftToSmallM, q);\n        bytesShiftToSmallM.push(...utils.bigInt2BytesLE(shiftToSmallM * R % q, n8f));\n        bytesSConst.push(...utils.bigInt2BytesLE(sConst * R % q, n8f));\n    }\n\n    const SHIFT_TO_M = module.alloc( bytesShiftToSmallM  );\n    const SCONST = module.alloc( bytesSConst  );\n\n    function rev(x) {\n        let r=0;\n        for (let i=0; i<8; i++) {\n            if (x & (1 << i)) {\n                r = r | (0x80 >> i);\n            }\n        }\n        return r;\n    }\n\n    const rtable = Array(256);\n    for (let i=0; i<256; i++) {\n        rtable[i] = rev(i);\n    }\n\n    const REVTABLE = module.alloc(rtable);\n\n\n    function buildLog2() {\n        const f = module.addFunction(prefix+\"__log2\");\n        f.addParam(\"n\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"bits\", \"i32\");\n        f.addLocal(\"aux\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\n                \"aux\",\n                c.i32_shr_u(\n                    c.getLocal(\"n\"),\n                    c.i32_const(1)\n                )\n            )\n        );\n        f.addCode(c.setLocal(\"bits\", c.i32_const(0)));\n\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.i32_eqz(c.getLocal(\"aux\"))\n            ),\n\n            c.setLocal(\n                \"aux\",\n                c.i32_shr_u(\n                    c.getLocal(\"aux\"),\n                    c.i32_const(1)\n                )\n            ),\n\n            c.setLocal(\n                \"bits\",\n                c.i32_add(\n                    c.getLocal(\"bits\"),\n                    c.i32_const(1)\n                )\n            ),\n\n            c.br(0)\n        )));\n\n        f.addCode(c.if(\n            c.i32_ne(\n                c.getLocal(\"n\"),\n                c.i32_shl(\n                    c.i32_const(1),\n                    c.getLocal(\"bits\")\n                )\n            ),\n            c.unreachable()\n        ));\n\n        f.addCode(c.if(\n            c.i32_gt_u(\n                c.getLocal(\"bits\"),\n                c.i32_const(maxBits)\n            ),\n            c.unreachable()\n        ));\n\n        f.addCode(c.getLocal(\"bits\"));\n    }\n\n    function buildFFT() {\n        const f = module.addFunction(prefix+\"_fft\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n\n        f.addLocal(\"bits\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const One = c.i32_const(module.alloc(n8f));\n\n        f.addCode(\n            c.setLocal(\n                \"bits\",\n                c.call(\n                    prefix + \"__log2\",\n                    c.getLocal(\"n\")\n                )\n            ),\n            c.call(fPrefix + \"_one\", One),\n            c.call(\n                prefix+\"_rawfft\",\n                c.getLocal(\"px\"),\n                c.getLocal(\"bits\"),\n                c.i32_const(0),\n                One\n            )\n        );\n\n    }\n\n    function buildIFFT() {\n        const f = module.addFunction(prefix+\"_ifft\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addLocal(\"bits\", \"i32\");\n        f.addLocal(\"pInv2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\n                \"bits\",\n                c.call(\n                    prefix + \"__log2\",\n                    c.getLocal(\"n\")\n                )\n            ),\n            c.setLocal(\n                \"pInv2\",\n                c.i32_add(\n                    c.i32_const(INV2),\n                    c.i32_mul(\n                        c.getLocal(\"bits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n            c.call(\n                prefix+\"_rawfft\",\n                c.getLocal(\"px\"),\n                c.getLocal(\"bits\"),\n                c.i32_const(1),\n                c.getLocal(\"pInv2\")\n            ),\n        );\n    }\n\n    function buildRawFFT() {\n        const f = module.addFunction(prefix+\"_rawfft\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"bits\", \"i32\"); // 2 power\n        f.addParam(\"reverse\", \"i32\");\n        f.addParam(\"mulFactor\", \"i32\");\n\n        f.addLocal(\"s\", \"i32\");\n        f.addLocal(\"k\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"m\", \"i32\");\n        f.addLocal(\"mdiv2\", \"i32\");\n        f.addLocal(\"n\", \"i32\");\n        f.addLocal(\"pwm\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const T = c.i32_const(module.alloc(n8g));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.call(prefix + \"__reversePermutation\", c.getLocal(\"px\"), c.getLocal(\"bits\")),\n            c.setLocal(\"n\", c.i32_shl(c.i32_const(1), c.getLocal(\"bits\"))),\n            c.setLocal(\"s\", c.i32_const(1)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_gt_u(\n                        c.getLocal(\"s\"),\n                        c.getLocal(\"bits\")\n                    )\n                ),\n                c.setLocal(\"m\", c.i32_shl(c.i32_const(1), c.getLocal(\"s\"))),\n                c.setLocal(\"pwm\",\n                    c.i32_add(\n                        c.i32_const(ROOTs),\n                        c.i32_mul(\n                            c.getLocal(\"s\"),\n                            c.i32_const(n8f)\n                        )\n                    )\n                ),\n                c.setLocal(\"k\", c.i32_const(0)),\n                c.block(c.loop(\n                    c.br_if(\n                        1,\n                        c.i32_ge_u(\n                            c.getLocal(\"k\"),\n                            c.getLocal(\"n\")\n                        )\n                    ),\n\n                    c.call(fPrefix + \"_one\", W),\n\n                    c.setLocal(\"mdiv2\", c.i32_shr_u(c.getLocal(\"m\"), c.i32_const(1)) ),\n                    c.setLocal(\"j\", c.i32_const(0)),\n                    c.block(c.loop(\n                        c.br_if(\n                            1,\n                            c.i32_ge_u(\n                                c.getLocal(\"j\"),\n                                c.getLocal(\"mdiv2\")\n                            )\n                        ),\n\n                        c.setLocal(\n                            \"idx1\",\n                            c.i32_add(\n                                c.getLocal(\"px\"),\n                                c.i32_mul(\n                                    c.i32_add(\n                                        c.getLocal(\"k\"),\n                                        c.getLocal(\"j\")\n                                    ),\n                                    c.i32_const(n8g)\n                                )\n                            )\n                        ),\n\n                        c.setLocal(\n                            \"idx2\",\n                            c.i32_add(\n                                c.getLocal(\"idx1\"),\n                                c.i32_mul(\n                                    c.getLocal(\"mdiv2\"),\n                                    c.i32_const(n8g)\n                                )\n                            )\n                        ),\n\n                        c.call(\n                            opGtimesF,\n                            c.getLocal(\"idx2\"),\n                            W,\n                            T\n                        ),\n\n                        c.call(\n                            gPrefix + \"_copy\",\n                            c.getLocal(\"idx1\"),\n                            U\n                        ),\n\n                        c.call(\n                            gPrefix + \"_add\",\n                            U,\n                            T,\n                            c.getLocal(\"idx1\"),\n                        ),\n\n                        c.call(\n                            gPrefix + \"_sub\",\n                            U,\n                            T,\n                            c.getLocal(\"idx2\"),\n                        ),\n\n                        c.call(\n                            fPrefix + \"_mul\",\n                            W,\n                            c.getLocal(\"pwm\"),\n                            W,\n                        ),\n\n                        c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                        c.br(0)\n                    )),\n\n                    c.setLocal(\"k\", c.i32_add(c.getLocal(\"k\"), c.getLocal(\"m\"))),\n                    c.br(0)\n                )),\n\n                c.setLocal(\"s\", c.i32_add(c.getLocal(\"s\"), c.i32_const(1))),\n                c.br(0)\n            )),\n            c.call(\n                prefix + \"__fftFinal\",\n                c.getLocal(\"px\"),\n                c.getLocal(\"bits\"),\n                c.getLocal(\"reverse\"),\n                c.getLocal(\"mulFactor\")\n            )\n        );\n    }\n\n\n    function buildFinalInverse() {\n        const f = module.addFunction(prefix+\"__fftFinal\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"bits\", \"i32\");\n        f.addParam(\"reverse\", \"i32\");\n        f.addParam(\"mulFactor\", \"i32\");\n        f.addLocal(\"n\", \"i32\");\n        f.addLocal(\"ndiv2\", \"i32\");\n        f.addLocal(\"pInv2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"mask\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const T = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.if(\n                c.i32_and(\n                    c.i32_eqz(c.getLocal(\"reverse\")),\n                    c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\"))\n                ),\n                c.ret([])\n            ),\n            c.setLocal(\"n\", c.i32_shl( c.i32_const(1), c.getLocal(\"bits\"))),\n\n            c.setLocal(\"mask\", c.i32_sub( c.getLocal(\"n\") , c.i32_const(1))),\n            c.setLocal(\"i\", c.i32_const(1)),\n            c.setLocal(\n                \"ndiv2\",\n                c.i32_shr_u(\n                    c.getLocal(\"n\"),\n                    c.i32_const(1)\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_ge_u(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"ndiv2\")\n                    )\n                ),\n\n                c.setLocal(\"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.i32_sub(\n                                c.getLocal(\"n\"),\n                                c.getLocal(\"i\")\n                            ),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.if(\n                    c.getLocal(\"reverse\"),\n                    c.if(\n                        c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\")),\n                        [\n                            ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx1\"), T),\n                            ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx2\") , c.getLocal(\"idx1\") ),\n                            ...c.call(gPrefix + \"_copy\", T , c.getLocal(\"idx2\")),\n                        ],\n                        [\n                            ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx1\"), T),\n                            ...c.call(opGtimesF , c.getLocal(\"idx2\") , c.getLocal(\"mulFactor\"), c.getLocal(\"idx1\") ),\n                            ...c.call(opGtimesF , T , c.getLocal(\"mulFactor\"), c.getLocal(\"idx2\")),\n                        ]\n                    ),\n                    c.if(\n                        c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\")),\n                        [\n                            // Do nothing (It should not be here)\n                        ],\n                        [\n                            ...c.call(opGtimesF , c.getLocal(\"idx1\") , c.getLocal(\"mulFactor\"), c.getLocal(\"idx1\") ),\n                            ...c.call(opGtimesF , c.getLocal(\"idx2\") , c.getLocal(\"mulFactor\"), c.getLocal(\"idx2\")),\n                        ]\n                    )\n                ),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n\n                c.br(0)\n            )),\n\n            c.if(\n                c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\")),\n                [\n                    // Do nothing (It should not be here)\n                ],\n                [\n                    ...c.call(opGtimesF, c.getLocal(\"px\") , c.getLocal(\"mulFactor\"), c.getLocal(\"px\")),\n                    ...c.setLocal(\"idx2\",\n                        c.i32_add(\n                            c.getLocal(\"px\"),\n                            c.i32_mul(\n                                c.getLocal(\"ndiv2\"),\n                                c.i32_const(n8g)\n                            )\n                        )\n                    ),\n                    ...c.call(opGtimesF, c.getLocal(\"idx2\"),c.getLocal(\"mulFactor\"), c.getLocal(\"idx2\"))\n                ]\n            )\n        );\n    }\n\n    function buildReversePermutation() {\n        const f = module.addFunction(prefix+\"__reversePermutation\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"bits\", \"i32\");\n        f.addLocal(\"n\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"ri\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const T = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.setLocal(\"n\", c.i32_shl( c.i32_const(1), c.getLocal(\"bits\"))),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\"ri\", c.call(prefix + \"__rev\", c.getLocal(\"i\"), c.getLocal(\"bits\"))),\n\n                c.setLocal(\"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.getLocal(\"ri\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.if(\n                    c.i32_lt_u(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"ri\")\n                    ),\n                    [\n                        ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx1\"), T),\n                        ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx2\") , c.getLocal(\"idx1\")),\n                        ...c.call(gPrefix + \"_copy\", T , c.getLocal(\"idx2\"))\n                    ]\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildRev() {\n        const f = module.addFunction(prefix+\"__rev\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"bits\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.i32_rotl(\n                c.i32_add(\n                    c.i32_add(\n                        c.i32_shl(\n                            c.i32_load8_u(\n                                c.i32_and(\n                                    c.getLocal(\"x\"),\n                                    c.i32_const(0xFF)\n                                ),\n                                REVTABLE,\n                                0\n                            ),\n                            c.i32_const(24)\n                        ),\n                        c.i32_shl(\n                            c.i32_load8_u(\n                                c.i32_and(\n                                    c.i32_shr_u(\n                                        c.getLocal(\"x\"),\n                                        c.i32_const(8)\n                                    ),\n                                    c.i32_const(0xFF)\n                                ),\n                                REVTABLE,\n                                0\n                            ),\n                            c.i32_const(16)\n                        ),\n                    ),\n                    c.i32_add(\n                        c.i32_shl(\n                            c.i32_load8_u(\n                                c.i32_and(\n                                    c.i32_shr_u(\n                                        c.getLocal(\"x\"),\n                                        c.i32_const(16)\n                                    ),\n                                    c.i32_const(0xFF)\n                                ),\n                                REVTABLE,\n                                0\n                            ),\n                            c.i32_const(8)\n                        ),\n                        c.i32_load8_u(\n                            c.i32_and(\n                                c.i32_shr_u(\n                                    c.getLocal(\"x\"),\n                                    c.i32_const(24)\n                                ),\n                                c.i32_const(0xFF)\n                            ),\n                            REVTABLE,\n                            0\n                        ),\n                    )\n                ),\n                c.getLocal(\"bits\")\n            )\n        );\n    }\n\n\n    function buildFFTJoin() {\n        const f = module.addFunction(prefix+\"_fftJoin\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const T = c.i32_const(module.alloc(n8g));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    T\n                ),\n\n                c.call(\n                    gPrefix + \"_copy\",\n                    c.getLocal(\"idx1\"),\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_add\",\n                    U,\n                    T,\n                    c.getLocal(\"idx1\"),\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    U,\n                    T,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W,\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n    function buildFFTJoinExt() {\n        const f = module.addFunction(prefix+\"_fftJoinExt\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addParam(\"totalBits\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"pShiftToM\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n\n            c.setLocal(\"pShiftToM\",\n                c.i32_add(\n                    c.i32_const(SHIFT_TO_M),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    gPrefix + \"_add\",\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx2\"),\n                    U\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"pShiftToM\"),\n                    c.getLocal(\"idx2\")\n                ),\n\n                c.call(\n                    gPrefix + \"_add\",\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"idx2\")\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    gPrefix + \"_copy\",\n                    U,\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildFFTJoinExtInv() {\n        const f = module.addFunction(prefix+\"_fftJoinExtInv\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addParam(\"totalBits\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"pShiftToM\", \"i32\");\n        f.addLocal(\"pSConst\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n\n            c.setLocal(\"pShiftToM\",\n                c.i32_add(\n                    c.i32_const(SHIFT_TO_M),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n            c.setLocal(\"pSConst\",\n                c.i32_add(\n                    c.i32_const(SCONST),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    c.getLocal(\"idx1\"),\n                    U,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"pSConst\"),\n                    c.getLocal(\"idx2\")\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"pShiftToM\"),\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    U,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"pSConst\"),\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n\n    function buildPrepareLagrangeEvaluation() {\n        const f = module.addFunction(prefix+\"_prepareLagrangeEvaluation\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addParam(\"totalBits\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"pShiftToM\", \"i32\");\n        f.addLocal(\"pSConst\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n\n            c.setLocal(\"pShiftToM\",\n                c.i32_add(\n                    c.i32_const(SHIFT_TO_M),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n            c.setLocal(\"pSConst\",\n                c.i32_add(\n                    c.i32_const(SCONST),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"pShiftToM\"),\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    c.getLocal(\"idx2\"),\n                    U,\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    opGtimesF,\n                    U,\n                    c.getLocal(\"pSConst\"),\n                    c.getLocal(\"idx1\"),\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildFFTMix() {\n        const f = module.addFunction(prefix+\"_fftMix\");\n        f.addParam(\"pBuff\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"exp\", \"i32\");\n        f.addLocal(\"nGroups\", \"i32\");\n        f.addLocal(\"nPerGroup\", \"i32\");\n        f.addLocal(\"nPerGroupDiv2\", \"i32\");\n        f.addLocal(\"pairOffset\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"pwm\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const T = c.i32_const(module.alloc(n8g));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.setLocal(\"nPerGroup\", c.i32_shl(c.i32_const(1), c.getLocal(\"exp\"))),\n            c.setLocal(\"nPerGroupDiv2\", c.i32_shr_u(c.getLocal(\"nPerGroup\"), c.i32_const(1))),\n            c.setLocal(\"nGroups\", c.i32_shr_u(c.getLocal(\"n\"), c.getLocal(\"exp\"))),\n            c.setLocal(\"pairOffset\", c.i32_mul(c.getLocal(\"nPerGroupDiv2\"), c.i32_const(n8g))),\n            c.setLocal(\"pwm\",\n                c.i32_add(\n                    c.i32_const(ROOTs),\n                    c.i32_mul(\n                        c.getLocal(\"exp\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"nGroups\")\n                    )\n                ),\n                c.call( fPrefix + \"_one\", W),\n                c.setLocal(\"j\", c.i32_const(0)),\n                c.block(c.loop(\n                    c.br_if(\n                        1,\n                        c.i32_eq(\n                            c.getLocal(\"j\"),\n                            c.getLocal(\"nPerGroupDiv2\")\n                        )\n                    ),\n\n                    c.setLocal(\n                        \"idx1\",\n                        c.i32_add(\n                            c.getLocal(\"pBuff\"),\n                            c.i32_mul(\n                                c.i32_add(\n                                    c.i32_mul(\n                                        c.getLocal(\"i\"),\n                                        c.getLocal(\"nPerGroup\")\n                                    ),\n                                    c.getLocal(\"j\")\n                                ),\n                                c.i32_const(n8g)\n                            )\n                        )\n                    ),\n\n                    c.setLocal(\n                        \"idx2\",\n                        c.i32_add(\n                            c.getLocal(\"idx1\"),\n                            c.getLocal(\"pairOffset\")\n                        )\n                    ),\n\n                    c.call(\n                        opGtimesF,\n                        c.getLocal(\"idx2\"),\n                        W,\n                        T\n                    ),\n\n                    c.call(\n                        gPrefix + \"_copy\",\n                        c.getLocal(\"idx1\"),\n                        U\n                    ),\n\n                    c.call(\n                        gPrefix + \"_add\",\n                        U,\n                        T,\n                        c.getLocal(\"idx1\"),\n                    ),\n\n                    c.call(\n                        gPrefix + \"_sub\",\n                        U,\n                        T,\n                        c.getLocal(\"idx2\"),\n                    ),\n\n                    c.call(\n                        fPrefix + \"_mul\",\n                        W,\n                        c.getLocal(\"pwm\"),\n                        W,\n                    ),\n                    c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n    // Reverse all and multiply by factor\n    function buildFFTFinal() {\n        const f = module.addFunction(prefix+\"_fftFinal\");\n        f.addParam(\"pBuff\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"factor\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"ndiv2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const T = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.setLocal(\"ndiv2\", c.i32_shr_u(c.getLocal(\"n\"), c.i32_const(1))),\n            c.if(\n                c.i32_and(\n                    c.getLocal(\"n\"),\n                    c.i32_const(1)\n                ),\n                c.call(\n                    opGtimesF,\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.getLocal(\"ndiv2\"),\n                            c.i32_const(n8g)\n                        )\n                    ),\n                    c.getLocal(\"factor\"),\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.getLocal(\"ndiv2\"),\n                            c.i32_const(n8g)\n                        )\n                    ),\n                ),\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_ge_u(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"ndiv2\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.i32_sub(\n                                c.i32_sub(\n                                    c.getLocal(\"n\"),\n                                    c.i32_const(1)\n                                ),\n                                c.getLocal(\"i\")\n                            ),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"factor\"),\n                    T\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"factor\"),\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    gPrefix + \"_copy\",\n                    T,\n                    c.getLocal(\"idx1\"),\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n    buildRev();\n    buildReversePermutation();\n    buildFinalInverse();\n    buildRawFFT();\n    buildLog2();\n    buildFFT();\n    buildIFFT();\n    buildFFTJoin();\n    buildFFTJoinExt();\n    buildFFTJoinExtInv();\n    buildFFTMix();\n    buildFFTFinal();\n    buildPrepareLagrangeEvaluation();\n\n    module.exportFunction(prefix+\"_fft\");\n    module.exportFunction(prefix+\"_ifft\");\n    module.exportFunction(prefix+\"_rawfft\");\n    module.exportFunction(prefix+\"_fftJoin\");\n    module.exportFunction(prefix+\"_fftJoinExt\");\n    module.exportFunction(prefix+\"_fftJoinExtInv\");\n    module.exportFunction(prefix+\"_fftMix\");\n    module.exportFunction(prefix+\"_fftFinal\");\n    module.exportFunction(prefix+\"_prepareLagrangeEvaluation\");\n\n};\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildPol(module, prefix, prefixField) {\n\n    const n64 = module.modules[prefixField].n64;\n    const n8 = n64*8;\n\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addLocal(\"lastp\", \"i32\");\n        f.addLocal(\"p\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\"p\", c.getLocal(\"px\")),\n            c.setLocal(\n                \"lastp\",\n                c.i32_add(\n                    c.getLocal(\"px\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"p\"),\n                        c.getLocal(\"lastp\")\n                    )\n                ),\n                c.call(prefixField + \"_zero\", c.getLocal(\"p\")),\n                c.setLocal(\"p\", c.i32_add(c.getLocal(\"p\"), c.i32_const(n8))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildConstructLC() {\n        const f = module.addFunction(prefix+\"_constructLC\");\n        f.addParam(\"ppolynomials\", \"i32\");\n        f.addParam(\"psignals\", \"i32\");\n        f.addParam(\"nSignals\", \"i32\");\n        f.addParam(\"pres\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"pp\", \"i32\");\n        f.addLocal(\"ps\", \"i32\");\n        f.addLocal(\"pd\", \"i32\");\n        f.addLocal(\"ncoefs\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.setLocal(\"pp\", c.getLocal(\"ppolynomials\")),\n            c.setLocal(\"ps\", c.getLocal(\"psignals\")),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"nSignals\")\n                    )\n                ),\n\n                c.setLocal(\"ncoefs\", c.i32_load(c.getLocal(\"pp\"))),\n                c.setLocal(\"pp\", c.i32_add(c.getLocal(\"pp\"), c.i32_const(4))),\n\n                c.setLocal(\"j\", c.i32_const(0)),\n                c.block(c.loop(\n                    c.br_if(\n                        1,\n                        c.i32_eq(\n                            c.getLocal(\"j\"),\n                            c.getLocal(\"ncoefs\")\n                        )\n                    ),\n\n                    c.setLocal(\n                        \"pd\",\n                        c.i32_add(\n                            c.getLocal(\"pres\"),\n                            c.i32_mul(\n                                c.i32_load(c.getLocal(\"pp\")),\n                                c.i32_const(n8)\n                            )\n                        )\n                    ),\n\n                    c.setLocal(\"pp\", c.i32_add(c.getLocal(\"pp\"), c.i32_const(4))),\n\n\n                    c.call(\n                        prefixField + \"_mul\",\n                        c.getLocal(\"ps\"),\n                        c.getLocal(\"pp\"),\n                        aux\n                    ),\n\n                    c.call(\n                        prefixField + \"_add\",\n                        aux,\n                        c.getLocal(\"pd\"),\n                        c.getLocal(\"pd\")\n                    ),\n\n                    c.setLocal(\"pp\", c.i32_add(c.getLocal(\"pp\"), c.i32_const(n8))),\n                    c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n\n                c.setLocal(\"ps\", c.i32_add(c.getLocal(\"ps\"), c.i32_const(n8))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n\n    }\n\n    buildZero();\n    buildConstructLC();\n\n\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_constructLC\");\n\n    return prefix;\n\n\n\n\n};\n", "\nmodule.exports = function buildQAP(module, prefix, prefixField) {\n\n    const n64 = module.modules[prefixField].n64;\n    const n8 = n64*8;\n\n\n    function buildBuildABC() {\n        const f = module.addFunction(prefix+\"_buildABC\");\n        f.addParam(\"pCoefs\", \"i32\");\n        f.addParam(\"nCoefs\", \"i32\");\n        f.addParam(\"pWitness\", \"i32\");\n        f.addParam(\"pA\", \"i32\");\n        f.addParam(\"pB\", \"i32\");\n        f.addParam(\"pC\", \"i32\");\n        f.addParam(\"offsetOut\", \"i32\");\n        f.addParam(\"nOut\", \"i32\");\n        f.addParam(\"offsetWitness\", \"i32\");\n        f.addParam(\"nWitness\", \"i32\");\n        f.addLocal(\"it\", \"i32\");\n        f.addLocal(\"ita\", \"i32\");\n        f.addLocal(\"itb\", \"i32\");\n        f.addLocal(\"last\", \"i32\");\n        f.addLocal(\"m\", \"i32\");\n        f.addLocal(\"c\", \"i32\");\n        f.addLocal(\"s\", \"i32\");\n        f.addLocal(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n\n            // Set output a and b to 0\n            c.setLocal(\"ita\", c.getLocal(\"pA\")),\n            c.setLocal(\"itb\", c.getLocal(\"pB\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pA\"),\n                    c.i32_mul(\n                        c.getLocal(\"nOut\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(prefixField + \"_zero\", c.getLocal(\"ita\")),\n                c.call(prefixField + \"_zero\", c.getLocal(\"itb\")),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.br(0)\n            )),\n\n\n            c.setLocal(\"it\", c.getLocal(\"pCoefs\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pCoefs\"),\n                    c.i32_mul(\n                        c.getLocal(\"nCoefs\"),\n                        c.i32_const(n8+12)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"it\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.setLocal(\n                    \"s\",\n                    c.i32_load(c.getLocal(\"it\"), 8)\n                ),\n                c.if(\n                    c.i32_or(\n                        c.i32_lt_u(\n                            c.getLocal(\"s\"),\n                            c.getLocal(\"offsetWitness\"),\n                        ),\n                        c.i32_ge_u(\n                            c.getLocal(\"s\"),\n                            c.i32_add(\n                                c.getLocal(\"offsetWitness\"),\n                                c.getLocal(\"nWitness\"),\n                            )\n                        )\n                    ),\n                    [\n                        ...c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                        ...c.br(1)\n                    ]\n                ),\n\n                c.setLocal(\n                    \"m\",\n                    c.i32_load(c.getLocal(\"it\"))\n                ),\n                c.if(\n                    c.i32_eq(c.getLocal(\"m\"), c.i32_const(0)),\n                    c.setLocal(\"pOut\", c.getLocal(\"pA\")),\n                    c.if(\n                        c.i32_eq(c.getLocal(\"m\"), c.i32_const(1)),\n                        c.setLocal(\"pOut\", c.getLocal(\"pB\")),\n                        [\n                            ...c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                            ...c.br(1)\n                        ]\n                    )\n                ),\n                c.setLocal(\n                    \"c\",\n                    c.i32_load(c.getLocal(\"it\"), 4)\n                ),\n                c.if(\n                    c.i32_or(\n                        c.i32_lt_u(\n                            c.getLocal(\"c\"),\n                            c.getLocal(\"offsetOut\"),\n                        ),\n                        c.i32_ge_u(\n                            c.getLocal(\"c\"),\n                            c.i32_add(\n                                c.getLocal(\"offsetOut\"),\n                                c.getLocal(\"nOut\"),\n                            )\n                        )\n                    ),\n                    [\n                        ...c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                        ...c.br(1)\n                    ]\n                ),\n                c.setLocal(\n                    \"pOut\",\n                    c.i32_add(\n                        c.getLocal(\"pOut\"),\n                        c.i32_mul(\n                            c.i32_sub(\n                                c.getLocal(\"c\"),\n                                c.getLocal(\"offsetOut\")\n                            ),\n                            c.i32_const(n8)\n                        )\n                    )\n                ),\n                c.call(\n                    prefixField + \"_mul\",\n                    c.i32_add(\n                        c.getLocal(\"pWitness\"),\n                        c.i32_mul(\n                            c.i32_sub(c.getLocal(\"s\"), c.getLocal(\"offsetWitness\")),\n                            c.i32_const(n8)\n                        )\n                    ),\n                    c.i32_add( c.getLocal(\"it\"), c.i32_const(12)),\n                    aux\n                ),\n                c.call(\n                    prefixField + \"_add\",\n                    c.getLocal(\"pOut\"),\n                    aux,\n                    c.getLocal(\"pOut\"),\n                ),\n                c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                c.br(0)\n            )),\n\n            c.setLocal(\"ita\", c.getLocal(\"pA\")),\n            c.setLocal(\"itb\", c.getLocal(\"pB\")),\n            c.setLocal(\"it\", c.getLocal(\"pC\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pA\"),\n                    c.i32_mul(\n                        c.getLocal(\"nOut\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(\n                    prefixField + \"_mul\",\n                    c.getLocal(\"ita\"),\n                    c.getLocal(\"itb\"),\n                    c.getLocal(\"it\")\n                ),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8))),\n                c.br(0)\n            )),\n\n        );\n    }\n\n    function buildJoinABC() {\n        const f = module.addFunction(prefix+\"_joinABC\");\n        f.addParam(\"pA\", \"i32\");\n        f.addParam(\"pB\", \"i32\");\n        f.addParam(\"pC\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pP\", \"i32\");\n        f.addLocal(\"ita\", \"i32\");\n        f.addLocal(\"itb\", \"i32\");\n        f.addLocal(\"itc\", \"i32\");\n        f.addLocal(\"itp\", \"i32\");\n        f.addLocal(\"last\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"ita\", c.getLocal(\"pA\")),\n            c.setLocal(\"itb\", c.getLocal(\"pB\")),\n            c.setLocal(\"itc\", c.getLocal(\"pC\")),\n            c.setLocal(\"itp\", c.getLocal(\"pP\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pA\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(\n                    prefixField + \"_mul\",\n                    c.getLocal(\"ita\"),\n                    c.getLocal(\"itb\"),\n                    aux\n                ),\n                c.call(\n                    prefixField + \"_sub\",\n                    aux,\n                    c.getLocal(\"itc\"),\n                    c.getLocal(\"itp\"),\n                ),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.setLocal(\"itc\", c.i32_add(c.getLocal(\"itc\"), c.i32_const(n8))),\n                c.setLocal(\"itp\", c.i32_add(c.getLocal(\"itp\"), c.i32_const(n8))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildBatchAdd() {\n        const f = module.addFunction(prefix+\"_batchAdd\");\n        f.addParam(\"pa\", \"i32\");\n        f.addParam(\"pb\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"ita\", \"i32\");\n        f.addLocal(\"itb\", \"i32\");\n        f.addLocal(\"itr\", \"i32\");\n        f.addLocal(\"last\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\"ita\", c.getLocal(\"pa\")),\n            c.setLocal(\"itb\", c.getLocal(\"pb\")),\n            c.setLocal(\"itr\", c.getLocal(\"pr\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pa\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(\n                    prefixField + \"_add\",\n                    c.getLocal(\"ita\"),\n                    c.getLocal(\"itb\"),\n                    c.getLocal(\"itr\"),\n                ),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.setLocal(\"itr\", c.i32_add(c.getLocal(\"itr\"), c.i32_const(n8))),\n                c.br(0)\n            ))\n        );\n    }\n\n    buildBuildABC();\n    buildJoinABC();\n    buildBatchAdd();\n\n    module.exportFunction(prefix + \"_buildABC\");\n    module.exportFunction(prefix + \"_joinABC\");\n    module.exportFunction(prefix + \"_batchAdd\");\n\n    return prefix;\n\n};\n\n", "\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildApplyKey(module, fnName, gPrefix, frPrefix, sizeGIn, sizeGOut, sizeF, opGtimesF) {\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"pIn\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pFirst\", \"i32\");\n    f.addParam(\"pInc\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addLocal(\"pOldFree\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"pFrom\", \"i32\");\n    f.addLocal(\"pTo\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const t = c.i32_const(module.alloc(sizeF));\n\n    f.addCode(\n        c.setLocal(\"pFrom\", c.getLocal(\"pIn\")),\n        c.setLocal(\"pTo\", c.getLocal(\"pOut\")),\n    );\n\n    // t = first\n    f.addCode(\n        c.call(\n            frPrefix + \"_copy\",\n            c.getLocal(\"pFirst\"),\n            t\n        )\n    );\n    f.addCode(\n        c.setLocal(\"i\", c.i32_const(0)),\n        c.block(c.loop(\n            c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n            c.call(\n                opGtimesF,\n                c.getLocal(\"pFrom\"),\n                t,\n                c.getLocal(\"pTo\")\n            ),\n            c.setLocal(\"pFrom\", c.i32_add(c.getLocal(\"pFrom\"), c.i32_const(sizeGIn))),\n            c.setLocal(\"pTo\", c.i32_add(c.getLocal(\"pTo\"), c.i32_const(sizeGOut))),\n\n            // t = t* inc\n            c.call(\n                frPrefix + \"_mul\",\n                t,\n                c.getLocal(\"pInc\"),\n                t\n            ),\n            c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        ))\n    );\n\n    module.exportFunction(fnName);\n\n};\n", "const utils = require(\"../utils\");\n\nconst buildF1m =require(\"../build_f1m.js\");\nconst buildF1 =require(\"../build_f1.js\");\nconst buildF2m =require(\"../build_f2m.js\");\nconst buildF3m =require(\"../build_f3m.js\");\nconst buildCurve =require(\"../build_curve_jacobian_a0.js\");\nconst buildFFT = require(\"../build_fft\");\nconst buildPol = require(\"../build_pol\");\nconst buildQAP = require(\"../build_qap\");\nconst buildApplyKey = require(\"../build_applykey\");\nconst { bitLength, modInv, isOdd, isNegative } = require(\"../bigint.js\");\n\nmodule.exports = function buildBN128(module, _prefix) {\n\n    const prefix = _prefix || \"bn128\";\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const q = 21888242871839275222246405745257275088696311157297823662689037894645226208583n;\n    const r = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;\n\n\n    const n64 = Math.floor((bitLength(q - 1n) - 1)/64) +1;\n    const n8 = n64*8;\n    const frsize = n8;\n    const f1size = n8;\n    const f2size = f1size * 2;\n    const ftsize = f1size * 12;\n\n    const pr = module.alloc(utils.bigInt2BytesLE( r, frsize ));\n\n    const f1mPrefix = buildF1m(module, q, \"f1m\");\n    buildF1(module, r, \"fr\", \"frm\");\n\n    const pG1b = module.alloc(utils.bigInt2BytesLE( toMontgomery(3n), f1size ));\n    const g1mPrefix = buildCurve(module, \"g1m\", \"f1m\", pG1b);\n\n    buildFFT(module, \"frm\", \"frm\", \"frm\", \"frm_mul\");\n\n    buildPol(module, \"pol\", \"frm\");\n    buildQAP(module, \"qap\", \"frm\");\n\n    const f2mPrefix = buildF2m(module, \"f1m_neg\", \"f2m\", \"f1m\");\n    const pG2b = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size )\n    ]);\n    const g2mPrefix = buildCurve(module, \"g2m\", \"f2m\", pG2b);\n\n\n    function buildGTimesFr(fnName, opMul) {\n        const f = module.addFunction(fnName);\n        f.addParam(\"pG\", \"i32\");\n        f.addParam(\"pFr\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(\"frm_fromMontgomery\", c.getLocal(\"pFr\"), AUX),\n            c.call(\n                opMul,\n                c.getLocal(\"pG\"),\n                AUX,\n                c.i32_const(n8),\n                c.getLocal(\"pr\")\n            )\n        );\n\n        module.exportFunction(fnName);\n    }\n    buildGTimesFr(\"g1m_timesFr\", \"g1m_timesScalar\");\n    buildFFT(module, \"g1m\", \"g1m\", \"frm\", \"g1m_timesFr\");\n\n    buildGTimesFr(\"g2m_timesFr\", \"g2m_timesScalar\");\n    buildFFT(module, \"g2m\", \"g2m\", \"frm\", \"g2m_timesFr\");\n\n    buildGTimesFr(\"g1m_timesFrAffine\", \"g1m_timesScalarAffine\");\n    buildGTimesFr(\"g2m_timesFrAffine\", \"g2m_timesScalarAffine\");\n\n    buildApplyKey(module, \"frm_batchApplyKey\", \"fmr\", \"frm\", n8, n8, n8, \"frm_mul\");\n    buildApplyKey(module, \"g1m_batchApplyKey\", \"g1m\", \"frm\", n8*3, n8*3, n8, \"g1m_timesFr\");\n    buildApplyKey(module, \"g1m_batchApplyKeyMixed\", \"g1m\", \"frm\", n8*2, n8*3, n8, \"g1m_timesFrAffine\");\n    buildApplyKey(module, \"g2m_batchApplyKey\", \"g2m\", \"frm\", n8*2*3, n8*3*2, n8, \"g2m_timesFr\");\n    buildApplyKey(module, \"g2m_batchApplyKeyMixed\", \"g2m\", \"frm\", n8*2*2, n8*3*2, n8, \"g2m_timesFrAffine\");\n\n    function toMontgomery(a) {\n        return BigInt(a) * ( 1n << BigInt(f1size*8)) % q;\n    }\n\n    const G1gen = [\n        1n,\n        2n,\n        1n\n    ];\n\n    const pG1gen = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[2]), f1size ),\n        ]\n    );\n\n    const G1zero = [\n        0n,\n        1n,\n        0n\n    ];\n\n    const pG1zero = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[2]), f1size )\n        ]\n    );\n\n    const G2gen = [\n        [\n            10857046999023057135944570762232829481370756359578518086990519993285655852781n,\n            11559732032986387107991004021392285783925812861821192530917403151452391805634n,\n        ],[\n            8495653923123431417604973247489272438418190587263600148770280649306958101930n,\n            4082367875863433681332203403145435568316851327593401208105741076214120093531n,\n        ],[\n            1n,\n            0n,\n        ]\n    ];\n\n    const pG2gen = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[0][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[0][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[1][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[1][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[2][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[2][1]), f1size ),\n        ]\n    );\n\n    const G2zero = [\n        [\n            0n,\n            0n,\n        ],[\n            1n,\n            0n,\n        ],[\n            0n,\n            0n,\n        ]\n    ];\n\n    const pG2zero = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[0][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[0][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[1][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[1][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[2][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[2][1]), f1size ),\n        ]\n    );\n\n    const pOneT = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(1), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n    ]);\n\n    const pNonResidueF6 = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(9), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(1), f1size ),\n    ]);\n\n    const pTwoInv = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(  modInv(2n, q)), f1size ),\n        ...utils.bigInt2BytesLE( 0n, f1size )\n    ]);\n\n    const pAltBn128Twist = pNonResidueF6;\n\n    const pTwistCoefB = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size ),\n    ]);\n\n    function build_mulNR6() {\n        const f = module.addFunction(prefix + \"_mulNR6\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(\n                f2mPrefix + \"_mul\",\n                c.i32_const(pNonResidueF6),\n                c.getLocal(\"x\"),\n                c.getLocal(\"pr\")\n            )\n        );\n    }\n    build_mulNR6();\n\n    const f6mPrefix = buildF3m(module, prefix+\"_mulNR6\", \"f6m\", \"f2m\");\n\n    function build_mulNR12() {\n        const f = module.addFunction(prefix + \"_mulNR12\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(\n                f2mPrefix + \"_mul\",\n                c.i32_const(pNonResidueF6),\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8*4)),\n                c.getLocal(\"pr\")\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.getLocal(\"x\"),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2)),\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8*2)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*4)),\n            )\n        );\n    }\n    build_mulNR12();\n\n    const ftmPrefix = buildF2m(module, prefix+\"_mulNR12\", \"ftm\", f6mPrefix);\n\n\n    const ateLoopCount = 29793968203157093288n;\n    const ateLoopBitBytes = bits(ateLoopCount);\n    const pAteLoopBitBytes = module.alloc(ateLoopBitBytes);\n    const isLoopNegative = false;\n\n    const ateCoefSize = 3 * f2size;\n    const ateNDblCoefs = ateLoopBitBytes.length-1;\n    const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) =>  acc + ( b!=0 ? 1 : 0)   ,0);\n    const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;\n    const prePSize = 3*2*n8;\n    const preQSize = 3*n8*2 + ateNCoefs*ateCoefSize;\n    const finalExpIsNegative = false;\n\n\n    module.modules[prefix] = {\n        n64: n64,\n        pG1gen: pG1gen,\n        pG1zero: pG1zero,\n        pG1b: pG1b,\n        pG2gen: pG2gen,\n        pG2zero: pG2zero,\n        pG2b: pG2b,\n        pq: module.modules[\"f1m\"].pq,\n        pr: pr,\n        pOneT: pOneT,\n        prePSize: prePSize,\n        preQSize: preQSize,\n        r: r.toString(),\n        q: q.toString()\n    };\n\n    // console.log(\"PrePSize: \" +prePSize);\n    // console.log(\"PreQSize: \" +preQSize);\n\n    const finalExpZ = 4965661367192848881n;\n\n    function naf(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd(E)) {\n                const z = 2 - Number(E % 4n);\n                res.push( z );\n                E = E - BigInt(z);\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function bits(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd(E)) {\n                res.push( 1 );\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function buildPrepareG1() {\n        const f = module.addFunction(prefix+ \"_prepareG1\");\n        f.addParam(\"pP\", \"i32\");\n        f.addParam(\"ppreP\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(g1mPrefix + \"_normalize\", c.getLocal(\"pP\"), c.getLocal(\"ppreP\")),  // TODO Remove if already in affine\n        );\n    }\n\n    function buildPrepAddStep() {\n        const f = module.addFunction(prefix+ \"_prepAddStep\");\n        f.addParam(\"pQ\", \"i32\");\n        f.addParam(\"pR\", \"i32\");\n        f.addParam(\"pCoef\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const X2  = c.getLocal(\"pQ\");\n        const Y2  = c.i32_add(c.getLocal(\"pQ\"), c.i32_const(f2size));\n\n        const X1  = c.getLocal(\"pR\");\n        const Y1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f2size));\n        const Z1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(2*f2size));\n\n        const ELL_0  = c.getLocal(\"pCoef\");\n        const ELL_VW = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(f2size));\n        const ELL_VV  = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(2*f2size));\n\n        const D = ELL_VW;\n        const E = c.i32_const(module.alloc(f2size));\n        const F = c.i32_const(module.alloc(f2size));\n        const G = c.i32_const(module.alloc(f2size));\n        const H = c.i32_const(module.alloc(f2size));\n        const I = c.i32_const(module.alloc(f2size));\n        const J = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n            // D = X1 - X2*Z1\n            c.call(f2mPrefix + \"_mul\", X2, Z1, D),\n            c.call(f2mPrefix + \"_sub\", X1, D, D),\n\n            // E = Y1 - Y2*Z1\n            c.call(f2mPrefix + \"_mul\", Y2, Z1, E),\n            c.call(f2mPrefix + \"_sub\", Y1, E, E),\n\n            // F = D^2\n            c.call(f2mPrefix + \"_square\", D, F),\n\n            // G = E^2\n            c.call(f2mPrefix + \"_square\", E, G),\n\n            // H = D*F\n            c.call(f2mPrefix + \"_mul\", D, F, H),\n\n            // I = X1 * F\n            c.call(f2mPrefix + \"_mul\", X1, F, I),\n\n            // J = H + Z1*G - (I+I)\n            c.call(f2mPrefix + \"_add\", I, I, AUX),\n            c.call(f2mPrefix + \"_mul\", Z1, G, J),\n            c.call(f2mPrefix + \"_add\", H, J, J),\n            c.call(f2mPrefix + \"_sub\", J, AUX, J),\n\n\n            // X3 (X1) = D*J\n            c.call(f2mPrefix + \"_mul\", D, J, X1),\n\n            // Y3 (Y1) = E*(I-J)-(H*Y1)\n            c.call(f2mPrefix + \"_mul\", H, Y1, Y1),\n            c.call(f2mPrefix + \"_sub\", I, J, AUX),\n            c.call(f2mPrefix + \"_mul\", E, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", AUX, Y1, Y1),\n\n            // Z3 (Z1) = Z1*H\n            c.call(f2mPrefix + \"_mul\", Z1, H, Z1),\n\n            // ell_0 = xi * (E * X2 - D * Y2)\n            c.call(f2mPrefix + \"_mul\", D, Y2, AUX),\n            c.call(f2mPrefix + \"_mul\", E, X2, ELL_0),\n            c.call(f2mPrefix + \"_sub\", ELL_0, AUX, ELL_0),\n            c.call(f2mPrefix + \"_mul\", ELL_0, c.i32_const(pAltBn128Twist), ELL_0),\n\n\n            // ell_VV = - E (later: * xP)\n            c.call(f2mPrefix + \"_neg\", E, ELL_VV),\n\n            // ell_VW = D (later: * yP    )\n            // Already assigned\n\n        );\n    }\n\n\n\n    function buildPrepDoubleStep() {\n        const f = module.addFunction(prefix+ \"_prepDblStep\");\n        f.addParam(\"pR\", \"i32\");\n        f.addParam(\"pCoef\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const X1  = c.getLocal(\"pR\");\n        const Y1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f2size));\n        const Z1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(2*f2size));\n\n        const ELL_0  = c.getLocal(\"pCoef\");\n        const ELL_VW = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(f2size));\n        const ELL_VV  = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(2*f2size));\n\n        const A = c.i32_const(module.alloc(f2size));\n        const B = c.i32_const(module.alloc(f2size));\n        const C = c.i32_const(module.alloc(f2size));\n        const D = c.i32_const(module.alloc(f2size));\n        const E = c.i32_const(module.alloc(f2size));\n        const F = c.i32_const(module.alloc(f2size));\n        const G = c.i32_const(module.alloc(f2size));\n        const H = c.i32_const(module.alloc(f2size));\n        const I = c.i32_const(module.alloc(f2size));\n        const J = c.i32_const(module.alloc(f2size));\n        const E2 = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // A = X1 * Y1 / 2\n            c.call(f2mPrefix + \"_mul\", Y1, c.i32_const(pTwoInv), A),\n            c.call(f2mPrefix + \"_mul\", X1, A, A),\n\n            // B = Y1^2\n            c.call(f2mPrefix + \"_square\", Y1, B),\n\n            // C = Z1^2\n            c.call(f2mPrefix + \"_square\", Z1, C),\n\n            // D = 3 * C\n            c.call(f2mPrefix + \"_add\", C, C, D),\n            c.call(f2mPrefix + \"_add\", D, C, D),\n\n            // E = twist_b * D\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pTwistCoefB), D, E),\n\n            // F = 3 * E\n            c.call(f2mPrefix + \"_add\", E, E, F),\n            c.call(f2mPrefix + \"_add\", E, F, F),\n\n            // G = (B+F)/2\n            c.call(f2mPrefix + \"_add\", B, F, G),\n            c.call(f2mPrefix + \"_mul\", G, c.i32_const(pTwoInv), G),\n\n            // H = (Y1+Z1)^2-(B+C)\n            c.call(f2mPrefix + \"_add\", B, C, AUX),\n            c.call(f2mPrefix + \"_add\", Y1, Z1, H),\n            c.call(f2mPrefix + \"_square\", H, H),\n            c.call(f2mPrefix + \"_sub\", H, AUX, H),\n\n            // I = E-B\n            c.call(f2mPrefix + \"_sub\", E, B, I),\n\n            // J = X1^2\n            c.call(f2mPrefix + \"_square\", X1, J),\n\n            // E_squared = E^2\n            c.call(f2mPrefix + \"_square\", E, E2),\n\n            // X3 (X1) = A * (B-F)\n            c.call(f2mPrefix + \"_sub\", B, F, AUX),\n            c.call(f2mPrefix + \"_mul\", A, AUX, X1),\n\n            // Y3 (Y1) = G^2 - 3*E^2\n            c.call(f2mPrefix + \"_add\", E2, E2, AUX),\n            c.call(f2mPrefix + \"_add\", E2, AUX, AUX),\n            c.call(f2mPrefix + \"_square\", G, Y1),\n            c.call(f2mPrefix + \"_sub\", Y1, AUX, Y1),\n\n            // Z3 (Z1) = B * H\n            c.call(f2mPrefix + \"_mul\", B, H, Z1),\n\n            // ell_0 = xi * I\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pAltBn128Twist), I, ELL_0),\n\n            // ell_VW = - H (later: * yP)\n            c.call(f2mPrefix + \"_neg\", H, ELL_VW),\n\n            // ell_VV = 3*J (later: * xP)\n            c.call(f2mPrefix + \"_add\", J, J, ELL_VV),\n            c.call(f2mPrefix + \"_add\", J, ELL_VV, ELL_VV),\n\n        );\n    }\n\n    function buildMulByQ() {\n        const f = module.addFunction(prefix + \"_mulByQ\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(f2size));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(f2size*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(f2size));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(f2size*2));\n\n        const MulByQX = c.i32_const(module.alloc([\n            ...utils.bigInt2BytesLE( toMontgomery(\"21575463638280843010398324269430826099269044274347216827212613867836435027261\"), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(\"10307601595873709700152284273816112264069230130616436755625194854815875713954\"), f1size ),\n        ]));\n\n        const MulByQY = c.i32_const(module.alloc([\n            ...utils.bigInt2BytesLE( toMontgomery(\"2821565182194536844548159561693502659359617185244120367078079554186484126554\"), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(\"3505843767911556378687030309984248845540243509899259641013678093033130930403\"), f1size ),\n        ]));\n\n        f.addCode(\n            // The frobeniusMap(1) in this field, is the conjugate\n            c.call(f2mPrefix + \"_conjugate\", x, x3),\n            c.call(f2mPrefix + \"_mul\", MulByQX, x3, x3),\n            c.call(f2mPrefix + \"_conjugate\", y, y3),\n            c.call(f2mPrefix + \"_mul\", MulByQY, y3, y3),\n            c.call(f2mPrefix + \"_conjugate\", z, z3),\n        );\n    }\n\n\n    function buildPrepareG2() {\n        buildMulByQ();\n        const f = module.addFunction(prefix+ \"_prepareG2\");\n        f.addParam(\"pQ\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const QX = c.getLocal(\"pQ\");\n\n        const pR = module.alloc(f2size*3);\n        const R = c.i32_const(pR);\n        const RX = c.i32_const(pR);\n        const RY = c.i32_const(pR+f2size);\n        const RZ = c.i32_const(pR+2*f2size);\n\n        const cQX = c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(0));\n        const cQY = c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size));\n\n        const pQ1 = module.alloc(f2size*3);\n        const Q1 = c.i32_const(pQ1);\n\n        const pQ2 = module.alloc(f2size*3);\n        const Q2 = c.i32_const(pQ2);\n        const Q2Y = c.i32_const(pQ2 + f2size);\n\n        f.addCode(\n            c.call(g2mPrefix + \"_normalize\", QX, cQX),  // TODO Remove if already in affine\n            c.call(f2mPrefix + \"_copy\", cQX, RX),\n            c.call(f2mPrefix + \"_copy\", cQY, RY),\n            c.call(f2mPrefix + \"_one\", RZ),\n        );\n\n        f.addCode(\n            c.setLocal(\"pCoef\", c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n                c.call(prefix + \"_prepDblStep\", R, c.getLocal(\"pCoef\")),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(prefix + \"_prepAddStep\", cQX, R, c.getLocal(\"pCoef\")),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n                    ]\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n\n        f.addCode(\n            c.call(prefix + \"_mulByQ\", cQX, Q1),\n            c.call(prefix + \"_mulByQ\", Q1, Q2)\n        );\n\n        if (isLoopNegative) {\n            f.addCode(\n                c.call(f2mPrefix + \"_neg\", RY, RY),\n            );\n        }\n\n        f.addCode(\n            c.call(f2mPrefix + \"_neg\", Q2Y, Q2Y),\n\n            c.call(prefix + \"_prepAddStep\", Q1, R, c.getLocal(\"pCoef\")),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n            c.call(prefix + \"_prepAddStep\", Q2, R, c.getLocal(\"pCoef\")),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n        );\n    }\n\n    function buildMulBy024Old() {\n        const f = module.addFunction(prefix+ \"__mulBy024Old\");\n        f.addParam(\"pEll0\", \"i32\");\n        f.addParam(\"pEllVW\", \"i32\");\n        f.addParam(\"pEllVV\", \"i32\");\n        f.addParam(\"pR\", \"i32\");            // Result in F12\n\n        const c = f.getCodeBuilder();\n\n        const x0  = c.getLocal(\"pEll0\");\n        const x2  = c.getLocal(\"pEllVV\");\n        const x4  = c.getLocal(\"pEllVW\");\n\n        const z0  = c.getLocal(\"pR\");\n\n        const pAUX12 = module.alloc(ftsize);\n        const AUX12 = c.i32_const(pAUX12);\n        const AUX12_0 = c.i32_const(pAUX12);\n        const AUX12_2 = c.i32_const(pAUX12+f2size);\n        const AUX12_4 = c.i32_const(pAUX12+f2size*2);\n        const AUX12_6 = c.i32_const(pAUX12+f2size*3);\n        const AUX12_8 = c.i32_const(pAUX12+f2size*4);\n        const AUX12_10 = c.i32_const(pAUX12+f2size*5);\n\n        f.addCode(\n\n            c.call(f2mPrefix + \"_copy\", x0, AUX12_0),\n            c.call(f2mPrefix + \"_zero\", AUX12_2),\n            c.call(f2mPrefix + \"_copy\", x2, AUX12_4),\n            c.call(f2mPrefix + \"_zero\", AUX12_6),\n            c.call(f2mPrefix + \"_copy\", x4, AUX12_8),\n            c.call(f2mPrefix + \"_zero\", AUX12_10),\n            c.call(ftmPrefix + \"_mul\", AUX12, z0, z0),\n        );\n    }\n\n    function buildMulBy024() {\n        const f = module.addFunction(prefix+ \"__mulBy024\");\n        f.addParam(\"pEll0\", \"i32\");\n        f.addParam(\"pEllVW\", \"i32\");\n        f.addParam(\"pEllVV\", \"i32\");\n        f.addParam(\"pR\", \"i32\");            // Result in F12\n\n        const c = f.getCodeBuilder();\n\n        const x0  = c.getLocal(\"pEll0\");\n        const x2  = c.getLocal(\"pEllVV\");\n        const x4  = c.getLocal(\"pEllVW\");\n\n        const z0  = c.getLocal(\"pR\");\n        const z1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(2*n8));\n        const z2  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(4*n8));\n        const z3  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(6*n8));\n        const z4  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(8*n8));\n        const z5  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(10*n8));\n\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const s0 = c.i32_const(module.alloc(f2size));\n        const T3 = c.i32_const(module.alloc(f2size));\n        const T4 = c.i32_const(module.alloc(f2size));\n        const D0 = c.i32_const(module.alloc(f2size));\n        const D2 = c.i32_const(module.alloc(f2size));\n        const D4 = c.i32_const(module.alloc(f2size));\n        const S1 = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // D0 = z0 * x0;\n            c.call(f2mPrefix + \"_mul\", z0, x0, D0),\n            // D2 = z2 * x2;\n            c.call(f2mPrefix + \"_mul\", z2, x2, D2),\n            // D4 = z4 * x4;\n            c.call(f2mPrefix + \"_mul\", z4, x4, D4),\n            // t2 = z0 + z4;\n            c.call(f2mPrefix + \"_add\", z0, z4, t2),\n            // t1 = z0 + z2;\n            c.call(f2mPrefix + \"_add\", z0, z2, t1),\n            // s0 = z1 + z3 + z5;\n            c.call(f2mPrefix + \"_add\", z1, z3, s0),\n            c.call(f2mPrefix + \"_add\", s0, z5, s0),\n\n\n            // For z.a_.a_ = z0.\n            // S1 = z1 * x2;\n            c.call(f2mPrefix + \"_mul\", z1, x2, S1),\n            // T3 = S1 + D4;\n            c.call(f2mPrefix + \"_add\", S1, D4, T3),\n            // T4 = my_Fp6::non_residue * T3 + D0;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            c.call(f2mPrefix + \"_add\", T4, D0, z0),\n            // z0 = T4;\n\n            // For z.a_.b_ = z1\n            // T3 = z5 * x4;\n            c.call(f2mPrefix + \"_mul\", z5, x4, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T3 = T3 + D2;\n            c.call(f2mPrefix + \"_add\", T3, D2, T3),\n            // T4 = my_Fp6::non_residue * T3;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            // T3 = z1 * x0;\n            c.call(f2mPrefix + \"_mul\", z1, x0, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T4 = T4 + T3;\n            c.call(f2mPrefix + \"_add\", T4, T3, z1),\n            // z1 = T4;\n\n\n\n            // For z.a_.c_ = z2\n            // t0 = x0 + x2;\n            c.call(f2mPrefix + \"_add\", x0, x2, t0),\n            // T3 = t1 * t0 - D0 - D2;\n            c.call(f2mPrefix + \"_mul\", t1, t0, T3),\n            c.call(f2mPrefix + \"_add\", D0, D2, AUX),\n            c.call(f2mPrefix + \"_sub\", T3, AUX, T3),\n            // T4 = z3 * x4;\n            c.call(f2mPrefix + \"_mul\", z3, x4, T4),\n            // S1 = S1 + T4;\n            c.call(f2mPrefix + \"_add\", S1, T4, S1),\n\n\n            // For z.b_.a_ = z3 (z3 needs z2)\n            // t0 = z2 + z4;\n            c.call(f2mPrefix + \"_add\", z2, z4, t0),\n            // T3 = T3 + T4;\n            // z2 = T3;\n            c.call(f2mPrefix + \"_add\", T3, T4, z2),\n            // t1 = x2 + x4;\n            c.call(f2mPrefix + \"_add\", x2, x4, t1),\n            // T3 = t0 * t1 - D2 - D4;\n            c.call(f2mPrefix + \"_mul\", t1, t0, T3),\n            c.call(f2mPrefix + \"_add\", D2, D4, AUX),\n            c.call(f2mPrefix + \"_sub\", T3, AUX, T3),\n            // T4 = my_Fp6::non_residue * T3;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            // T3 = z3 * x0;\n            c.call(f2mPrefix + \"_mul\", z3, x0, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T4 = T4 + T3;\n            c.call(f2mPrefix + \"_add\", T4, T3, z3),\n            // z3 = T4;\n\n            // For z.b_.b_ = z4\n            // T3 = z5 * x2;\n            c.call(f2mPrefix + \"_mul\", z5, x2, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T4 = my_Fp6::non_residue * T3;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            // t0 = x0 + x4;\n            c.call(f2mPrefix + \"_add\", x0, x4, t0),\n            // T3 = t2 * t0 - D0 - D4;\n            c.call(f2mPrefix + \"_mul\", t2, t0, T3),\n            c.call(f2mPrefix + \"_add\", D0, D4, AUX),\n            c.call(f2mPrefix + \"_sub\", T3, AUX, T3),\n            // T4 = T4 + T3;\n            c.call(f2mPrefix + \"_add\", T4, T3, z4),\n            // z4 = T4;\n\n            // For z.b_.c_ = z5.\n            // t0 = x0 + x2 + x4;\n            c.call(f2mPrefix + \"_add\", x0, x2, t0),\n            c.call(f2mPrefix + \"_add\", t0, x4, t0),\n            // T3 = s0 * t0 - S1;\n            c.call(f2mPrefix + \"_mul\", s0, t0, T3),\n            c.call(f2mPrefix + \"_sub\", T3, S1, z5),\n            // z5 = T3;\n\n        );\n    }\n\n\n    function buildMillerLoop() {\n        const f = module.addFunction(prefix+ \"_millerLoop\");\n        f.addParam(\"ppreP\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const preP_PX = c.getLocal(\"ppreP\");\n        const preP_PY = c.i32_add(c.getLocal(\"ppreP\"), c.i32_const(f1size));\n\n        const ELL_0  = c.getLocal(\"pCoef\");\n        const ELL_VW = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(f2size));\n        const ELL_VV  = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(2*f2size));\n\n\n        const pVW = module.alloc(f2size);\n        const VW = c.i32_const(pVW);\n        const pVV = module.alloc(f2size);\n        const VV = c.i32_const(pVV);\n\n        const F = c.getLocal(\"r\");\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_one\", F),\n\n            c.setLocal(\"pCoef\", c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n\n                c.call(ftmPrefix + \"_square\", F, F),\n\n                c.call(f2mPrefix + \"_mul1\", ELL_VW,preP_PY, VW),\n                c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n                c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(f2mPrefix + \"_mul1\", ELL_VW, preP_PY, VW),\n                        ...c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n\n                        ...c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                    ]\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n\n        );\n\n        if (isLoopNegative) {\n            f.addCode(\n                c.call(ftmPrefix + \"_inverse\", F, F),\n            );\n        }\n\n        f.addCode(\n            c.call(f2mPrefix + \"_mul1\", ELL_VW, preP_PY, VW),\n            c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n            c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n            c.call(f2mPrefix + \"_mul1\", ELL_VW, preP_PY, VW),\n            c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n            c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n        );\n\n    }\n\n\n    function buildFrobeniusMap(n) {\n        const F12 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [8376118865763821496583973867626364092589906065868298776909617916018768340080n, 16469823323077808223889137241176536799009286646108169935659301613961712198316n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556617n, 0n],\n                [11697423496358154304825782922584725312912383441159505038794027105778954184319n, 303847389135065887422783454877609941456349188919719272345083954437860409601n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],\n                [3321304630594332808241809054958361220322477375291206261884409189760185844239n, 5722266937896532885780051958958348231143373700109372999374820235121374419868n],\n                [21888242871839275222246405745257275088696311157297823662689037894645226208582n, 0n],\n                [13512124006075453725662431877630910996106405091429524885779419978626457868503n, 5418419548761466998357268504080738289687024511189653727029736280683514010267n],\n                [2203960485148121921418603742825762020974279258880205651966n, 0n],\n                [10190819375481120917420622822672549775783927716138318623895010788866272024264n, 21584395482704209334823622290379665147239961968378104390343953940207365798982n],\n                [2203960485148121921418603742825762020974279258880205651967n, 0n],\n                [18566938241244942414004596690298913868373833782006617400804628704885040364344n, 16165975933942742336466353786298926857552937457188450663314217659523851788715n],\n            ]\n        ];\n\n        const F6 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [21575463638280843010398324269430826099269044274347216827212613867836435027261n, 10307601595873709700152284273816112264069230130616436755625194854815875713954n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],\n                [3772000881919853776433695186713858239009073593817195771773381919316419345261n, 2236595495967245188281701248203181795121068902605861227855261137820944008926n],\n                [2203960485148121921418603742825762020974279258880205651966n, 0n],\n                [18429021223477853657660792034369865839114504446431234726392080002137598044644n, 9344045779998320333812420223237981029506012124075525679208581902008406485703n],\n            ],\n            [\n                [1n, 0n],\n                [2581911344467009335267311115468803099551665605076196740867805258568234346338n, 19937756971775647987995932169929341994314640652964949448313374472400716661030n],\n                [2203960485148121921418603742825762020974279258880205651966n, 0n],\n                [5324479202449903542726783395506214481928257762400643279780343368557297135718n, 16208900380737693084919495127334387981393726419856888799917914180988844123039n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],\n                [13981852324922362344252311234282257507216387789820983642040889267519694726527n, 7629828391165209371577384193250820201684255241773809077146787135900891633097n],\n            ]\n        ];\n\n        const f = module.addFunction(prefix+ \"__frobeniusMap\"+n);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<6; i++) {\n            const X = (i==0) ? c.getLocal(\"x\") : c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size));\n            const Xc0 = X;\n            const Xc1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size + f1size));\n            const R = (i==0) ? c.getLocal(\"r\") : c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size));\n            const Rc0 = R;\n            const Rc1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size + f1size));\n            const coef = mul2(F12[Math.floor(i/3)][n%12] , F6[i%3][n%6]);\n            const pCoef = module.alloc([\n                ...utils.bigInt2BytesLE(toMontgomery(coef[0]), 32),\n                ...utils.bigInt2BytesLE(toMontgomery(coef[1]), 32),\n            ]);\n            if (n%2 == 1) {\n                f.addCode(\n                    c.call(f1mPrefix + \"_copy\", Xc0, Rc0),\n                    c.call(f1mPrefix + \"_neg\", Xc1, Rc1),\n                    c.call(f2mPrefix + \"_mul\", R, c.i32_const(pCoef), R),\n                );\n            } else {\n                f.addCode(c.call(f2mPrefix + \"_mul\", X, c.i32_const(pCoef), R));\n            }\n        }\n\n        function mul2(a, b) {\n            const ac0 = BigInt(a[0]);\n            const ac1 = BigInt(a[1]);\n            const bc0 = BigInt(b[0]);\n            const bc1 = BigInt(b[1]);\n            const res = [\n                (ac0 * bc0 - (  ac1 * bc1)  ) % q,\n                (ac0 * bc1 + (  ac1 * bc0)  ) % q,\n            ];\n            if (isNegative(res[0])) res[0] = res[0] + q;\n            return res;\n        }\n\n    }\n\n\n\n    function buildFinalExponentiationFirstChunk() {\n\n        const f = module.addFunction(prefix+ \"__finalExponentiationFirstChunk\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const eltC0 = elt;\n        const eltC1 = c.i32_add(elt, c.i32_const(n8*6));\n        const r = c.getLocal(\"r\");\n        const pA = module.alloc(ftsize);\n        const A = c.i32_const(pA);\n        const Ac0 = A;\n        const Ac1 = c.i32_const(pA + n8*6);\n        const B = c.i32_const(module.alloc(ftsize));\n        const C = c.i32_const(module.alloc(ftsize));\n        const D = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n            // const alt_bn128_Fq12 A = alt_bn128_Fq12(elt.c0,-elt.c1);\n            c.call(f6mPrefix + \"_copy\", eltC0, Ac0),\n            c.call(f6mPrefix + \"_neg\", eltC1, Ac1),\n\n            // const alt_bn128_Fq12 B = elt.inverse();\n            c.call(ftmPrefix + \"_inverse\", elt, B),\n\n            // const alt_bn128_Fq12 C = A * B;\n            c.call(ftmPrefix + \"_mul\", A, B, C),\n            // const alt_bn128_Fq12 D = C.Frobenius_map(2);\n            c.call(prefix + \"__frobeniusMap2\", C, D),\n            // const alt_bn128_Fq12 result = D * C;\n            c.call(ftmPrefix + \"_mul\", C, D, r),\n        );\n    }\n\n    function buildCyclotomicSquare() {\n        const f = module.addFunction(prefix+ \"__cyclotomicSquare\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x4 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f2size));\n        const x3 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f2size));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(3*f2size));\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(4*f2size));\n        const x5 = c.i32_add(c.getLocal(\"x\"), c.i32_const(5*f2size));\n\n        const r0 = c.getLocal(\"r\");\n        const r4 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f2size));\n        const r3 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f2size));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(3*f2size));\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*f2size));\n        const r5 = c.i32_add(c.getLocal(\"r\"), c.i32_const(5*f2size));\n\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t3 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n        const tmp = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n\n        f.addCode(\n            //    // t0 + t1*y = (z0 + z1*y)^2 = a^2\n            //    tmp = z0 * z1;\n            //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;\n            //    t1 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x0, x1, tmp),\n            c.call(f2mPrefix + \"_mul\", x1, c.i32_const(pNonResidueF6), t0),\n            c.call(f2mPrefix + \"_add\", x0, t0, t0),\n            c.call(f2mPrefix + \"_add\", x0, x1, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t0, t0),\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t0, AUX, t0),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t1),\n\n            //  // t2 + t3*y = (z2 + z3*y)^2 = b^2\n            //  tmp = z2 * z3;\n            //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;\n            //  t3 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x2, x3, tmp),\n            c.call(f2mPrefix + \"_mul\", x3, c.i32_const(pNonResidueF6), t2),\n            c.call(f2mPrefix + \"_add\", x2, t2, t2),\n            c.call(f2mPrefix + \"_add\", x2, x3, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t2, t2),\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t2, AUX, t2),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t3),\n\n            //  // t4 + t5*y = (z4 + z5*y)^2 = c^2\n            //  tmp = z4 * z5;\n            //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;\n            //  t5 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x4, x5, tmp),\n            c.call(f2mPrefix + \"_mul\", x5, c.i32_const(pNonResidueF6), t4),\n            c.call(f2mPrefix + \"_add\", x4, t4, t4),\n            c.call(f2mPrefix + \"_add\", x4, x5, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t4, t4),\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t4, AUX, t4),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t5),\n\n            // For A\n            // z0 = 3 * t0 - 2 * z0\n            c.call(f2mPrefix + \"_sub\", t0, x0, r0),\n            c.call(f2mPrefix + \"_add\", r0, r0, r0),\n            c.call(f2mPrefix + \"_add\", t0, r0, r0),\n            // z1 = 3 * t1 + 2 * z1\n            c.call(f2mPrefix + \"_add\", t1, x1, r1),\n            c.call(f2mPrefix + \"_add\", r1, r1, r1),\n            c.call(f2mPrefix + \"_add\", t1, r1, r1),\n\n            // For B\n            // z2 = 3 * (xi * t5) + 2 * z2\n            c.call(f2mPrefix + \"_mul\", t5, c.i32_const(pAltBn128Twist), AUX),\n            c.call(f2mPrefix + \"_add\", AUX, x2, r2),\n            c.call(f2mPrefix + \"_add\", r2, r2, r2),\n            c.call(f2mPrefix + \"_add\", AUX, r2, r2),\n            // z3 = 3 * t4 - 2 * z3\n            c.call(f2mPrefix + \"_sub\", t4, x3, r3),\n            c.call(f2mPrefix + \"_add\", r3, r3, r3),\n            c.call(f2mPrefix + \"_add\", t4, r3, r3),\n\n            // For C\n            // z4 = 3 * t2 - 2 * z4\n            c.call(f2mPrefix + \"_sub\", t2, x4, r4),\n            c.call(f2mPrefix + \"_add\", r4, r4, r4),\n            c.call(f2mPrefix + \"_add\", t2, r4, r4),\n            // z5 = 3 * t3 + 2 * z5\n            c.call(f2mPrefix + \"_add\", t3, x5, r5),\n            c.call(f2mPrefix + \"_add\", r5, r5, r5),\n            c.call(f2mPrefix + \"_add\", t3, r5, r5),\n\n        );\n    }\n\n\n    function buildCyclotomicExp(exponent, fnName) {\n        const exponentNafBytes = naf(exponent).map( (b) => (b==-1 ? 0xFF: b) );\n        const pExponentNafBytes = module.alloc(exponentNafBytes);\n\n        const f = module.addFunction(prefix+ \"__cyclotomicExp_\"+fnName);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"bit\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"x\");\n\n        const res = c.getLocal(\"r\");\n\n        const inverse = c.i32_const(module.alloc(ftsize));\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_conjugate\", x, inverse),\n            c.call(ftmPrefix + \"_one\", res),\n\n            c.if(\n                c.teeLocal(\"bit\", c.i32_load8_s(c.i32_const(exponentNafBytes.length-1), pExponentNafBytes)),\n                c.if(\n                    c.i32_eq(\n                        c.getLocal(\"bit\"),\n                        c.i32_const(1)\n                    ),\n                    c.call(ftmPrefix + \"_mul\", res, x, res),\n                    c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                )\n            ),\n\n            c.setLocal(\"i\", c.i32_const(exponentNafBytes.length-2)),\n            c.block(c.loop(\n                c.call(prefix + \"__cyclotomicSquare\", res, res),\n                c.if(\n                    c.teeLocal(\"bit\", c.i32_load8_s(c.getLocal(\"i\"), pExponentNafBytes)),\n                    c.if(\n                        c.i32_eq(\n                            c.getLocal(\"bit\"),\n                            c.i32_const(1)\n                        ),\n                        c.call(ftmPrefix + \"_mul\", res, x, res),\n                        c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                    )\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n\n    function buildFinalExponentiationLastChunk() {\n        buildCyclotomicSquare();\n        buildCyclotomicExp(finalExpZ, \"w0\");\n\n        const f = module.addFunction(prefix+ \"__finalExponentiationLastChunk\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const result = c.getLocal(\"r\");\n        const A = c.i32_const(module.alloc(ftsize));\n        const B = c.i32_const(module.alloc(ftsize));\n        const C = c.i32_const(module.alloc(ftsize));\n        const D = c.i32_const(module.alloc(ftsize));\n        const E = c.i32_const(module.alloc(ftsize));\n        const F = c.i32_const(module.alloc(ftsize));\n        const G = c.i32_const(module.alloc(ftsize));\n        const H = c.i32_const(module.alloc(ftsize));\n        const I = c.i32_const(module.alloc(ftsize));\n        const J = c.i32_const(module.alloc(ftsize));\n        const K = c.i32_const(module.alloc(ftsize));\n        const L = c.i32_const(module.alloc(ftsize));\n        const M = c.i32_const(module.alloc(ftsize));\n        const N = c.i32_const(module.alloc(ftsize));\n        const O = c.i32_const(module.alloc(ftsize));\n        const P = c.i32_const(module.alloc(ftsize));\n        const Q = c.i32_const(module.alloc(ftsize));\n        const R = c.i32_const(module.alloc(ftsize));\n        const S = c.i32_const(module.alloc(ftsize));\n        const T = c.i32_const(module.alloc(ftsize));\n        const U = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n\n\n            // A = exp_by_neg_z(elt)  // = elt^(-z)\n            c.call(prefix + \"__cyclotomicExp_w0\", elt, A),\n            finalExpIsNegative ? [] : c.call(ftmPrefix + \"_conjugate\", A, A),\n            // B = A^2                // = elt^(-2*z)\n            c.call(prefix + \"__cyclotomicSquare\", A, B),\n            // C = B^2                // = elt^(-4*z)\n            c.call(prefix + \"__cyclotomicSquare\", B, C),\n            // D = C * B              // = elt^(-6*z)\n            c.call(ftmPrefix + \"_mul\", C, B, D),\n            // E = exp_by_neg_z(D)    // = elt^(6*z^2)\n            c.call(prefix + \"__cyclotomicExp_w0\", D, E),\n            finalExpIsNegative ? [] : c.call(ftmPrefix + \"_conjugate\", E, E),\n            // F = E^2                // = elt^(12*z^2)\n            c.call(prefix + \"__cyclotomicSquare\", E, F),\n            // G = epx_by_neg_z(F)    // = elt^(-12*z^3)\n            c.call(prefix + \"__cyclotomicExp_w0\", F, G),\n            finalExpIsNegative ? [] : c.call(ftmPrefix + \"_conjugate\", G, G),\n            // H = conj(D)            // = elt^(6*z)\n            c.call(ftmPrefix + \"_conjugate\", D, H),\n            // I = conj(G)            // = elt^(12*z^3)\n            c.call(ftmPrefix + \"_conjugate\", G, I),\n            // J = I * E              // = elt^(12*z^3 + 6*z^2)\n            c.call(ftmPrefix + \"_mul\", I, E, J),\n            // K = J * H              // = elt^(12*z^3 + 6*z^2 + 6*z)\n            c.call(ftmPrefix + \"_mul\", J, H, K),\n            // L = K * B              // = elt^(12*z^3 + 6*z^2 + 4*z)\n            c.call(ftmPrefix + \"_mul\", K, B, L),\n            // M = K * E              // = elt^(12*z^3 + 12*z^2 + 6*z)\n            c.call(ftmPrefix + \"_mul\", K, E, M),\n\n            // N = M * elt            // = elt^(12*z^3 + 12*z^2 + 6*z + 1)\n            c.call(ftmPrefix + \"_mul\", M, elt, N),\n\n            // O = L.Frobenius_map(1) // = elt^(q*(12*z^3 + 6*z^2 + 4*z))\n            c.call(prefix + \"__frobeniusMap1\", L, O),\n            // P = O * N              // = elt^(q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))\n            c.call(ftmPrefix + \"_mul\", O, N, P),\n            // Q = K.Frobenius_map(2) // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z))\n            c.call(prefix + \"__frobeniusMap2\", K, Q),\n            // R = Q * P              // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))\n            c.call(ftmPrefix + \"_mul\", Q, P, R),\n            // S = conj(elt)          // = elt^(-1)\n            c.call(ftmPrefix + \"_conjugate\", elt, S),\n            // T = S * L              // = elt^(12*z^3 + 6*z^2 + 4*z - 1)\n            c.call(ftmPrefix + \"_mul\", S, L, T),\n            // U = T.Frobenius_map(3) // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1))\n            c.call(prefix + \"__frobeniusMap3\", T, U),\n            // V = U * R              // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1) + q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))\n            c.call(ftmPrefix + \"_mul\", U, R, result),\n            // result = V\n        );\n    }\n\n\n    function buildFinalExponentiation() {\n        buildFinalExponentiationFirstChunk();\n        buildFinalExponentiationLastChunk();\n        const f = module.addFunction(prefix+ \"_finalExponentiation\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const result = c.getLocal(\"r\");\n        const eltToFirstChunk = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n            c.call(prefix + \"__finalExponentiationFirstChunk\", elt, eltToFirstChunk ),\n            c.call(prefix + \"__finalExponentiationLastChunk\", eltToFirstChunk, result )\n        );\n    }\n\n\n    function buildFinalExponentiationOld() {\n        const f = module.addFunction(prefix+ \"_finalExponentiationOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const exponent = 552484233613224096312617126783173147097382103762957654188882734314196910839907541213974502761540629817009608548654680343627701153829446747810907373256841551006201639677726139946029199968412598804882391702273019083653272047566316584365559776493027495458238373902875937659943504873220554161550525926302303331747463515644711876653177129578303191095900909191624817826566688241804408081892785725967931714097716709526092261278071952560171111444072049229123565057483750161460024353346284167282452756217662335528813519139808291170539072125381230815729071544861602750936964829313608137325426383735122175229541155376346436093930287402089517426973178917569713384748081827255472576937471496195752727188261435633271238710131736096299798168852925540549342330775279877006784354801422249722573783561685179618816480037695005515426162362431072245638324744480n;\n\n        const pExponent = module.alloc(utils.bigInt2BytesLE( exponent, 352 ));\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(ftmPrefix + \"_exp\", c.getLocal(\"x\"), c.i32_const(pExponent), c.i32_const(352), c.getLocal(\"r\")),\n        );\n    }\n\n\n\n\n    const pPreP = module.alloc(prePSize);\n    const pPreQ = module.alloc(preQSize);\n\n    function buildPairingEquation(nPairings) {\n\n        const f = module.addFunction(prefix+ \"_pairingEq\"+nPairings);\n        for (let i=0; i<nPairings; i++) {\n            f.addParam(\"p_\"+i, \"i32\");\n            f.addParam(\"q_\"+i, \"i32\");\n        }\n        f.addParam(\"c\", \"i32\");\n        f.setReturnType(\"i32\");\n\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n        const auxT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(ftmPrefix + \"_one\", resT ));\n\n        for (let i=0; i<nPairings; i++) {\n\n            f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p_\"+i), c.i32_const(pPreP) ));\n            f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q_\"+i), c.i32_const(pPreQ) ));\n            f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), auxT ));\n\n            f.addCode(c.call(ftmPrefix + \"_mul\", resT, auxT, resT ));\n        }\n\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, resT ));\n\n        f.addCode(c.call(ftmPrefix + \"_eq\", resT, c.getLocal(\"c\")));\n    }\n\n\n    function buildPairing() {\n\n        const f = module.addFunction(prefix+ \"_pairing\");\n        f.addParam(\"p\", \"i32\");\n        f.addParam(\"q\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p\"), c.i32_const(pPreP) ));\n        f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q\"), c.i32_const(pPreQ) ));\n        f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), resT ));\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, c.getLocal(\"r\") ));\n    }\n\n\n    buildPrepAddStep();\n    buildPrepDoubleStep();\n\n    buildPrepareG1();\n    buildPrepareG2();\n\n    buildMulBy024();\n    buildMulBy024Old();\n    buildMillerLoop();\n\n\n    for (let i=0; i<10; i++) {\n        buildFrobeniusMap(i);\n        module.exportFunction(prefix + \"__frobeniusMap\"+i);\n    }\n\n    buildFinalExponentiationOld();\n    buildFinalExponentiation();\n\n    for (let i=1; i<=5; i++) {\n        buildPairingEquation(i);\n        module.exportFunction(prefix + \"_pairingEq\"+i);\n    }\n\n    buildPairing();\n\n    module.exportFunction(prefix + \"_pairing\");\n\n    module.exportFunction(prefix + \"_prepareG1\");\n    module.exportFunction(prefix + \"_prepareG2\");\n    module.exportFunction(prefix + \"_millerLoop\");\n    module.exportFunction(prefix + \"_finalExponentiation\");\n    module.exportFunction(prefix + \"_finalExponentiationOld\");\n    module.exportFunction(prefix + \"__mulBy024\");\n    module.exportFunction(prefix + \"__mulBy024Old\");\n    module.exportFunction(prefix + \"__cyclotomicSquare\");\n    module.exportFunction(prefix + \"__cyclotomicExp_w0\");\n\n    // console.log(module.functionIdxByName);\n\n};\n\n", "const utils = require(\"../utils\");\n\nconst buildF1m =require(\"../build_f1m.js\");\nconst buildF1 =require(\"../build_f1.js\");\nconst buildF2m =require(\"../build_f2m.js\");\nconst buildF3m =require(\"../build_f3m.js\");\nconst buildCurve =require(\"../build_curve_jacobian_a0.js\");\nconst buildFFT = require(\"../build_fft\");\nconst buildPol = require(\"../build_pol\");\nconst buildQAP = require(\"../build_qap\");\nconst buildApplyKey = require(\"../build_applykey\");\nconst { bitLength, isOdd, isNegative } = require(\"../bigint.js\");\n\n// Definition here: https://electriccoin.co/blog/new-snark-curve/\n\nmodule.exports = function buildBLS12381(module, _prefix) {\n\n    const prefix = _prefix || \"bls12381\";\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const q = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    const r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;\n\n    const n64q = Math.floor((bitLength(q - 1n) - 1)/64) +1;\n    const n8q = n64q*8;\n    const f1size = n8q;\n    const f2size = f1size * 2;\n    const ftsize = f1size * 12;\n\n    const n64r = Math.floor((bitLength(r - 1n) - 1)/64) +1;\n    const n8r = n64r*8;\n    const frsize = n8r;\n\n\n    const pr = module.alloc(utils.bigInt2BytesLE( r, frsize ));\n\n    const f1mPrefix = buildF1m(module, q, \"f1m\", \"intq\");\n    buildF1(module, r, \"fr\", \"frm\", \"intr\");\n    const pG1b = module.alloc(utils.bigInt2BytesLE( toMontgomery(4n), f1size ));\n    const g1mPrefix = buildCurve(module, \"g1m\", \"f1m\", pG1b);\n\n    buildFFT(module, \"frm\", \"frm\", \"frm\", \"frm_mul\");\n\n    buildPol(module, \"pol\", \"frm\");\n    buildQAP(module, \"qap\", \"frm\");\n\n    const f2mPrefix = buildF2m(module, \"f1m_neg\", \"f2m\", \"f1m\");\n    const pG2b = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(4n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(4n), f1size )\n    ]);\n    const g2mPrefix = buildCurve(module, \"g2m\", \"f2m\", pG2b);\n\n\n    function buildGTimesFr(fnName, opMul) {\n        const f = module.addFunction(fnName);\n        f.addParam(\"pG\", \"i32\");\n        f.addParam(\"pFr\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8r));\n\n        f.addCode(\n            c.call(\"frm_fromMontgomery\", c.getLocal(\"pFr\"), AUX),\n            c.call(\n                opMul,\n                c.getLocal(\"pG\"),\n                AUX,\n                c.i32_const(n8r),\n                c.getLocal(\"pr\")\n            )\n        );\n\n        module.exportFunction(fnName);\n    }\n    buildGTimesFr(\"g1m_timesFr\", \"g1m_timesScalar\");\n    buildFFT(module, \"g1m\", \"g1m\", \"frm\", \"g1m_timesFr\");\n\n    buildGTimesFr(\"g2m_timesFr\", \"g2m_timesScalar\");\n    buildFFT(module, \"g2m\", \"g2m\", \"frm\", \"g2m_timesFr\");\n\n    buildGTimesFr(\"g1m_timesFrAffine\", \"g1m_timesScalarAffine\");\n    buildGTimesFr(\"g2m_timesFrAffine\", \"g2m_timesScalarAffine\");\n\n    buildApplyKey(module, \"frm_batchApplyKey\", \"fmr\", \"frm\", n8r, n8r, n8r, \"frm_mul\");\n    buildApplyKey(module, \"g1m_batchApplyKey\", \"g1m\", \"frm\", n8q*3, n8q*3, n8r, \"g1m_timesFr\");\n    buildApplyKey(module, \"g1m_batchApplyKeyMixed\", \"g1m\", \"frm\", n8q*2, n8q*3, n8r, \"g1m_timesFrAffine\");\n    buildApplyKey(module, \"g2m_batchApplyKey\", \"g2m\", \"frm\", n8q*2*3, n8q*3*2, n8r, \"g2m_timesFr\");\n    buildApplyKey(module, \"g2m_batchApplyKeyMixed\", \"g2m\", \"frm\", n8q*2*2, n8q*3*2, n8r, \"g2m_timesFrAffine\");\n\n\n    function toMontgomery(a) {\n        return BigInt(a) * (1n << BigInt(f1size*8)) % q;\n    }\n\n    const G1gen = [\n        3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507n,\n        1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569n,\n        1n\n    ];\n\n    const pG1gen = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[2]), f1size ),\n        ]\n    );\n\n    const G1zero = [\n        0n,\n        1n,\n        0n\n    ];\n\n    const pG1zero = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[2]), f1size )\n        ]\n    );\n\n    const G2gen = [\n        [\n            352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160n,\n            3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758n,\n        ],[\n            1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905n,\n            927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582n,\n        ],[\n            1n,\n            0n,\n        ]\n    ];\n\n    const pG2gen = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[0][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[0][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[1][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[1][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[2][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[2][1]), f1size ),\n        ]\n    );\n\n    const G2zero = [\n        [\n            0n,\n            0n,\n        ],[\n            1n,\n            0n,\n        ],[\n            0n,\n            0n,\n        ]\n    ];\n\n    const pG2zero = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[0][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[0][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[1][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[1][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[2][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[2][1]), f1size ),\n        ]\n    );\n\n    const pOneT = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(1n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n    ]);\n\n    const pBls12381Twist =  module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(1n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(1n), f1size ),\n    ]);\n\n    function build_mulNR2() {\n        const f = module.addFunction(f2mPrefix + \"_mulNR\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0c = c.i32_const(module.alloc(f1size));\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1size));\n        const r0 = c.getLocal(\"pr\");\n        const r1 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(f1size));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, x0c),\n            c.call(f1mPrefix+\"_sub\", x0, x1, r0),\n            c.call(f1mPrefix+\"_add\", x0c, x1, r1),\n        );\n    }\n    build_mulNR2();\n\n    const f6mPrefix = buildF3m(module, f2mPrefix+\"_mulNR\", \"f6m\", \"f2m\");\n\n    function build_mulNR6() {\n        const f = module.addFunction(f6mPrefix + \"_mulNR\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const c0copy = c.i32_const(module.alloc(f1size*2));\n\n        f.addCode(\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.getLocal(\"x\"),\n                c0copy\n            ),\n            c.call(\n                f2mPrefix + \"_mulNR\",\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8q*4)),\n                c.getLocal(\"pr\")\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8q*2)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8q*4)),\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c0copy,\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8q*2)),\n            ),\n        );\n    }\n    build_mulNR6();\n\n    const ftmPrefix = buildF2m(module, f6mPrefix+\"_mulNR\", \"ftm\", f6mPrefix);\n\n    const ateLoopCount = 0xd201000000010000n;\n    const ateLoopBitBytes = bits(ateLoopCount);\n    const pAteLoopBitBytes = module.alloc(ateLoopBitBytes);\n    const isLoopNegative = true;\n\n    const ateCoefSize = 3 * f2size;\n    const ateNDblCoefs = ateLoopBitBytes.length-1;\n    const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) =>  acc + ( b!=0 ? 1 : 0)   ,0);\n    const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;\n    const prePSize = 3*2*n8q;\n    const preQSize = 3*n8q*2 + ateNCoefs*ateCoefSize;\n    const finalExpIsNegative = true;\n\n    const finalExpZ = 15132376222941642752n;\n\n\n    module.modules[prefix] = {\n        n64q: n64q,\n        n64r: n64r,\n        n8q: n8q,\n        n8r: n8r,\n        pG1gen: pG1gen,\n        pG1zero: pG1zero,\n        pG1b: pG1b,\n        pG2gen: pG2gen,\n        pG2zero: pG2zero,\n        pG2b: pG2b,\n        pq: module.modules[\"f1m\"].pq,\n        pr: pr,\n        pOneT: pOneT,\n        r: r,\n        q: q,\n        prePSize: prePSize,\n        preQSize: preQSize\n    };\n\n\n    function naf(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd(E)) {\n                const z = 2 - Number(E % 4n);\n                res.push( z );\n                E = E - BigInt(z);\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function bits(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd(E)) {\n                res.push( 1 );\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function buildPrepareG1() {\n        const f = module.addFunction(prefix+ \"_prepareG1\");\n        f.addParam(\"pP\", \"i32\");\n        f.addParam(\"ppreP\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(g1mPrefix + \"_normalize\", c.getLocal(\"pP\"), c.getLocal(\"ppreP\")),  // TODO Remove if already in affine\n        );\n    }\n\n\n\n    function buildPrepDoubleStep() {\n        const f = module.addFunction(prefix+ \"_prepDblStep\");\n        f.addParam(\"R\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Rx  = c.getLocal(\"R\");\n        const Ry  = c.i32_add(c.getLocal(\"R\"), c.i32_const(2*n8q));\n        const Rz  = c.i32_add(c.getLocal(\"R\"), c.i32_const(4*n8q));\n\n        const t0  = c.getLocal(\"r\");\n        const t3  = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*n8q));\n        const t6  = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*n8q));\n\n\n        const zsquared = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // tmp0 = r.x.square();\n            c.call(f2mPrefix + \"_square\", Rx, t0),\n\n            // tmp1 = r.y.square();\n            c.call(f2mPrefix + \"_square\", Ry, t1),\n\n            // tmp2 = tmp1.square();\n            c.call(f2mPrefix + \"_square\", t1, t2),\n\n            // tmp3 = (tmp1 + r.x).square() - tmp0 - tmp2;\n            c.call(f2mPrefix + \"_add\", t1, Rx, t3),\n            c.call(f2mPrefix + \"_square\", t3, t3),\n            c.call(f2mPrefix + \"_sub\", t3, t0, t3),\n            c.call(f2mPrefix + \"_sub\", t3, t2, t3),\n\n            // tmp3 = tmp3 + tmp3;\n            c.call(f2mPrefix + \"_add\", t3, t3, t3),\n\n            // tmp4 = tmp0 + tmp0 + tmp0;\n            c.call(f2mPrefix + \"_add\", t0, t0, t4),\n            c.call(f2mPrefix + \"_add\", t4, t0, t4),\n\n            // tmp6 = r.x + tmp4;\n            c.call(f2mPrefix + \"_add\", Rx, t4, t6),\n\n            // tmp5 = tmp4.square();\n            c.call(f2mPrefix + \"_square\", t4, t5),\n\n            // zsquared = r.z.square();\n            c.call(f2mPrefix + \"_square\", Rz, zsquared),\n\n            // r.x = tmp5 - tmp3 - tmp3;\n            c.call(f2mPrefix + \"_sub\", t5, t3, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t3, Rx),\n\n            // r.z = (r.z + r.y).square() - tmp1 - zsquared;\n            c.call(f2mPrefix + \"_add\", Rz, Ry, Rz),\n            c.call(f2mPrefix + \"_square\", Rz, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, t1, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, zsquared, Rz),\n\n            // r.y = (tmp3 - r.x) * tmp4;\n            c.call(f2mPrefix + \"_sub\", t3, Rx, Ry),\n            c.call(f2mPrefix + \"_mul\", Ry, t4, Ry),\n\n            // tmp2 = tmp2 + tmp2;\n            c.call(f2mPrefix + \"_add\", t2, t2, t2),\n\n            // tmp2 = tmp2 + tmp2;\n            c.call(f2mPrefix + \"_add\", t2, t2, t2),\n\n            // tmp2 = tmp2 + tmp2;\n            c.call(f2mPrefix + \"_add\", t2, t2, t2),\n\n            // r.y -= tmp2;\n            c.call(f2mPrefix + \"_sub\", Ry, t2, Ry),\n\n            // tmp3 = tmp4 * zsquared;\n            c.call(f2mPrefix + \"_mul\", t4, zsquared, t3),\n\n            // tmp3 = tmp3 + tmp3;\n            c.call(f2mPrefix + \"_add\", t3, t3, t3),\n\n            // tmp3 = -tmp3;\n            c.call(f2mPrefix + \"_neg\", t3, t3),\n\n            // tmp6 = tmp6.square() - tmp0 - tmp5;\n            c.call(f2mPrefix + \"_square\", t6, t6),\n            c.call(f2mPrefix + \"_sub\", t6, t0, t6),\n            c.call(f2mPrefix + \"_sub\", t6, t5, t6),\n\n            // tmp1 = tmp1 + tmp1;\n            c.call(f2mPrefix + \"_add\", t1, t1, t1),\n\n            // tmp1 = tmp1 + tmp1;\n            c.call(f2mPrefix + \"_add\", t1, t1, t1),\n\n            // tmp6 = tmp6 - tmp1;\n            c.call(f2mPrefix + \"_sub\", t6, t1, t6),\n\n            // tmp0 = r.z * zsquared;\n            c.call(f2mPrefix + \"_mul\", Rz, zsquared, t0),\n\n            // tmp0 = tmp0 + tmp0;\n            c.call(f2mPrefix + \"_add\", t0, t0, t0),\n\n        );\n    }\n\n    function buildPrepAddStep() {\n        const f = module.addFunction(prefix+ \"_prepAddStep\");\n        f.addParam(\"R\", \"i32\");\n        f.addParam(\"Q\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Rx  = c.getLocal(\"R\");\n        const Ry  = c.i32_add(c.getLocal(\"R\"), c.i32_const(2*n8q));\n        const Rz  = c.i32_add(c.getLocal(\"R\"), c.i32_const(4*n8q));\n\n        const Qx  = c.getLocal(\"Q\");\n        const Qy  = c.i32_add(c.getLocal(\"Q\"), c.i32_const(2*n8q));\n\n        const t10  = c.getLocal(\"r\");\n        const t1  = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*n8q));\n        const t9  = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*n8q));\n\n        const zsquared = c.i32_const(module.alloc(f2size));\n        const ysquared = c.i32_const(module.alloc(f2size));\n        const ztsquared = c.i32_const(module.alloc(f2size));\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t3 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n        const t6 = c.i32_const(module.alloc(f2size));\n        const t7 = c.i32_const(module.alloc(f2size));\n        const t8 = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // zsquared = r.z.square();\n            c.call(f2mPrefix + \"_square\", Rz, zsquared),\n\n            // ysquared = q.y.square();\n            c.call(f2mPrefix + \"_square\", Qy, ysquared),\n\n            // t0 = zsquared * q.x;\n            c.call(f2mPrefix + \"_mul\", zsquared, Qx, t0),\n\n            // t1 = ((q.y + r.z).square() - ysquared - zsquared) * zsquared;\n            c.call(f2mPrefix + \"_add\", Qy, Rz, t1),\n            c.call(f2mPrefix + \"_square\", t1, t1),\n            c.call(f2mPrefix + \"_sub\", t1, ysquared, t1),\n            c.call(f2mPrefix + \"_sub\", t1, zsquared, t1),\n            c.call(f2mPrefix + \"_mul\", t1, zsquared, t1),\n\n            // t2 = t0 - r.x;\n            c.call(f2mPrefix + \"_sub\", t0, Rx, t2),\n\n            // t3 = t2.square();\n            c.call(f2mPrefix + \"_square\", t2, t3),\n\n            // t4 = t3 + t3;\n            c.call(f2mPrefix + \"_add\", t3, t3, t4),\n\n            // t4 = t4 + t4;\n            c.call(f2mPrefix + \"_add\", t4, t4, t4),\n\n            // t5 = t4 * t2;\n            c.call(f2mPrefix + \"_mul\", t4, t2, t5),\n\n            // t6 = t1 - r.y - r.y;\n            c.call(f2mPrefix + \"_sub\", t1, Ry, t6),\n            c.call(f2mPrefix + \"_sub\", t6, Ry, t6),\n\n            // t9 = t6 * q.x;\n            c.call(f2mPrefix + \"_mul\", t6, Qx, t9),\n\n            // t7 = t4 * r.x;\n            c.call(f2mPrefix + \"_mul\", t4, Rx, t7),\n\n            // r.x = t6.square() - t5 - t7 - t7;\n            c.call(f2mPrefix + \"_square\", t6, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t5, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t7, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t7, Rx),\n\n            // r.z = (r.z + t2).square() - zsquared - t3;\n            c.call(f2mPrefix + \"_add\", Rz, t2, Rz),\n            c.call(f2mPrefix + \"_square\", Rz, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, zsquared, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, t3, Rz),\n\n            // t10 = q.y + r.z;\n            c.call(f2mPrefix + \"_add\", Qy, Rz, t10),\n\n            // t8 = (t7 - r.x) * t6;\n            c.call(f2mPrefix + \"_sub\", t7, Rx, t8),\n            c.call(f2mPrefix + \"_mul\", t8, t6, t8),\n\n            // t0 = r.y * t5;\n            c.call(f2mPrefix + \"_mul\", Ry, t5, t0),\n\n            // t0 = t0 + t0;\n            c.call(f2mPrefix + \"_add\", t0, t0, t0),\n\n            // r.y = t8 - t0;\n            c.call(f2mPrefix + \"_sub\", t8, t0, Ry),\n\n            // t10 = t10.square() - ysquared;\n            c.call(f2mPrefix + \"_square\", t10, t10),\n            c.call(f2mPrefix + \"_sub\", t10, ysquared, t10),\n\n            // ztsquared = r.z.square();\n            c.call(f2mPrefix + \"_square\", Rz, ztsquared),\n\n            // t10 = t10 - ztsquared;\n            c.call(f2mPrefix + \"_sub\", t10, ztsquared, t10),\n\n            // t9 = t9 + t9 - t10;\n            c.call(f2mPrefix + \"_add\", t9, t9, t9),\n            c.call(f2mPrefix + \"_sub\", t9, t10, t9),\n\n            // t10 = r.z + r.z;\n            c.call(f2mPrefix + \"_add\", Rz, Rz, t10),\n\n            // t6 = -t6;\n            c.call(f2mPrefix + \"_neg\", t6, t6),\n\n            // t1 = t6 + t6;\n            c.call(f2mPrefix + \"_add\", t6, t6, t1),\n        );\n    }\n\n\n    function buildPrepareG2() {\n        const f = module.addFunction(prefix+ \"_prepareG2\");\n        f.addParam(\"pQ\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n\n        const Q = c.getLocal(\"pQ\");\n\n        const pR = module.alloc(f2size*3);\n        const R = c.i32_const(pR);\n\n        const base = c.getLocal(\"ppreQ\");\n\n        f.addCode(\n            c.call(g2mPrefix + \"_normalize\", Q, base),\n            c.if(\n                c.call(g2mPrefix + \"_isZero\", base),\n                c.ret([])\n            ),\n            c.call(g2mPrefix + \"_copy\", base, R),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n        );\n\n        f.addCode(\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n                c.call(prefix + \"_prepDblStep\", R, c.getLocal(\"pCoef\")),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(prefix + \"_prepAddStep\", R, base, c.getLocal(\"pCoef\")),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n                    ]\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n    function buildF6Mul1() {\n        const f = module.addFunction(f6mPrefix+ \"_mul1\");\n        f.addParam(\"pA\", \"i32\");    // F6\n        f.addParam(\"pC1\", \"i32\");   // F2\n        f.addParam(\"pR\", \"i32\");    // F6\n\n        const c = f.getCodeBuilder();\n\n        const A_c0 = c.getLocal(\"pA\");\n        const A_c1 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*2));\n        const A_c2 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*4));\n\n        const c1  = c.getLocal(\"pC1\");\n\n        const t1 = c.getLocal(\"pR\");\n        const t2 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*2));\n        const b_b = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*4));\n\n        const Ac0_Ac1 = c.i32_const(module.alloc(f1size*2));\n        const Ac1_Ac2 = c.i32_const(module.alloc(f1size*2));\n\n        f.addCode(\n\n            c.call(f2mPrefix + \"_add\", A_c0, A_c1, Ac0_Ac1),\n            c.call(f2mPrefix + \"_add\", A_c1, A_c2, Ac1_Ac2),\n\n            // let b_b = self.c1 * c1;\n            c.call(f2mPrefix + \"_mul\", A_c1, c1, b_b),\n\n            // let t1 = (self.c1 + self.c2) * c1 - b_b;\n            c.call(f2mPrefix + \"_mul\", Ac1_Ac2, c1, t1),\n            c.call(f2mPrefix + \"_sub\", t1, b_b, t1),\n\n            // let t1 = t1.mul_by_nonresidue();\n            c.call(f2mPrefix + \"_mulNR\", t1, t1),\n\n            // let t2 = (self.c0 + self.c1) * c1 - b_b;\n            c.call(f2mPrefix + \"_mul\", Ac0_Ac1, c1, t2),\n            c.call(f2mPrefix + \"_sub\", t2, b_b, t2),\n        );\n    }\n    buildF6Mul1();\n\n    function buildF6Mul01() {\n        const f = module.addFunction(f6mPrefix+ \"_mul01\");\n        f.addParam(\"pA\", \"i32\");    // F6\n        f.addParam(\"pC0\", \"i32\");   // F2\n        f.addParam(\"pC1\", \"i32\");   // F2\n        f.addParam(\"pR\", \"i32\");    // F6\n\n        const c = f.getCodeBuilder();\n\n        const A_c0 = c.getLocal(\"pA\");\n        const A_c1 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*2));\n        const A_c2 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*4));\n\n        const c0  = c.getLocal(\"pC0\");\n        const c1  = c.getLocal(\"pC1\");\n\n        const t1 = c.getLocal(\"pR\");\n        const t2 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*2));\n        const t3 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*4));\n\n        const a_a = c.i32_const(module.alloc(f1size*2));\n        const b_b = c.i32_const(module.alloc(f1size*2));\n        const Ac0_Ac1 = c.i32_const(module.alloc(f1size*2));\n        const Ac0_Ac2 = c.i32_const(module.alloc(f1size*2));\n\n        f.addCode(\n            // let a_a = self.c0 * c0;\n            c.call(f2mPrefix + \"_mul\", A_c0, c0, a_a),\n\n            // let b_b = self.c1 * c1;\n            c.call(f2mPrefix + \"_mul\", A_c1, c1, b_b),\n\n\n            c.call(f2mPrefix + \"_add\", A_c0, A_c1, Ac0_Ac1),\n            c.call(f2mPrefix + \"_add\", A_c0, A_c2, Ac0_Ac2),\n\n            // let t1 = (self.c1 + self.c2) * c1 - b_b;\n            c.call(f2mPrefix + \"_add\", A_c1, A_c2, t1),\n            c.call(f2mPrefix + \"_mul\", t1, c1, t1),\n            c.call(f2mPrefix + \"_sub\", t1, b_b, t1),\n\n            // let t1 = t1.mul_by_nonresidue() + a_a;\n            c.call(f2mPrefix + \"_mulNR\", t1, t1),\n            c.call(f2mPrefix + \"_add\", t1, a_a, t1),\n\n            // let t2 = (c0 + c1) * (self.c0 + self.c1) - a_a - b_b;\n            c.call(f2mPrefix + \"_add\", c0, c1, t2),\n            c.call(f2mPrefix + \"_mul\", t2, Ac0_Ac1, t2),\n            c.call(f2mPrefix + \"_sub\", t2, a_a, t2),\n            c.call(f2mPrefix + \"_sub\", t2, b_b, t2),\n\n            // let t3 = (self.c0 + self.c2) * c0 - a_a + b_b;\n            c.call(f2mPrefix + \"_mul\", Ac0_Ac2, c0, t3),\n            c.call(f2mPrefix + \"_sub\", t3, a_a, t3),\n            c.call(f2mPrefix + \"_add\", t3, b_b, t3),\n\n\n        );\n    }\n    buildF6Mul01();\n\n\n    function buildF12Mul014() {\n\n        const f = module.addFunction(ftmPrefix+ \"_mul014\");\n        f.addParam(\"pA\", \"i32\");    // F12\n        f.addParam(\"pC0\", \"i32\");   // F2\n        f.addParam(\"pC1\", \"i32\");   // F2\n        f.addParam(\"pC4\", \"i32\");   // F2\n        f.addParam(\"pR\", \"i32\");    // F12\n\n        const c = f.getCodeBuilder();\n\n\n        const A_c0 = c.getLocal(\"pA\");\n        const A_c1 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*6));\n\n        const c0  = c.getLocal(\"pC0\");\n        const c1  = c.getLocal(\"pC1\");\n        const c4  = c.getLocal(\"pC4\");\n\n        const aa = c.i32_const(module.alloc(f1size*6));\n        const bb = c.i32_const(module.alloc(f1size*6));\n        const o = c.i32_const(module.alloc(f1size*2));\n\n        const R_c0 = c.getLocal(\"pR\");\n        const R_c1 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*6));\n\n        f.addCode(\n            // let aa = self.c0.mul_by_01(c0, c1);\n            c.call(f6mPrefix + \"_mul01\", A_c0, c0, c1, aa),\n\n            // let bb = self.c1.mul_by_1(c4);\n            c.call(f6mPrefix + \"_mul1\", A_c1, c4, bb),\n\n            // let o = c1 + c4;\n            c.call(f2mPrefix + \"_add\", c1, c4, o),\n\n            // let c1 = self.c1 + self.c0;\n            c.call(f6mPrefix + \"_add\", A_c1, A_c0, R_c1),\n\n            // let c1 = c1.mul_by_01(c0, &o);\n            c.call(f6mPrefix + \"_mul01\", R_c1, c0, o, R_c1),\n\n            // let c1 = c1 - aa - bb;\n            c.call(f6mPrefix + \"_sub\", R_c1, aa, R_c1),\n            c.call(f6mPrefix + \"_sub\", R_c1, bb, R_c1),\n\n            // let c0 = bb;\n            c.call(f6mPrefix + \"_copy\", bb, R_c0),\n\n            // let c0 = c0.mul_by_nonresidue();\n            c.call(f6mPrefix + \"_mulNR\", R_c0, R_c0),\n\n            // let c0 = c0 + aa;\n            c.call(f6mPrefix + \"_add\", R_c0, aa, R_c0),\n        );\n    }\n    buildF12Mul014();\n\n\n    function buildELL() {\n        const f = module.addFunction(prefix+ \"_ell\");\n        f.addParam(\"pP\", \"i32\");\n        f.addParam(\"pCoefs\", \"i32\");\n        f.addParam(\"pF\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Px  = c.getLocal(\"pP\");\n        const Py  = c.i32_add(c.getLocal(\"pP\"), c.i32_const(n8q));\n\n        const F  = c.getLocal(\"pF\");\n\n        const coef0_0  = c.getLocal(\"pCoefs\");\n        const coef0_1  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size));\n        const coef1_0  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size*2));\n        const coef1_1  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size*3));\n        const coef2  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size*4));\n\n        const pc0 = module.alloc(f1size*2);\n        const c0  = c.i32_const(pc0);\n        const c0_c0 = c.i32_const(pc0);\n        const c0_c1 = c.i32_const(pc0+f1size);\n\n        const pc1 = module.alloc(f1size*2);\n        const c1  = c.i32_const(pc1);\n        const c1_c0 = c.i32_const(pc1);\n        const c1_c1 = c.i32_const(pc1+f1size);\n        f.addCode(\n            //     let mut c0 = coeffs.0;\n            //     let mut c1 = coeffs.1;\n            //\n            //    c0.c0 *= p.y;\n            //    c0.c1 *= p.y;\n            //\n            //    c1.c0 *= p.x;\n            //    c1.c1 *= p.x;\n            //\n            //     f.mul_by_014(&coeffs.2, &c1, &c0)\n\n            c.call(f1mPrefix + \"_mul\", coef0_0, Py, c0_c0),\n            c.call(f1mPrefix + \"_mul\", coef0_1, Py, c0_c1),\n            c.call(f1mPrefix + \"_mul\", coef1_0, Px, c1_c0),\n            c.call(f1mPrefix + \"_mul\", coef1_1, Px, c1_c1),\n\n            c.call(ftmPrefix + \"_mul014\", F, coef2, c1, c0, F),\n\n        );\n\n    }\n    buildELL();\n\n    function buildMillerLoop() {\n        const f = module.addFunction(prefix+ \"_millerLoop\");\n        f.addParam(\"ppreP\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const preP = c.getLocal(\"ppreP\");\n\n        const coefs  = c.getLocal(\"pCoef\");\n\n        const F = c.getLocal(\"r\");\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_one\", F),\n\n            c.if(\n                c.call(g1mPrefix + \"_isZero\", preP),\n                c.ret([])\n            ),\n            c.if(\n                c.call(g1mPrefix + \"_isZero\", c.getLocal(\"ppreQ\")),\n                c.ret([])\n            ),\n            c.setLocal(\"pCoef\", c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n\n                c.call(prefix + \"_ell\", preP, coefs,  F),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(prefix + \"_ell\", preP, coefs,  F),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n                    ]\n                ),\n                c.call(ftmPrefix + \"_square\", F, F),\n\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.i32_const(1) )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n            c.call(prefix + \"_ell\", preP, coefs,  F),\n\n        );\n\n\n        if (isLoopNegative) {\n            f.addCode(\n                c.call(ftmPrefix + \"_conjugate\", F, F),\n            );\n        }\n    }\n\n\n    function buildFrobeniusMap(n) {\n        const F12 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n, 151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],\n                [2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n, 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],\n                [3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n, 877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n],\n                [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],\n                [151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n, 3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],\n                [1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n, 2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],\n                [877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n, 3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n],\n            ]\n        ];\n\n        const F6 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [0n, 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],\n                [0n, 1n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],\n                [0n, 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n],\n            ],\n            [\n                [1n, 0n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],\n                [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],\n            ]\n        ];\n\n        const f = module.addFunction(ftmPrefix + \"_frobeniusMap\"+n);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<6; i++) {\n            const X = (i==0) ? c.getLocal(\"x\") : c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size));\n            const Xc0 = X;\n            const Xc1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size + f1size));\n            const R = (i==0) ? c.getLocal(\"r\") : c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size));\n            const Rc0 = R;\n            const Rc1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size + f1size));\n            const coef = mul2(F12[Math.floor(i/3)][n%12] , F6[i%3][n%6]);\n            const pCoef = module.alloc([\n                ...utils.bigInt2BytesLE(toMontgomery(coef[0]), n8q),\n                ...utils.bigInt2BytesLE(toMontgomery(coef[1]), n8q),\n            ]);\n            if (n%2 == 1) {\n                f.addCode(\n                    c.call(f1mPrefix + \"_copy\", Xc0, Rc0),\n                    c.call(f1mPrefix + \"_neg\", Xc1, Rc1),\n                    c.call(f2mPrefix + \"_mul\", R, c.i32_const(pCoef), R),\n                );\n            } else {\n                f.addCode(c.call(f2mPrefix + \"_mul\", X, c.i32_const(pCoef), R));\n            }\n        }\n\n        function mul2(a, b) {\n            const ac0 = a[0];\n            const ac1 = a[1];\n            const bc0 = b[0];\n            const bc1 = b[1];\n            const res = [\n                (ac0 * bc0 - (ac1 * bc1)) % q,\n                (ac0 * bc1 + (ac1 * bc0)) % q,\n            ];\n            if (isNegative(res[0])) res[0] = res[0] + q;\n            return res;\n        }\n\n    }\n\n\n    function buildCyclotomicSquare() {\n        const f = module.addFunction(prefix+ \"__cyclotomicSquare\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x4 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f2size));\n        const x3 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f2size));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(3*f2size));\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(4*f2size));\n        const x5 = c.i32_add(c.getLocal(\"x\"), c.i32_const(5*f2size));\n\n        const r0 = c.getLocal(\"r\");\n        const r4 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f2size));\n        const r3 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f2size));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(3*f2size));\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*f2size));\n        const r5 = c.i32_add(c.getLocal(\"r\"), c.i32_const(5*f2size));\n\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t3 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n        const tmp = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n\n        f.addCode(\n            //    // t0 + t1*y = (z0 + z1*y)^2 = a^2\n            //    tmp = z0 * z1;\n            //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;\n            //    t1 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x0, x1, tmp),\n            c.call(f2mPrefix + \"_mulNR\", x1, t0),\n            c.call(f2mPrefix + \"_add\", x0, t0, t0),\n            c.call(f2mPrefix + \"_add\", x0, x1, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t0, t0),\n            c.call(f2mPrefix + \"_mulNR\", tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t0, AUX, t0),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t1),\n\n            //  // t2 + t3*y = (z2 + z3*y)^2 = b^2\n            //  tmp = z2 * z3;\n            //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;\n            //  t3 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x2, x3, tmp),\n            c.call(f2mPrefix + \"_mulNR\", x3, t2),\n            c.call(f2mPrefix + \"_add\", x2, t2, t2),\n            c.call(f2mPrefix + \"_add\", x2, x3, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t2, t2),\n            c.call(f2mPrefix + \"_mulNR\", tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t2, AUX, t2),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t3),\n\n            //  // t4 + t5*y = (z4 + z5*y)^2 = c^2\n            //  tmp = z4 * z5;\n            //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;\n            //  t5 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x4, x5, tmp),\n            c.call(f2mPrefix + \"_mulNR\", x5, t4),\n            c.call(f2mPrefix + \"_add\", x4, t4, t4),\n            c.call(f2mPrefix + \"_add\", x4, x5, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t4, t4),\n            c.call(f2mPrefix + \"_mulNR\", tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t4, AUX, t4),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t5),\n\n            // For A\n            // z0 = 3 * t0 - 2 * z0\n            c.call(f2mPrefix + \"_sub\", t0, x0, r0),\n            c.call(f2mPrefix + \"_add\", r0, r0, r0),\n            c.call(f2mPrefix + \"_add\", t0, r0, r0),\n            // z1 = 3 * t1 + 2 * z1\n            c.call(f2mPrefix + \"_add\", t1, x1, r1),\n            c.call(f2mPrefix + \"_add\", r1, r1, r1),\n            c.call(f2mPrefix + \"_add\", t1, r1, r1),\n\n            // For B\n            // z2 = 3 * (xi * t5) + 2 * z2\n            c.call(f2mPrefix + \"_mul\", t5, c.i32_const(pBls12381Twist), AUX),\n            c.call(f2mPrefix + \"_add\", AUX, x2, r2),\n            c.call(f2mPrefix + \"_add\", r2, r2, r2),\n            c.call(f2mPrefix + \"_add\", AUX, r2, r2),\n            // z3 = 3 * t4 - 2 * z3\n            c.call(f2mPrefix + \"_sub\", t4, x3, r3),\n            c.call(f2mPrefix + \"_add\", r3, r3, r3),\n            c.call(f2mPrefix + \"_add\", t4, r3, r3),\n\n            // For C\n            // z4 = 3 * t2 - 2 * z4\n            c.call(f2mPrefix + \"_sub\", t2, x4, r4),\n            c.call(f2mPrefix + \"_add\", r4, r4, r4),\n            c.call(f2mPrefix + \"_add\", t2, r4, r4),\n            // z5 = 3 * t3 + 2 * z5\n            c.call(f2mPrefix + \"_add\", t3, x5, r5),\n            c.call(f2mPrefix + \"_add\", r5, r5, r5),\n            c.call(f2mPrefix + \"_add\", t3, r5, r5),\n\n        );\n    }\n\n\n    function buildCyclotomicExp(exponent, isExpNegative, fnName) {\n        const exponentNafBytes = naf(exponent).map( (b) => (b==-1 ? 0xFF: b) );\n        const pExponentNafBytes = module.alloc(exponentNafBytes);\n        // const pExponent = module.alloc(utils.bigInt2BytesLE(exponent, n8));\n\n        const f = module.addFunction(prefix+ \"__cyclotomicExp_\"+fnName);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"bit\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"x\");\n\n        const res = c.getLocal(\"r\");\n\n        const inverse = c.i32_const(module.alloc(ftsize));\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_conjugate\", x, inverse),\n            c.call(ftmPrefix + \"_one\", res),\n\n            c.if(\n                c.teeLocal(\"bit\", c.i32_load8_s(c.i32_const(exponentNafBytes.length-1), pExponentNafBytes)),\n                c.if(\n                    c.i32_eq(\n                        c.getLocal(\"bit\"),\n                        c.i32_const(1)\n                    ),\n                    c.call(ftmPrefix + \"_mul\", res, x, res),\n                    c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                )\n            ),\n\n            c.setLocal(\"i\", c.i32_const(exponentNafBytes.length-2)),\n            c.block(c.loop(\n                c.call(prefix + \"__cyclotomicSquare\", res, res),\n                c.if(\n                    c.teeLocal(\"bit\", c.i32_load8_s(c.getLocal(\"i\"), pExponentNafBytes)),\n                    c.if(\n                        c.i32_eq(\n                            c.getLocal(\"bit\"),\n                            c.i32_const(1)\n                        ),\n                        c.call(ftmPrefix + \"_mul\", res, x, res),\n                        c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                    )\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n\n        if (isExpNegative) {\n            f.addCode(\n                c.call(ftmPrefix + \"_conjugate\", res, res),\n            );\n        }\n\n    }\n\n    function buildFinalExponentiation() {\n        buildCyclotomicSquare();\n        buildCyclotomicExp(finalExpZ, finalExpIsNegative, \"w0\");\n\n        const f = module.addFunction(prefix+ \"_finalExponentiation\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const res = c.getLocal(\"r\");\n        const t0 = c.i32_const(module.alloc(ftsize));\n        const t1 = c.i32_const(module.alloc(ftsize));\n        const t2 = c.i32_const(module.alloc(ftsize));\n        const t3 = c.i32_const(module.alloc(ftsize));\n        const t4 = c.i32_const(module.alloc(ftsize));\n        const t5 = c.i32_const(module.alloc(ftsize));\n        const t6 = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n\n            // let mut t0 = f.frobenius_map(6)\n            c.call(ftmPrefix + \"_frobeniusMap6\", elt, t0),\n\n            // let t1 = f.invert()\n            c.call(ftmPrefix + \"_inverse\", elt, t1),\n\n            // let mut t2 = t0 * t1;\n            c.call(ftmPrefix + \"_mul\", t0, t1, t2),\n\n            // t1 = t2.clone();\n            c.call(ftmPrefix + \"_copy\", t2, t1),\n\n            // t2 = t2.frobenius_map().frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap2\", t2, t2),\n\n            // t2 *= t1;\n            c.call(ftmPrefix + \"_mul\", t2, t1, t2),\n\n\n            // t1 = cyclotomic_square(t2).conjugate();\n            c.call(prefix + \"__cyclotomicSquare\", t2, t1),\n            c.call(ftmPrefix + \"_conjugate\", t1, t1),\n\n            // let mut t3 = cycolotomic_exp(t2);\n            c.call(prefix + \"__cyclotomicExp_w0\", t2, t3),\n\n            // let mut t4 = cyclotomic_square(t3);\n            c.call(prefix + \"__cyclotomicSquare\", t3, t4),\n\n            // let mut t5 = t1 * t3;\n            c.call(ftmPrefix + \"_mul\", t1, t3, t5),\n\n            // t1 = cycolotomic_exp(t5);\n            c.call(prefix + \"__cyclotomicExp_w0\", t5, t1),\n\n            // t0 = cycolotomic_exp(t1);\n            c.call(prefix + \"__cyclotomicExp_w0\", t1, t0),\n\n            // let mut t6 = cycolotomic_exp(t0);\n            c.call(prefix + \"__cyclotomicExp_w0\", t0, t6),\n\n            // t6 *= t4;\n            c.call(ftmPrefix + \"_mul\", t6, t4, t6),\n\n            // t4 = cycolotomic_exp(t6);\n            c.call(prefix + \"__cyclotomicExp_w0\", t6, t4),\n\n            // t5 = t5.conjugate();\n            c.call(ftmPrefix + \"_conjugate\", t5, t5),\n\n            // t4 *= t5 * t2;\n            c.call(ftmPrefix + \"_mul\", t4, t5, t4),\n            c.call(ftmPrefix + \"_mul\", t4, t2, t4),\n\n            // t5 = t2.conjugate();\n            c.call(ftmPrefix + \"_conjugate\", t2, t5),\n\n            // t1 *= t2;\n            c.call(ftmPrefix + \"_mul\", t1, t2, t1),\n\n            // t1 = t1.frobenius_map().frobenius_map().frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap3\", t1, t1),\n\n            // t6 *= t5;\n            c.call(ftmPrefix + \"_mul\", t6, t5, t6),\n\n            // t6 = t6.frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap1\", t6, t6),\n\n            // t3 *= t0;\n            c.call(ftmPrefix + \"_mul\", t3, t0, t3),\n\n            // t3 = t3.frobenius_map().frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap2\", t3, t3),\n\n            // t3 *= t1;\n            c.call(ftmPrefix + \"_mul\", t3, t1, t3),\n\n            // t3 *= t6;\n            c.call(ftmPrefix + \"_mul\", t3, t6, t3),\n\n            // f = t3 * t4;\n            c.call(ftmPrefix + \"_mul\", t3, t4, res),\n\n        );\n    }\n\n\n    function buildFinalExponentiationOld() {\n        const f = module.addFunction(prefix+ \"_finalExponentiationOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const exponent = 322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n;\n\n        const pExponent = module.alloc(utils.bigInt2BytesLE( exponent, 544 ));\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(ftmPrefix + \"_exp\", c.getLocal(\"x\"), c.i32_const(pExponent), c.i32_const(544), c.getLocal(\"r\")),\n        );\n    }\n\n\n    const pPreP = module.alloc(prePSize);\n    const pPreQ = module.alloc(preQSize);\n\n    function buildPairingEquation(nPairings) {\n\n        const f = module.addFunction(prefix+ \"_pairingEq\"+nPairings);\n        for (let i=0; i<nPairings; i++) {\n            f.addParam(\"p_\"+i, \"i32\");\n            f.addParam(\"q_\"+i, \"i32\");\n        }\n        f.addParam(\"c\", \"i32\");\n        f.setReturnType(\"i32\");\n\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n        const auxT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(ftmPrefix + \"_one\", resT ));\n\n        for (let i=0; i<nPairings; i++) {\n\n            f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p_\"+i), c.i32_const(pPreP) ));\n            f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q_\"+i), c.i32_const(pPreQ) ));\n\n            // Checks\n            f.addCode(\n                c.if(\n                    c.i32_eqz(c.call(g1mPrefix + \"_inGroupAffine\", c.i32_const(pPreP))),\n                    c.ret(c.i32_const(0))\n                ),\n                c.if(\n                    c.i32_eqz(c.call(g2mPrefix + \"_inGroupAffine\", c.i32_const(pPreQ))),\n                    c.ret(c.i32_const(0))\n                )\n            );\n\n            f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), auxT ));\n\n            f.addCode(c.call(ftmPrefix + \"_mul\", resT, auxT, resT ));\n        }\n\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, resT ));\n\n        f.addCode(c.call(ftmPrefix + \"_eq\", resT, c.getLocal(\"c\")));\n    }\n\n\n    function buildPairing() {\n\n        const f = module.addFunction(prefix+ \"_pairing\");\n        f.addParam(\"p\", \"i32\");\n        f.addParam(\"q\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p\"), c.i32_const(pPreP) ));\n        f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q\"), c.i32_const(pPreQ) ));\n        f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), resT ));\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, c.getLocal(\"r\") ));\n    }\n\n\n    function buildInGroupG2() {\n        const f = module.addFunction(g2mPrefix+ \"_inGroupAffine\");\n        f.addParam(\"p\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const WINV = [\n            2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279894n,\n            2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893n\n        ];\n\n        const FROB2X = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;\n        const FROB3Y = [\n            2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,\n            2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n\n        ];\n\n        const wInv = c.i32_const(module.alloc([\n            ...utils.bigInt2BytesLE(toMontgomery(WINV[0]), n8q),\n            ...utils.bigInt2BytesLE(toMontgomery(WINV[1]), n8q),\n        ]));\n\n        const frob2X = c.i32_const(module.alloc(utils.bigInt2BytesLE(toMontgomery(FROB2X), n8q)));\n        const frob3Y = c.i32_const(module.alloc([\n            ...utils.bigInt2BytesLE(toMontgomery(FROB3Y[0]), n8q),\n            ...utils.bigInt2BytesLE(toMontgomery(FROB3Y[1]), n8q),\n        ]));\n\n        const z = c.i32_const(module.alloc(utils.bigInt2BytesLE(finalExpZ, 8)));\n\n        const px = c.getLocal(\"p\");\n        const py = c.i32_add(c.getLocal(\"p\"), c.i32_const(f2size));\n\n        const aux = c.i32_const(module.alloc(f1size));\n\n        const x_winv = c.i32_const(module.alloc(f2size));\n        const y_winv = c.i32_const(module.alloc(f2size));\n        const pf2 = module.alloc(f2size*2);\n        const f2 = c.i32_const(pf2);\n        const f2x = c.i32_const(pf2);\n        const f2x_c1 = c.i32_const(pf2);\n        const f2x_c2 = c.i32_const(pf2+f1size);\n        const f2y = c.i32_const(pf2+f2size);\n        const f2y_c1 = c.i32_const(pf2+f2size);\n        const f2y_c2 = c.i32_const(pf2+f2size+f1size);\n        const pf3 = module.alloc(f2size*3);\n        const f3 = c.i32_const(pf3);\n        const f3x = c.i32_const(pf3);\n        const f3x_c1 = c.i32_const(pf3);\n        const f3x_c2 = c.i32_const(pf3+f1size);\n        const f3y = c.i32_const(pf3+f2size);\n        const f3y_c1 = c.i32_const(pf3+f2size);\n        const f3y_c2 = c.i32_const(pf3+f2size+f1size);\n        const f3z = c.i32_const(pf3+f2size*2);\n\n\n        f.addCode(\n            c.if(\n                c.call(g2mPrefix + \"_isZeroAffine\", c.getLocal(\"p\")),\n                c.ret( c.i32_const(1)),\n            ),\n            c.if(\n                c.i32_eqz(c.call(g2mPrefix + \"_inCurveAffine\", c.getLocal(\"p\"))),\n                c.ret( c.i32_const(0)),\n            ),\n            c.call(f2mPrefix + \"_mul\", px, wInv, x_winv),\n            c.call(f2mPrefix + \"_mul\", py, wInv, y_winv),\n\n            c.call(f2mPrefix + \"_mul1\", x_winv, frob2X, f2x),\n            c.call(f2mPrefix + \"_neg\", y_winv, f2y),\n\n            c.call(f2mPrefix + \"_neg\", x_winv, f3x),\n            c.call(f2mPrefix + \"_mul\", y_winv, frob3Y, f3y),\n\n            c.call(f1mPrefix + \"_sub\", f2x_c1, f2x_c2, aux),\n            c.call(f1mPrefix + \"_add\", f2x_c1, f2x_c2, f2x_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f2x_c1),\n\n            c.call(f1mPrefix + \"_sub\", f2y_c1, f2y_c2, aux),\n            c.call(f1mPrefix + \"_add\", f2y_c1, f2y_c2, f2y_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f2y_c1),\n\n            c.call(f1mPrefix + \"_add\", f3x_c1, f3x_c2, aux),\n            c.call(f1mPrefix + \"_sub\", f3x_c1, f3x_c2, f3x_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f3x_c1),\n\n            c.call(f1mPrefix + \"_sub\", f3y_c2, f3y_c1, aux),\n            c.call(f1mPrefix + \"_add\", f3y_c1, f3y_c2, f3y_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f3y_c1),\n\n            c.call(f2mPrefix + \"_one\", f3z),\n\n            c.call(g2mPrefix + \"_timesScalar\", f3, z, c.i32_const(8), f3),\n            c.call(g2mPrefix + \"_addMixed\", f3, f2, f3),\n\n            c.ret(\n                c.call(g2mPrefix + \"_eqMixed\", f3, c.getLocal(\"p\"))\n            )\n        );\n\n        const fInGroup = module.addFunction(g2mPrefix + \"_inGroup\");\n        fInGroup.addParam(\"pIn\", \"i32\");\n        fInGroup.setReturnType(\"i32\");\n\n        const c2 = fInGroup.getCodeBuilder();\n\n        const aux2 = c2.i32_const(module.alloc(f2size*2));\n\n        fInGroup.addCode(\n            c2.call(g2mPrefix + \"_toAffine\", c2.getLocal(\"pIn\"), aux2),\n\n            c2.ret(\n                c2.call(g2mPrefix + \"_inGroupAffine\", aux2),\n            )\n        );\n\n    }\n\n    function buildInGroupG1() {\n        const f = module.addFunction(g1mPrefix+ \"_inGroupAffine\");\n        f.addParam(\"p\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const BETA = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;\n        const BETA2 = 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n;\n        const Z2M1D3 = (finalExpZ * finalExpZ - 1n) / 3n;\n\n        const beta = c.i32_const(module.alloc(utils.bigInt2BytesLE(toMontgomery(BETA), n8q)));\n        const beta2 = c.i32_const(module.alloc(utils.bigInt2BytesLE(toMontgomery(BETA2), n8q)));\n\n        const z2m1d3 = c.i32_const(module.alloc(utils.bigInt2BytesLE(Z2M1D3, 16)));\n\n\n        const px = c.getLocal(\"p\");\n        const py = c.i32_add(c.getLocal(\"p\"), c.i32_const(f1size));\n\n        const psp = module.alloc(f1size*3);\n        const sp = c.i32_const(psp);\n        const spx = c.i32_const(psp);\n        const spy = c.i32_const(psp+f1size);\n\n        const ps2p = module.alloc(f1size*2);\n        const s2p = c.i32_const(ps2p);\n        const s2px = c.i32_const(ps2p);\n        const s2py = c.i32_const(ps2p+f1size);\n\n        f.addCode(\n            c.if(\n                c.call(g1mPrefix + \"_isZeroAffine\", c.getLocal(\"p\")),\n                c.ret( c.i32_const(1)),\n            ),\n            c.if(\n                c.i32_eqz(c.call(g1mPrefix + \"_inCurveAffine\", c.getLocal(\"p\"))),\n                c.ret( c.i32_const(0)),\n            ),\n\n            c.call(f1mPrefix + \"_mul\", px, beta, spx),\n            c.call(f1mPrefix + \"_copy\", py, spy),\n\n            c.call(f1mPrefix + \"_mul\", px, beta2, s2px),\n            c.call(f1mPrefix + \"_copy\", py, s2py),\n\n\n            c.call(g1mPrefix + \"_doubleAffine\", sp, sp),\n            c.call(g1mPrefix + \"_subMixed\", sp, c.getLocal(\"p\"), sp),\n            c.call(g1mPrefix + \"_subMixed\", sp, s2p, sp),\n\n            c.call(g1mPrefix + \"_timesScalar\", sp, z2m1d3, c.i32_const(16), sp),\n\n            c.ret(\n                c.call(g1mPrefix + \"_eqMixed\", sp, s2p)\n            )\n\n        );\n\n        const fInGroup = module.addFunction(g1mPrefix + \"_inGroup\");\n        fInGroup.addParam(\"pIn\", \"i32\");\n        fInGroup.setReturnType(\"i32\");\n\n        const c2 = fInGroup.getCodeBuilder();\n\n        const aux2 = c2.i32_const(module.alloc(f1size*2));\n\n        fInGroup.addCode(\n            c2.call(g1mPrefix + \"_toAffine\", c2.getLocal(\"pIn\"), aux2),\n\n            c2.ret(\n                c2.call(g1mPrefix + \"_inGroupAffine\", aux2),\n            )\n        );\n    }\n\n    for (let i=0; i<10; i++) {\n        buildFrobeniusMap(i);\n        module.exportFunction(ftmPrefix + \"_frobeniusMap\"+i);\n    }\n\n\n    buildInGroupG1();\n    buildInGroupG2();\n\n    buildPrepAddStep();\n    buildPrepDoubleStep();\n\n    buildPrepareG1();\n    buildPrepareG2();\n\n    buildMillerLoop();\n\n    buildFinalExponentiationOld();\n    buildFinalExponentiation();\n\n    for (let i=1; i<=5; i++) {\n        buildPairingEquation(i);\n        module.exportFunction(prefix + \"_pairingEq\"+i);\n    }\n\n    buildPairing();\n\n    module.exportFunction(prefix + \"_pairing\");\n\n\n    module.exportFunction(prefix + \"_prepareG1\");\n    module.exportFunction(prefix + \"_prepareG2\");\n    module.exportFunction(prefix + \"_millerLoop\");\n    module.exportFunction(prefix + \"_finalExponentiation\");\n    module.exportFunction(prefix + \"_finalExponentiationOld\");\n    module.exportFunction(prefix + \"__cyclotomicSquare\");\n    module.exportFunction(prefix + \"__cyclotomicExp_w0\");\n\n    module.exportFunction(f6mPrefix + \"_mul1\");\n    module.exportFunction(f6mPrefix + \"_mul01\");\n    module.exportFunction(ftmPrefix + \"_mul014\");\n\n    module.exportFunction(g1mPrefix + \"_inGroupAffine\");\n    module.exportFunction(g1mPrefix + \"_inGroup\");\n    module.exportFunction(g2mPrefix + \"_inGroupAffine\");\n    module.exportFunction(g2mPrefix + \"_inGroup\");\n\n    // console.log(module.functionIdxByName);\n};\n\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n// module.exports.bn128_wasm = require(\"./build/bn128_wasm.js\");\n// module.exports.bls12381_wasm = require(\"./build/bls12381_wasm.js\");\n// module.exports.mnt6753_wasm = require(\"./build/mnt6753_wasm.js\");\n\nmodule.exports.buildBn128 = require(\"./src/bn128/build_bn128.js\");\nmodule.exports.buildBls12381 = require(\"./src/bls12381/build_bls12381.js\");\n// module.exports.buildMnt6753 = require(\"./src/mnt6753/build_mnt7.js\");\n\nmodule.exports.buildF1m = require(\"./src/build_f1m\");\n", "/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nmodule.exports = Worker;", "'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n", "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n", "\nconst polyfill = require('crypto')\n\nif (polyfill && polyfill.default) {\n    module.exports = polyfill.default\n    for (let k in polyfill) {\n        module.exports[k] = polyfill[k]\n    }\n} else if (polyfill)  {\n    module.exports = polyfill\n}\n\n\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashSha256 = exports.sha256 = exports.sha256nodeCrypto = exports.sha256js = void 0;\nvar buffer_1 = require(\"buffer/\");\n/**\n * From https://github.com/crypto-browserify/sha.js/blob/master/sha256.js\n *\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\nvar sha256js = /** @class */ (function () {\n    function sha256js() {\n        this._blockSize = 64;\n        this._finalSize = 56;\n        this._len = 0;\n        this._w = new Array(64);\n        this._a = 0x6a09e667;\n        this._b = 0xbb67ae85;\n        this._c = 0x3c6ef372;\n        this._d = 0xa54ff53a;\n        this._e = 0x510e527f;\n        this._f = 0x9b05688c;\n        this._g = 0x1f83d9ab;\n        this._h = 0x5be0cd19;\n        this._block = buffer_1.Buffer.alloc(this._blockSize);\n    }\n    sha256js.prototype.update = function (data, encoding) {\n        if (typeof data === 'string') {\n            encoding = encoding || 'utf8';\n            data = buffer_1.Buffer.from(data, encoding);\n        }\n        var block = this._block;\n        var blockSize = this._blockSize;\n        var length = data.length;\n        var accum = this._len;\n        for (var offset = 0; offset < length;) {\n            var assigned = accum % blockSize;\n            var remainder = Math.min(length - offset, blockSize - assigned);\n            for (var i = 0; i < remainder; i++) {\n                block[assigned + i] = data[offset + i];\n            }\n            accum += remainder;\n            offset += remainder;\n            if ((accum % blockSize) === 0) {\n                this._update(block);\n            }\n        }\n        this._len += length;\n        return this;\n    };\n    sha256js.prototype.digest = function (encoding) {\n        var rem = this._len % this._blockSize;\n        this._block[rem] = 0x80;\n        // zero (rem + 1) trailing bits, where (rem + 1) is the smallest\n        // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize\n        this._block.fill(0, rem + 1);\n        if (rem >= this._finalSize) {\n            this._update(this._block);\n            this._block.fill(0);\n        }\n        var bits = this._len * 8;\n        // uint32\n        if (bits <= 0xffffffff) {\n            this._block.writeUInt32BE(bits, this._blockSize - 4);\n            // uint64\n        }\n        else {\n            var lowBits = (bits & 0xffffffff) >>> 0;\n            var highBits = (bits - lowBits) / 0x100000000;\n            this._block.writeUInt32BE(highBits, this._blockSize - 8);\n            this._block.writeUInt32BE(lowBits, this._blockSize - 4);\n        }\n        this._update(this._block);\n        var hash = buffer_1.Buffer.alloc(32);\n        hash.writeInt32BE(this._a, 0);\n        hash.writeInt32BE(this._b, 4);\n        hash.writeInt32BE(this._c, 8);\n        hash.writeInt32BE(this._d, 12);\n        hash.writeInt32BE(this._e, 16);\n        hash.writeInt32BE(this._f, 20);\n        hash.writeInt32BE(this._g, 24);\n        hash.writeInt32BE(this._h, 28);\n        return encoding ? hash.toString(encoding) : hash;\n    };\n    sha256js.prototype.ch = function (x, y, z) {\n        return z ^ (x & (y ^ z));\n    };\n    sha256js.prototype.maj = function (x, y, z) {\n        return (x & y) | (z & (x | y));\n    };\n    sha256js.prototype.sigma0 = function (x) {\n        return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);\n    };\n    sha256js.prototype.sigma1 = function (x) {\n        return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);\n    };\n    sha256js.prototype.gamma0 = function (x) {\n        return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3);\n    };\n    sha256js.prototype.gamma1 = function (x) {\n        return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10);\n    };\n    sha256js.prototype._update = function (M) {\n        var W = this._w;\n        var a = this._a | 0;\n        var b = this._b | 0;\n        var c = this._c | 0;\n        var d = this._d | 0;\n        var e = this._e | 0;\n        var f = this._f | 0;\n        var g = this._g | 0;\n        var h = this._h | 0;\n        var i = 0;\n        for (; i < 16; ++i)\n            W[i] = M.readInt32BE(i * 4);\n        for (; i < 64; ++i)\n            W[i] = (this.gamma1(W[i - 2]) + W[i - 7] + this.gamma0(W[i - 15]) + W[i - 16]) | 0;\n        for (var j = 0; j < 64; ++j) {\n            var T1 = (h + this.sigma1(e) + this.ch(e, f, g) + sha256js.K[j] + W[j]) | 0;\n            var T2 = (this.sigma0(a) + this.maj(a, b, c)) | 0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) | 0;\n        }\n        this._a = (a + this._a) | 0;\n        this._b = (b + this._b) | 0;\n        this._c = (c + this._c) | 0;\n        this._d = (d + this._d) | 0;\n        this._e = (e + this._e) | 0;\n        this._f = (f + this._f) | 0;\n        this._g = (g + this._g) | 0;\n        this._h = (h + this._h) | 0;\n    };\n    sha256js.K = [\n        0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n        0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n        0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n        0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n        0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n        0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n        0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n        0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n        0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n        0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n        0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n        0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n        0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n        0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n        0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n        0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n    ];\n    return sha256js;\n}());\nexports.sha256js = sha256js;\nvar sha256nodeCrypto = /** @class */ (function () {\n    function sha256nodeCrypto() {\n        if (!sha256nodeCrypto.useCryptoModuleCache || sha256nodeCrypto.nodeCryptoCreateHash === undefined) {\n            sha256nodeCrypto.nodeCryptoCreateHash = require('crypto').createHash;\n        }\n        this.hash = sha256nodeCrypto.nodeCryptoCreateHash('sha256');\n    }\n    sha256nodeCrypto.prototype.update = function (data, encoding) {\n        this.hash.update(data, encoding);\n        return this;\n    };\n    sha256nodeCrypto.prototype.digest = function (encoding) {\n        if (encoding) {\n            return this.hash.digest(encoding);\n        }\n        else {\n            return this.hash.digest();\n        }\n    };\n    sha256nodeCrypto.useCryptoModuleCache = true;\n    return sha256nodeCrypto;\n}());\nexports.sha256nodeCrypto = sha256nodeCrypto;\nvar _nodeCryptoAvailable = undefined;\nfunction isNodeCryptoAvailable() {\n    if (sha256nodeCrypto.useCryptoModuleCache && _nodeCryptoAvailable !== undefined) {\n        return _nodeCryptoAvailable;\n    }\n    var isAvailable = false;\n    try {\n        if (typeof require === 'function') {\n            var cryptoModule = require('crypto');\n            isAvailable = cryptoModule && typeof cryptoModule.createHash === 'function';\n        }\n    }\n    catch (error) {\n        // ignore\n    }\n    _nodeCryptoAvailable = isAvailable;\n    return isAvailable;\n}\nvar sha256 = /** @class */ (function () {\n    function sha256() {\n        if (isNodeCryptoAvailable()) {\n            this.instance = new sha256nodeCrypto();\n        }\n        else {\n            this.instance = new sha256js();\n        }\n    }\n    sha256.prototype.update = function (data, encoding) {\n        this.instance.update(data, encoding);\n        return this;\n    };\n    sha256.prototype.digest = function (encoding) {\n        if (encoding) {\n            return this.instance.digest(encoding);\n        }\n        else {\n            return this.instance.digest();\n        }\n    };\n    return sha256;\n}());\nexports.sha256 = sha256;\n/**\n * Use Nodejs `crypto` module if available, otherwise uses js implementation.\n * @param data Input data to hash.\n */\nfunction hashSha256(data) {\n    return new sha256().update(data).digest();\n}\nexports.hashSha256 = hashSha256;\nexports.default = hashSha256;\n//# sourceMappingURL=index.js.map", "'use strict'\n/**\n * Base58 characters must only include numbers 123456789, uppercase ABCDEFGHJKLMNPQRSTUVWXYZ and lowercase abcdefghijkmnopqrstuvwxyz.\n * @kind namespace\n * @name base58_chars\n * @type {string}\n */\nconst base58_chars =\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = base58_chars\n", "'use strict'\n\nconst base58_chars = require('../private/base58_chars.js')\n\n/**\n * Converts a `base58` string to its corresponding binary representation.\n * @kind function\n * @name base58_to_binary\n * @param {base58_chars} base58String base58 encoded string\n * @returns {Uint8Array} binary representation for the base58 string.\n * @example <caption>Ways to `import`.</caption>\n * ```js\n * import { base58_to_binary } from 'base58-js'\n * ```\n * @example <caption>Ways to `require`.</caption>\n * ```js\n * const { base58_to_binary } = require('base58-js')\n * ```\n * @example <caption>Usage.</caption>\n * ```js\n * const bin = base58_to_binary(\"6MRy\")\n * console.log(bin)\n * ```\n * Logged output will be Uint8Array(3) [15, 239, 64].\n */\nconst base58_to_binary = base58String => {\n  if (!base58String || typeof base58String !== 'string')\n    throw new Error(`Expected base58 string but got \u201C${base58String}\u201D`)\n  if (base58String.match(/[IOl0]/gmu))\n    throw new Error(\n      `Invalid base58 character \u201C${base58String.match(/[IOl0]/gmu)}\u201D`\n    )\n  const lz = base58String.match(/^1+/gmu)\n  const psz = lz ? lz[0].length : 0\n  const size =\n    ((base58String.length - psz) * (Math.log(58) / Math.log(256)) + 1) >>> 0\n\n  return new Uint8Array([\n    ...new Uint8Array(psz),\n    ...base58String\n      .match(/.{1}/gmu)\n      .map(i => base58_chars.indexOf(i))\n      .reduce((acc, i) => {\n        acc = acc.map(j => {\n          const x = j * 58 + i\n          i = x >> 8\n          return x\n        })\n        return acc\n      }, new Uint8Array(size))\n      .reverse()\n      .filter(\n        (\n          lastValue => value =>\n            (lastValue = lastValue || value)\n        )(false)\n      )\n  ])\n}\n\nmodule.exports = base58_to_binary\n", "'use strict'\nconst base58_chars = require('./base58_chars.js')\n\n/**\n * Generates a mapping between base58 and ascii.\n * @name create_base58_map\n * @kind function\n * @returns {Array} mapping between ascii and base58.\n * @ignore\n */\nconst create_base58_map = () => {\n  const base58M = Array(256).fill(-1)\n  for (let i = 0; i < base58_chars.length; ++i)\n    base58M[base58_chars.charCodeAt(i)] = i\n\n  return base58M\n}\n\nmodule.exports = create_base58_map\n", "'use strict'\n\nconst base58_chars = require('../private/base58_chars.js')\nconst create_base58_map = require('../private/create_base58_map.js')\n\nconst base58Map = create_base58_map()\n\n/**\n * Converts a [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) into a base58 string.\n * @kind function\n * @name binary_to_base58\n * @param {Uint8Array | Array} uint8array Unsigned integer.\n * @returns {base58_chars} The base58 string representation of the binary array.\n * @example <caption>Ways to `require`.</caption>\n * ```js\n * const { binary_to_base58 } = require(\"base58-js\")\n * ```\n * @example <caption>Ways to `import`.</caption>\n * ```js\n * import { binary_to_base58 } from 'base58-js'\n * ```\n * @example <caption>Usage.</caption>\n * ```js\n * const str = binary_to_base58([15, 239, 64])\n * console.log(str)\n * ```\n * Logged output will be 6MRy.\n */\nconst binary_to_base58 = uint8array => {\n  const result = []\n\n  for (const byte of uint8array) {\n    let carry = byte\n    for (let j = 0; j < result.length; ++j) {\n      const x = (base58Map[result[j]] << 8) + carry\n      result[j] = base58_chars.charCodeAt(x % 58)\n      carry = (x / 58) | 0\n    }\n    while (carry) {\n      result.push(base58_chars.charCodeAt(carry % 58))\n      carry = (carry / 58) | 0\n    }\n  }\n\n  for (const byte of uint8array)\n    if (byte) break\n    else result.push('1'.charCodeAt(0))\n\n  result.reverse()\n\n  return String.fromCharCode(...result)\n}\n\nmodule.exports = binary_to_base58\n", "'use strict'\n\nexports.base58_to_binary = require('./base58_to_binary.js')\nexports.binary_to_base58 = require('./binary_to_base58.js')\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nfunction parse(string, encoding, opts) {\n  var _opts$out;\n\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Build the character lookup table:\n  if (!encoding.codes) {\n    encoding.codes = {};\n\n    for (var i = 0; i < encoding.chars.length; ++i) {\n      encoding.codes[encoding.chars[i]] = i;\n    }\n  } // The string must have a whole number of bytes:\n\n\n  if (!opts.loose && string.length * encoding.bits & 7) {\n    throw new SyntaxError('Invalid padding');\n  } // Count the padding bytes:\n\n\n  var end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end; // If we get a whole number of bytes, there is too much padding:\n\n    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {\n      throw new SyntaxError('Invalid padding');\n    }\n  } // Allocate the output:\n\n\n  var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0); // Parse the data:\n\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  var written = 0; // Next byte to write\n\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = encoding.codes[string[_i]];\n\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[_i]);\n    } // Append the bits to the buffer:\n\n\n    buffer = buffer << encoding.bits | value;\n    bits += encoding.bits; // Write out some bits if the buffer has a byte's worth:\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  } // Verify that we have received just enough bits:\n\n\n  if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n}\nfunction stringify(data, encoding, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var _opts = opts,\n      _opts$pad = _opts.pad,\n      pad = _opts$pad === void 0 ? true : _opts$pad;\n  var mask = (1 << encoding.bits) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | 0xff & data[i];\n    bits += 8; // Write out as much as we can:\n\n    while (bits > encoding.bits) {\n      bits -= encoding.bits;\n      out += encoding.chars[mask & buffer >> bits];\n    }\n  } // Partial character:\n\n\n  if (bits) {\n    out += encoding.chars[mask & buffer << encoding.bits - bits];\n  } // Add padding characters until we hit a byte boundary:\n\n\n  if (pad) {\n    while (out.length * encoding.bits & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n}\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nvar base16Encoding = {\n  chars: '0123456789ABCDEF',\n  bits: 4\n};\nvar base32Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bits: 5\n};\nvar base32HexEncoding = {\n  chars: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bits: 5\n};\nvar base64Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bits: 6\n};\nvar base64UrlEncoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bits: 6\n};\nvar base16 = {\n  parse: function parse$1(string, opts) {\n    return parse(string.toUpperCase(), base16Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base16Encoding, opts);\n  }\n};\nvar base32 = {\n  parse: function parse$1(string, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return parse(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32Encoding, opts);\n  }\n};\nvar base32hex = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base32HexEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32HexEncoding, opts);\n  }\n};\nvar base64 = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64Encoding, opts);\n  }\n};\nvar base64url = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64UrlEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64UrlEncoding, opts);\n  }\n};\nvar codec = {\n  parse: parse,\n  stringify: stringify\n};\n\nexports.base16 = base16;\nexports.base32 = base32;\nexports.base32hex = base32hex;\nexports.base64 = base64;\nexports.base64url = base64url;\nexports.codec = codec;\n", "export default {};\n", "module.exports = assert\n\nclass AssertionError extends Error {}\nAssertionError.prototype.name = 'AssertionError'\n\n/**\n * Minimal assert function\n * @param  {any} t Value to check if falsy\n * @param  {string=} m Optional assertion error message\n * @throws {AssertionError}\n */\nfunction assert (t, m) {\n  if (!t) {\n    var err = new AssertionError(m)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, assert)\n    throw err\n  }\n}\n", "function byteLength (string) {\n  return string.length\n}\n\nfunction toString (buffer) {\n  const len = buffer.byteLength\n\n  let result = ''\n\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(buffer[i])\n  }\n\n  return result\n}\n\nfunction write (buffer, string, offset = 0, length = byteLength(string)) {\n  const len = Math.min(length, buffer.byteLength - offset)\n\n  for (let i = 0; i < len; i++) {\n    buffer[offset + i] = string.charCodeAt(i)\n  }\n\n  return len\n}\n\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n}\n", "const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\nconst codes = new Uint8Array(256)\n\nfor (let i = 0; i < alphabet.length; i++) {\n  codes[alphabet.charCodeAt(i)] = i\n}\n\ncodes[/* - */ 0x2d] = 62\ncodes[/* _ */ 0x5f] = 63\n\nfunction byteLength (string) {\n  let len = string.length\n\n  if (string.charCodeAt(len - 1) === 0x3d) len--\n  if (len > 1 && string.charCodeAt(len - 1) === 0x3d) len--\n\n  return (len * 3) >>> 2\n}\n\nfunction toString (buffer) {\n  const len = buffer.byteLength\n\n  let result = ''\n\n  for (let i = 0; i < len; i += 3) {\n    result += (\n      alphabet[buffer[i] >> 2] +\n      alphabet[((buffer[i] & 3) << 4) | (buffer[i + 1] >> 4)] +\n      alphabet[((buffer[i + 1] & 15) << 2) | (buffer[i + 2] >> 6)] +\n      alphabet[buffer[i + 2] & 63]\n    )\n  }\n\n  if (len % 3 === 2) {\n    result = result.substring(0, result.length - 1) + '='\n  } else if (len % 3 === 1) {\n    result = result.substring(0, result.length - 2) + '=='\n  }\n\n  return result\n};\n\nfunction write (buffer, string, offset = 0, length = byteLength(string)) {\n  const len = Math.min(length, buffer.byteLength - offset)\n\n  for (let i = 0, j = 0; i < len; i += 4) {\n    const a = codes[string.charCodeAt(i)]\n    const b = codes[string.charCodeAt(i + 1)]\n    const c = codes[string.charCodeAt(i + 2)]\n    const d = codes[string.charCodeAt(i + 3)]\n\n    buffer[j++] = (a << 2) | (b >> 4)\n    buffer[j++] = ((b & 15) << 4) | (c >> 2)\n    buffer[j++] = ((c & 3) << 6) | (d & 63)\n  }\n\n  return len\n};\n\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n}\n", "function byteLength (string) {\n  return string.length >>> 1\n}\n\nfunction toString (buffer) {\n  const len = buffer.byteLength\n\n  buffer = new DataView(buffer.buffer, buffer.byteOffset, len)\n\n  let result = ''\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    result += buffer.getUint32(i).toString(16).padStart(8, '0')\n  }\n\n  for (; i < len; i++) {\n    result += buffer.getUint8(i).toString(16).padStart(2, '0')\n  }\n\n  return result\n}\n\nfunction write (buffer, string, offset = 0, length = byteLength(string)) {\n  const len = Math.min(length, buffer.byteLength - offset)\n\n  for (let i = 0; i < len; i++) {\n    const a = hexValue(string.charCodeAt(i * 2))\n    const b = hexValue(string.charCodeAt(i * 2 + 1))\n\n    if (a === undefined || b === undefined) {\n      return buffer.subarray(0, i)\n    }\n\n    buffer[offset + i] = (a << 4) | b\n  }\n\n  return len\n}\n\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n}\n\nfunction hexValue (char) {\n  if (char >= 0x30 && char <= 0x39) return char - 0x30\n  if (char >= 0x41 && char <= 0x46) return char - 0x41 + 10\n  if (char >= 0x61 && char <= 0x66) return char - 0x61 + 10\n}\n", "function byteLength (string) {\n  let length = 0\n\n  for (let i = 0, n = string.length; i < n; i++) {\n    const code = string.charCodeAt(i)\n\n    if (code >= 0xd800 && code <= 0xdbff && i + 1 < n) {\n      const code = string.charCodeAt(i + 1)\n\n      if (code >= 0xdc00 && code <= 0xdfff) {\n        length += 4\n        i++\n        continue\n      }\n    }\n\n    if (code <= 0x7f) length += 1\n    else if (code <= 0x7ff) length += 2\n    else length += 3\n  }\n\n  return length\n}\n\nlet toString\n\nif (typeof TextDecoder !== 'undefined') {\n  const decoder = new TextDecoder()\n\n  toString = function toString (buffer) {\n    return decoder.decode(buffer)\n  }\n} else {\n  toString = function toString (buffer) {\n    const len = buffer.byteLength\n\n    let output = ''\n    let i = 0\n\n    while (i < len) {\n      let byte = buffer[i]\n\n      if (byte <= 0x7f) {\n        output += String.fromCharCode(byte)\n        i++\n        continue\n      }\n\n      let bytesNeeded = 0\n      let codePoint = 0\n\n      if (byte <= 0xdf) {\n        bytesNeeded = 1\n        codePoint = byte & 0x1f\n      } else if (byte <= 0xef) {\n        bytesNeeded = 2\n        codePoint = byte & 0x0f\n      } else if (byte <= 0xf4) {\n        bytesNeeded = 3\n        codePoint = byte & 0x07\n      }\n\n      if (len - i - bytesNeeded > 0) {\n        let k = 0\n\n        while (k < bytesNeeded) {\n          byte = buffer[i + k + 1]\n          codePoint = (codePoint << 6) | (byte & 0x3f)\n          k += 1\n        }\n      } else {\n        codePoint = 0xfffd\n        bytesNeeded = len - i\n      }\n\n      output += String.fromCodePoint(codePoint)\n      i += bytesNeeded + 1\n    }\n\n    return output\n  }\n}\n\nlet write\n\nif (typeof TextEncoder !== 'undefined') {\n  const encoder = new TextEncoder()\n\n  write = function write (buffer, string, offset = 0, length = byteLength(string)) {\n    const len = Math.min(length, buffer.byteLength - offset)\n    encoder.encodeInto(string, buffer.subarray(offset, offset + len))\n    return len\n  }\n} else {\n  write = function write (buffer, string, offset = 0, length = byteLength(string)) {\n    const len = Math.min(length, buffer.byteLength - offset)\n\n    buffer = buffer.subarray(offset, offset + len)\n\n    let i = 0\n    let j = 0\n\n    while (i < string.length) {\n      const code = string.codePointAt(i)\n\n      if (code <= 0x7f) {\n        buffer[j++] = code\n        i++\n        continue\n      }\n\n      let count = 0\n      let bits = 0\n\n      if (code <= 0x7ff) {\n        count = 6\n        bits = 0xc0\n      } else if (code <= 0xffff) {\n        count = 12\n        bits = 0xe0\n      } else if (code <= 0x1fffff) {\n        count = 18\n        bits = 0xf0\n      }\n\n      buffer[j++] = bits | (code >> count)\n      count -= 6\n\n      while (count >= 0) {\n        buffer[j++] = 0x80 | ((code >> count) & 0x3f)\n        count -= 6\n      }\n\n      i += code >= 0x10000 ? 2 : 1\n    }\n\n    return len\n  }\n}\n\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n}\n", "function byteLength (string) {\n  return string.length * 2\n}\n\nfunction toString (buffer) {\n  const len = buffer.byteLength\n\n  let result = ''\n\n  for (let i = 0; i < len - 1; i += 2) {\n    result += String.fromCharCode(buffer[i] + (buffer[i + 1] * 256))\n  }\n\n  return result\n}\n\nfunction write (buffer, string, offset = 0, length = byteLength(string)) {\n  const len = Math.min(length, buffer.byteLength - offset)\n\n  let units = len\n\n  for (let i = 0; i < string.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    const c = string.charCodeAt(i)\n    const hi = c >> 8\n    const lo = c % 256\n\n    buffer[offset + i * 2] = lo\n    buffer[offset + i * 2 + 1] = hi\n  }\n\n  return len\n}\n\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n}\n", "const ascii = require('./lib/ascii')\nconst base64 = require('./lib/base64')\nconst hex = require('./lib/hex')\nconst utf8 = require('./lib/utf8')\nconst utf16le = require('./lib/utf16le')\n\nconst LE = new Uint8Array(Uint16Array.of(0xff).buffer)[0] === 0xff\n\nfunction codecFor (encoding) {\n  switch (encoding) {\n    case 'ascii':\n      return ascii\n    case 'base64':\n      return base64\n    case 'hex':\n      return hex\n    case 'utf8':\n    case 'utf-8':\n    case undefined:\n      return utf8\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return utf16le\n    default:\n      throw new Error(`Unknown encoding: ${encoding}`)\n  }\n}\n\nfunction isBuffer (value) {\n  return value instanceof Uint8Array\n}\n\nfunction isEncoding (encoding) {\n  try {\n    codecFor(encoding)\n    return true\n  } catch {\n    return false\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  const buffer = new Uint8Array(size)\n  if (fill !== undefined) exports.fill(buffer, fill, 0, buffer.byteLength, encoding)\n  return buffer\n}\n\nfunction allocUnsafe (size) {\n  return new Uint8Array(size)\n}\n\nfunction allocUnsafeSlow (size) {\n  return new Uint8Array(size)\n}\n\nfunction byteLength (string, encoding) {\n  return codecFor(encoding).byteLength(string)\n}\n\nfunction compare (a, b) {\n  if (a === b) return 0\n\n  const len = Math.min(a.byteLength, b.byteLength)\n\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    const x = a.getUint32(i, LE)\n    const y = b.getUint32(i, LE)\n    if (x !== y) break\n  }\n\n  for (; i < len; i++) {\n    const x = a.getUint8(i)\n    const y = b.getUint8(i)\n    if (x < y) return -1\n    if (x > y) return 1\n  }\n\n  return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0\n}\n\nfunction concat (buffers, totalLength) {\n  if (totalLength === undefined) {\n    totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0)\n  }\n\n  const result = new Uint8Array(totalLength)\n\n  buffers.reduce(\n    (offset, buffer) => {\n      result.set(buffer, offset)\n      return offset + buffer.byteLength\n    },\n    0\n  )\n\n  return result\n}\n\nfunction copy (source, target, targetStart = 0, start = 0, end = source.byteLength) {\n  if (end > 0 && end < start) return 0\n  if (end === start) return 0\n  if (source.byteLength === 0 || target.byteLength === 0) return 0\n\n  if (targetStart < 0) throw new RangeError('targetStart is out of range')\n  if (start < 0 || start >= source.byteLength) throw new RangeError('sourceStart is out of range')\n  if (end < 0) throw new RangeError('sourceEnd is out of range')\n\n  if (targetStart >= target.byteLength) targetStart = target.byteLength\n  if (end > source.byteLength) end = source.byteLength\n  if (target.byteLength - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (source === target) {\n    target.copyWithin(targetStart, start, end)\n  } else {\n    target.set(source.subarray(start, end), targetStart)\n  }\n\n  return len\n}\n\nfunction equals (a, b) {\n  if (a === b) return true\n  if (a.byteLength !== b.byteLength) return false\n\n  const len = a.byteLength\n\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    if (a.getUint32(i, LE) !== b.getUint32(i, LE)) return false\n  }\n\n  for (; i < len; i++) {\n    if (a.getUint8(i) !== b.getUint8(i)) return false\n  }\n\n  return true\n}\n\nfunction fill (buffer, value, offset, end, encoding) {\n  if (typeof value === 'string') {\n    // fill(buffer, string, encoding)\n    if (typeof offset === 'string') {\n      encoding = offset\n      offset = 0\n      end = buffer.byteLength\n\n    // fill(buffer, string, offset, encoding)\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = buffer.byteLength\n    }\n  } else if (typeof val === 'number') {\n    value = value & 0xff\n  } else if (typeof val === 'boolean') {\n    value = +value\n  }\n\n  if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (offset === undefined) offset = 0\n  if (end === undefined) end = buffer.byteLength\n\n  if (end <= offset) return buffer\n\n  if (!value) value = 0\n\n  if (typeof value === 'number') {\n    for (let i = offset; i < end; ++i) {\n      buffer[i] = value\n    }\n  } else {\n    value = isBuffer(value) ? value : from(value, encoding)\n\n    const len = value.byteLength\n\n    for (let i = 0; i < end - offset; ++i) {\n      buffer[i + offset] = value[i % len]\n    }\n  }\n\n  return buffer\n}\n\nfunction from (value, encodingOrOffset, length) {\n  // from(string, encoding)\n  if (typeof value === 'string') return fromString(value, encodingOrOffset)\n\n  // from(array)\n  if (Array.isArray(value)) return fromArray(value)\n\n  // from(buffer)\n  if (ArrayBuffer.isView(value)) return fromBuffer(value)\n\n  // from(arrayBuffer[, byteOffset[, length]])\n  return fromArrayBuffer(value, encodingOrOffset, length)\n}\n\nfunction fromString (string, encoding) {\n  const codec = codecFor(encoding)\n  const buffer = new Uint8Array(codec.byteLength(string))\n  codec.write(buffer, string, 0, buffer.byteLength)\n  return buffer\n}\n\nfunction fromArray (array) {\n  const buffer = new Uint8Array(array.length)\n  buffer.set(array)\n  return buffer\n}\n\nfunction fromBuffer (buffer) {\n  const copy = new Uint8Array(buffer.byteLength)\n  copy.set(buffer)\n  return copy\n}\n\nfunction fromArrayBuffer (arrayBuffer, byteOffset, length) {\n  return new Uint8Array(arrayBuffer, byteOffset, length)\n}\n\nfunction includes (buffer, value, byteOffset, encoding) {\n  return indexOf(buffer, value, byteOffset, encoding) !== -1\n}\n\nfunction bidirectionalIndexOf (buffer, value, byteOffset, encoding, first) {\n  if (buffer.byteLength === 0) return -1\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset === undefined) {\n    byteOffset = first ? 0 : (buffer.length - 1)\n  } else if (byteOffset < 0) {\n    byteOffset += buffer.byteLength\n  }\n\n  if (byteOffset >= buffer.byteLength) {\n    if (first) return -1\n    else byteOffset = buffer.byteLength - 1\n  } else if (byteOffset < 0) {\n    if (first) byteOffset = 0\n    else return -1\n  }\n\n  if (typeof value === 'string') {\n    value = from(value, encoding)\n  } else if (typeof value === 'number') {\n    value = value & 0xff\n\n    if (first) {\n      return buffer.indexOf(value, byteOffset)\n    } else {\n      return buffer.lastIndexOf(value, byteOffset)\n    }\n  }\n\n  if (value.byteLength === 0) return -1\n\n  if (first) {\n    let foundIndex = -1\n\n    for (let i = byteOffset; i < buffer.byteLength; i++) {\n      if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === value.byteLength) return foundIndex\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + value.byteLength > buffer.byteLength) {\n      byteOffset = buffer.byteLength - value.byteLength\n    }\n\n    for (let i = byteOffset; i >= 0; i--) {\n      let found = true\n\n      for (let j = 0; j < value.byteLength; j++) {\n        if (buffer[i + j] !== value[j]) {\n          found = false\n          break\n        }\n      }\n\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nfunction indexOf (buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, true /* first */)\n}\n\nfunction lastIndexOf (buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, false /* last */)\n}\n\nfunction swap (buffer, n, m) {\n  const i = buffer[n]\n  buffer[n] = buffer[m]\n  buffer[m] = i\n}\n\nfunction swap16 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')\n\n  for (let i = 0; i < len; i += 2) swap(buffer, i, i + 1)\n\n  return buffer\n}\n\nfunction swap32 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')\n\n  for (let i = 0; i < len; i += 4) {\n    swap(buffer, i, i + 3)\n    swap(buffer, i + 1, i + 2)\n  }\n\n  return buffer\n}\n\nfunction swap64 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')\n\n  for (let i = 0; i < len; i += 8) {\n    swap(buffer, i, i + 7)\n    swap(buffer, i + 1, i + 6)\n    swap(buffer, i + 2, i + 5)\n    swap(buffer, i + 3, i + 4)\n  }\n\n  return buffer\n}\n\nfunction toBuffer (buffer) {\n  return buffer\n}\n\nfunction toString (buffer, encoding, start = 0, end = buffer.byteLength) {\n  const len = buffer.byteLength\n\n  if (start >= len) return ''\n  if (end <= start) return ''\n  if (start < 0) start = 0\n  if (end > len) end = len\n\n  if (start !== 0 || end < len) buffer = buffer.subarray(start, end)\n\n  return codecFor(encoding).toString(buffer)\n}\n\nfunction write (buffer, string, offset, length, encoding) {\n  // write(buffer, string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n\n  // write(buffer, string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    offset = undefined\n\n  // write(buffer, string, offset, encoding)\n  } else if (encoding === undefined && typeof length === 'string') {\n    encoding = length\n    length = undefined\n  }\n\n  return codecFor(encoding).write(buffer, string, offset, length)\n}\n\nfunction writeDoubleLE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setFloat64(offset, value, true)\n\n  return offset + 8\n}\n\nfunction writeFloatLE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setFloat32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction writeUInt32LE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setUint32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction writeInt32LE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setInt32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction readDoubleLE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getFloat64(offset, true)\n}\n\nfunction readFloatLE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getFloat32(offset, true)\n}\n\nfunction readUInt32LE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getUint32(offset, true)\n}\n\nfunction readInt32LE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getInt32(offset, true)\n}\n\nmodule.exports = exports = {\n  isBuffer,\n  isEncoding,\n  alloc,\n  allocUnsafe,\n  allocUnsafeSlow,\n  byteLength,\n  compare,\n  concat,\n  copy,\n  equals,\n  fill,\n  from,\n  includes,\n  indexOf,\n  lastIndexOf,\n  swap16,\n  swap32,\n  swap64,\n  toBuffer,\n  toString,\n  write,\n  writeDoubleLE,\n  writeFloatLE,\n  writeUInt32LE,\n  writeInt32LE,\n  readDoubleLE,\n  readFloatLE,\n  readUInt32LE,\n  readInt32LE\n}\n", "var __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __toBinary = /* @__PURE__ */ (() => {\n  var table = new Uint8Array(128);\n  for (var i = 0; i < 64; i++)\n    table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;\n  return (base64) => {\n    var n = base64.length, bytes2 = new Uint8Array((n - (base64[n - 1] == \"=\") - (base64[n - 2] == \"=\")) * 3 / 4 | 0);\n    for (var i2 = 0, j = 0; i2 < n; ) {\n      var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];\n      var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];\n      bytes2[j++] = c0 << 2 | c1 >> 4;\n      bytes2[j++] = c1 << 4 | c2 >> 2;\n      bytes2[j++] = c2 << 6 | c3;\n    }\n    return bytes2;\n  };\n})();\n\n// wasm-binary:./blake2b.wat\nvar require_blake2b = __commonJS({\n  \"wasm-binary:./blake2b.wat\"(exports2, module2) {\n    module2.exports = __toBinary(\"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\");\n  }\n});\n\n// wasm-module:./blake2b.wat\nvar bytes = require_blake2b();\nvar compiled = WebAssembly.compile(bytes);\nmodule.exports = async (imports) => {\n  const instance = await WebAssembly.instantiate(await compiled, imports);\n  return instance.exports;\n};\n", "var assert = require('nanoassert')\nvar b4a = require('b4a')\n\nvar wasm = null\nvar wasmPromise = typeof WebAssembly !== \"undefined\" && require('./blake2b')().then(mod => {\n  wasm = mod\n})\n\nvar head = 64\nvar freeList = []\n\nmodule.exports = Blake2b\nvar BYTES_MIN = module.exports.BYTES_MIN = 16\nvar BYTES_MAX = module.exports.BYTES_MAX = 64\nvar BYTES = module.exports.BYTES = 32\nvar KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16\nvar KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64\nvar KEYBYTES = module.exports.KEYBYTES = 32\nvar SALTBYTES = module.exports.SALTBYTES = 16\nvar PERSONALBYTES = module.exports.PERSONALBYTES = 16\n\nfunction Blake2b (digestLength, key, salt, personal, noAssert) {\n  if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert)\n  if (!wasm) throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)')\n  if (!digestLength) digestLength = 32\n\n  if (noAssert !== true) {\n    assert(digestLength >= BYTES_MIN, 'digestLength must be at least ' + BYTES_MIN + ', was given ' + digestLength)\n    assert(digestLength <= BYTES_MAX, 'digestLength must be at most ' + BYTES_MAX + ', was given ' + digestLength)\n    if (key != null) {\n      assert(key instanceof Uint8Array, 'key must be Uint8Array or Buffer')\n      assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length)\n      assert(key.length <= KEYBYTES_MAX, 'key must be at least ' + KEYBYTES_MAX + ', was given ' + key.length)\n    }\n    if (salt != null) {\n      assert(salt instanceof Uint8Array, 'salt must be Uint8Array or Buffer')\n      assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length)\n    }\n    if (personal != null) {\n      assert(personal instanceof Uint8Array, 'personal must be Uint8Array or Buffer')\n      assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length)\n    }\n  }\n\n  if (!freeList.length) {\n    freeList.push(head)\n    head += 216\n  }\n\n  this.digestLength = digestLength\n  this.finalized = false\n  this.pointer = freeList.pop()\n  this._memory = new Uint8Array(wasm.memory.buffer)\n\n  this._memory.fill(0, 0, 64)\n  this._memory[0] = this.digestLength\n  this._memory[1] = key ? key.length : 0\n  this._memory[2] = 1 // fanout\n  this._memory[3] = 1 // depth\n\n  if (salt) this._memory.set(salt, 32)\n  if (personal) this._memory.set(personal, 48)\n\n  if (this.pointer + 216 > this._memory.length) this._realloc(this.pointer + 216) // we need 216 bytes for the state\n  wasm.blake2b_init(this.pointer, this.digestLength)\n\n  if (key) {\n    this.update(key)\n    this._memory.fill(0, head, head + key.length) // whiteout key\n    this._memory[this.pointer + 200] = 128\n  }\n}\n\nBlake2b.prototype._realloc = function (size) {\n  wasm.memory.grow(Math.max(0, Math.ceil(Math.abs(size - this._memory.length) / 65536)))\n  this._memory = new Uint8Array(wasm.memory.buffer)\n}\n\nBlake2b.prototype.update = function (input) {\n  assert(this.finalized === false, 'Hash instance finalized')\n  assert(input instanceof Uint8Array, 'input must be Uint8Array or Buffer')\n\n  if (head + input.length > this._memory.length) this._realloc(head + input.length)\n  this._memory.set(input, head)\n  wasm.blake2b_update(this.pointer, head, head + input.length)\n  return this\n}\n\nBlake2b.prototype.digest = function (enc) {\n  assert(this.finalized === false, 'Hash instance finalized')\n  this.finalized = true\n\n  freeList.push(this.pointer)\n  wasm.blake2b_final(this.pointer)\n\n  if (!enc || enc === 'binary') {\n    return this._memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength)\n  }\n\n  if (typeof enc === 'string') {\n    return b4a.toString(this._memory, enc, this.pointer + 128, this.pointer + 128 + this.digestLength)\n  }\n\n  assert(enc instanceof Uint8Array && enc.length >= this.digestLength, 'input must be Uint8Array or Buffer')\n  for (var i = 0; i < this.digestLength; i++) {\n    enc[i] = this._memory[this.pointer + 128 + i]\n  }\n\n  return enc\n}\n\n// libsodium compat\nBlake2b.prototype.final = Blake2b.prototype.digest\n\nBlake2b.WASM = wasm\nBlake2b.SUPPORTED = typeof WebAssembly !== 'undefined'\n\nBlake2b.ready = function (cb) {\n  if (!cb) cb = noop\n  if (!wasmPromise) return cb(new Error('WebAssembly not supported'))\n  return wasmPromise.then(() => cb(), cb)\n}\n\nBlake2b.prototype.ready = Blake2b.ready\n\nBlake2b.prototype.getPartialHash = function () {\n  return this._memory.slice(this.pointer, this.pointer + 216);\n}\n\nBlake2b.prototype.setPartialHash = function (ph) {\n  this._memory.set(ph, this.pointer);\n}\n\nfunction noop () {}\n", "\nconst polyfill = require('fs')\n\nif (polyfill && polyfill.default) {\n    module.exports = polyfill.default\n    for (let k in polyfill) {\n        module.exports[k] = polyfill[k]\n    }\n} else if (polyfill)  {\n    module.exports = polyfill\n}\n\n\n", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexport function resolve() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : '/';\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexport function normalize(path) {\n  var isPathAbsolute = isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isPathAbsolute).join('/');\n\n  if (!path && !isPathAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isPathAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexport function isAbsolute(path) {\n  return path.charAt(0) === '/';\n}\n\n// posix version\nexport function join() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n}\n\n\n// path.relative(from, to)\n// posix version\nexport function relative(from, to) {\n  from = resolve(from).substr(1);\n  to = resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n}\n\nexport var sep = '/';\nexport var delimiter = ':';\n\nexport function dirname(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n}\n\nexport function basename(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n}\n\n\nexport function extname(path) {\n  return splitPath(path)[3];\n}\nexport default {\n  extname: extname,\n  basename: basename,\n  dirname: dirname,\n  sep: sep,\n  delimiter: delimiter,\n  relative: relative,\n  join: join,\n  isAbsolute: isAbsolute,\n  normalize: normalize,\n  resolve: resolve\n};\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b' ?\n    function (str, start, len) { return str.substr(start, len) } :\n    function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n", "\nconst polyfill = require('path')\n\nif (polyfill && polyfill.default) {\n    module.exports = polyfill.default\n    for (let k in polyfill) {\n        module.exports[k] = polyfill[k]\n    }\n} else if (polyfill)  {\n    module.exports = polyfill\n}\n\n\n", "/*\n * EJS Embedded JavaScript templates\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n/**\n * Private utility functions\n * @module utils\n * @private\n */\n\n'use strict';\n\nvar regExpChars = /[|\\\\{}()[\\]^$+*?.]/g;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar hasOwn = function (obj, key) { return hasOwnProperty.apply(obj, [key]); };\n\n/**\n * Escape characters reserved in regular expressions.\n *\n * If `string` is `undefined` or `null`, the empty string is returned.\n *\n * @param {String} string Input string\n * @return {String} Escaped string\n * @static\n * @private\n */\nexports.escapeRegExpChars = function (string) {\n  // istanbul ignore if\n  if (!string) {\n    return '';\n  }\n  return String(string).replace(regExpChars, '\\\\$&');\n};\n\nvar _ENCODE_HTML_RULES = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&#34;',\n  \"'\": '&#39;'\n};\nvar _MATCH_HTML = /[&<>'\"]/g;\n\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n}\n\n/**\n * Stringified version of constants used by {@link module:utils.escapeXML}.\n *\n * It is used in the process of generating {@link ClientFunction}s.\n *\n * @readonly\n * @type {String}\n */\n\nvar escapeFuncStr =\n  'var _ENCODE_HTML_RULES = {\\n'\n+ '      \"&\": \"&amp;\"\\n'\n+ '    , \"<\": \"&lt;\"\\n'\n+ '    , \">\": \"&gt;\"\\n'\n+ '    , \\'\"\\': \"&#34;\"\\n'\n+ '    , \"\\'\": \"&#39;\"\\n'\n+ '    }\\n'\n+ '  , _MATCH_HTML = /[&<>\\'\"]/g;\\n'\n+ 'function encode_char(c) {\\n'\n+ '  return _ENCODE_HTML_RULES[c] || c;\\n'\n+ '};\\n';\n\n/**\n * Escape characters reserved in XML.\n *\n * If `markup` is `undefined` or `null`, the empty string is returned.\n *\n * @implements {EscapeCallback}\n * @param {String} markup Input string\n * @return {String} Escaped string\n * @static\n * @private\n */\n\nexports.escapeXML = function (markup) {\n  return markup == undefined\n    ? ''\n    : String(markup)\n      .replace(_MATCH_HTML, encode_char);\n};\nexports.escapeXML.toString = function () {\n  return Function.prototype.toString.call(this) + ';\\n' + escapeFuncStr;\n};\n\n/**\n * Naive copy of properties from one object to another.\n * Does not recurse into non-scalar properties\n * Does not check to see if the property has a value before copying\n *\n * @param  {Object} to   Destination object\n * @param  {Object} from Source object\n * @return {Object}      Destination object\n * @static\n * @private\n */\nexports.shallowCopy = function (to, from) {\n  from = from || {};\n  if ((to !== null) && (to !== undefined)) {\n    for (var p in from) {\n      if (!hasOwn(from, p)) {\n        continue;\n      }\n      if (p === '__proto__' || p === 'constructor') {\n        continue;\n      }\n      to[p] = from[p];\n    }\n  }\n  return to;\n};\n\n/**\n * Naive copy of a list of key names, from one object to another.\n * Only copies property if it is actually defined\n * Does not recurse into non-scalar properties\n *\n * @param  {Object} to   Destination object\n * @param  {Object} from Source object\n * @param  {Array} list List of properties to copy\n * @return {Object}      Destination object\n * @static\n * @private\n */\nexports.shallowCopyFromList = function (to, from, list) {\n  list = list || [];\n  from = from || {};\n  if ((to !== null) && (to !== undefined)) {\n    for (var i = 0; i < list.length; i++) {\n      var p = list[i];\n      if (typeof from[p] != 'undefined') {\n        if (!hasOwn(from, p)) {\n          continue;\n        }\n        if (p === '__proto__' || p === 'constructor') {\n          continue;\n        }\n        to[p] = from[p];\n      }\n    }\n  }\n  return to;\n};\n\n/**\n * Simple in-process cache implementation. Does not implement limits of any\n * sort.\n *\n * @implements {Cache}\n * @static\n * @private\n */\nexports.cache = {\n  _data: {},\n  set: function (key, val) {\n    this._data[key] = val;\n  },\n  get: function (key) {\n    return this._data[key];\n  },\n  remove: function (key) {\n    delete this._data[key];\n  },\n  reset: function () {\n    this._data = {};\n  }\n};\n\n/**\n * Transforms hyphen case variable into camel case.\n *\n * @param {String} string Hyphen case string\n * @return {String} Camel case string\n * @static\n * @private\n */\nexports.hyphenToCamel = function (str) {\n  return str.replace(/-[a-z]/g, function (match) { return match[1].toUpperCase(); });\n};\n\n/**\n * Returns a null-prototype object in runtimes that support it\n *\n * @return {Object} Object, prototype will be set to null where possible\n * @static\n * @private\n */\nexports.createNullProtoObjWherePossible = (function () {\n  if (typeof Object.create == 'function') {\n    return function () {\n      return Object.create(null);\n    };\n  }\n  if (!({__proto__: null} instanceof Object)) {\n    return function () {\n      return {__proto__: null};\n    };\n  }\n  // Not possible, just pass through\n  return function () {\n    return {};\n  };\n})();\n\n\n", "/*\n * EJS Embedded JavaScript templates\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n'use strict';\n\n/**\n * @file Embedded JavaScript templating engine. {@link http://ejs.co}\n * @author Matthew Eernisse <mde@fleegix.org>\n * @author Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\n * @project EJS\n * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}\n */\n\n/**\n * EJS internal functions.\n *\n * Technically this \"module\" lies in the same file as {@link module:ejs}, for\n * the sake of organization all the private functions re grouped into this\n * module.\n *\n * @module ejs-internal\n * @private\n */\n\n/**\n * Embedded JavaScript templating engine.\n *\n * @module ejs\n * @public\n */\n\n\nvar fs = require('fs');\nvar path = require('path');\nvar utils = require('./utils');\n\nvar scopeOptionWarned = false;\n/** @type {string} */\nvar _VERSION_STRING = require('../package.json').version;\nvar _DEFAULT_OPEN_DELIMITER = '<';\nvar _DEFAULT_CLOSE_DELIMITER = '>';\nvar _DEFAULT_DELIMITER = '%';\nvar _DEFAULT_LOCALS_NAME = 'locals';\nvar _NAME = 'ejs';\nvar _REGEX_STRING = '(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)';\nvar _OPTS_PASSABLE_WITH_DATA = ['delimiter', 'scope', 'context', 'debug', 'compileDebug',\n  'client', '_with', 'rmWhitespace', 'strict', 'filename', 'async'];\n// We don't allow 'cache' option to be passed in the data obj for\n// the normal `render` call, but this is where Express 2 & 3 put it\n// so we make an exception for `renderFile`\nvar _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat('cache');\nvar _BOM = /^\\uFEFF/;\nvar _JS_IDENTIFIER = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\n\n/**\n * EJS template function cache. This can be a LRU object from lru-cache NPM\n * module. By default, it is {@link module:utils.cache}, a simple in-process\n * cache that grows continuously.\n *\n * @type {Cache}\n */\n\nexports.cache = utils.cache;\n\n/**\n * Custom file loader. Useful for template preprocessing or restricting access\n * to a certain part of the filesystem.\n *\n * @type {fileLoader}\n */\n\nexports.fileLoader = fs.readFileSync;\n\n/**\n * Name of the object containing the locals.\n *\n * This variable is overridden by {@link Options}`.localsName` if it is not\n * `undefined`.\n *\n * @type {String}\n * @public\n */\n\nexports.localsName = _DEFAULT_LOCALS_NAME;\n\n/**\n * Promise implementation -- defaults to the native implementation if available\n * This is mostly just for testability\n *\n * @type {PromiseConstructorLike}\n * @public\n */\n\nexports.promiseImpl = (new Function('return this;'))().Promise;\n\n/**\n * Get the path to the included file from the parent file path and the\n * specified path.\n *\n * @param {String}  name     specified path\n * @param {String}  filename parent file path\n * @param {Boolean} [isDir=false] whether the parent file path is a directory\n * @return {String}\n */\nexports.resolveInclude = function(name, filename, isDir) {\n  var dirname = path.dirname;\n  var extname = path.extname;\n  var resolve = path.resolve;\n  var includePath = resolve(isDir ? filename : dirname(filename), name);\n  var ext = extname(name);\n  if (!ext) {\n    includePath += '.ejs';\n  }\n  return includePath;\n};\n\n/**\n * Try to resolve file path on multiple directories\n *\n * @param  {String}        name  specified path\n * @param  {Array<String>} paths list of possible parent directory paths\n * @return {String}\n */\nfunction resolvePaths(name, paths) {\n  var filePath;\n  if (paths.some(function (v) {\n    filePath = exports.resolveInclude(name, v, true);\n    return fs.existsSync(filePath);\n  })) {\n    return filePath;\n  }\n}\n\n/**\n * Get the path to the included file by Options\n *\n * @param  {String}  path    specified path\n * @param  {Options} options compilation options\n * @return {String}\n */\nfunction getIncludePath(path, options) {\n  var includePath;\n  var filePath;\n  var views = options.views;\n  var match = /^[A-Za-z]+:\\\\|^\\//.exec(path);\n\n  // Abs path\n  if (match && match.length) {\n    path = path.replace(/^\\/*/, '');\n    if (Array.isArray(options.root)) {\n      includePath = resolvePaths(path, options.root);\n    } else {\n      includePath = exports.resolveInclude(path, options.root || '/', true);\n    }\n  }\n  // Relative paths\n  else {\n    // Look relative to a passed filename first\n    if (options.filename) {\n      filePath = exports.resolveInclude(path, options.filename);\n      if (fs.existsSync(filePath)) {\n        includePath = filePath;\n      }\n    }\n    // Then look in any views directories\n    if (!includePath && Array.isArray(views)) {\n      includePath = resolvePaths(path, views);\n    }\n    if (!includePath && typeof options.includer !== 'function') {\n      throw new Error('Could not find the include file \"' +\n          options.escapeFunction(path) + '\"');\n    }\n  }\n  return includePath;\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `template` is not set, the file specified in `options.filename` will be\n * read.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @memberof module:ejs-internal\n * @param {Options} options   compilation options\n * @param {String} [template] template source\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `options.client`, either type might be returned.\n * @static\n */\n\nfunction handleCache(options, template) {\n  var func;\n  var filename = options.filename;\n  var hasTemplate = arguments.length > 1;\n\n  if (options.cache) {\n    if (!filename) {\n      throw new Error('cache option requires a filename');\n    }\n    func = exports.cache.get(filename);\n    if (func) {\n      return func;\n    }\n    if (!hasTemplate) {\n      template = fileLoader(filename).toString().replace(_BOM, '');\n    }\n  }\n  else if (!hasTemplate) {\n    // istanbul ignore if: should not happen at all\n    if (!filename) {\n      throw new Error('Internal EJS error: no file name or template '\n                    + 'provided');\n    }\n    template = fileLoader(filename).toString().replace(_BOM, '');\n  }\n  func = exports.compile(template, options);\n  if (options.cache) {\n    exports.cache.set(filename, func);\n  }\n  return func;\n}\n\n/**\n * Try calling handleCache with the given options and data and call the\n * callback with the result. If an error occurs, call the callback with\n * the error. Used by renderFile().\n *\n * @memberof module:ejs-internal\n * @param {Options} options    compilation options\n * @param {Object} data        template data\n * @param {RenderFileCallback} cb callback\n * @static\n */\n\nfunction tryHandleCache(options, data, cb) {\n  var result;\n  if (!cb) {\n    if (typeof exports.promiseImpl == 'function') {\n      return new exports.promiseImpl(function (resolve, reject) {\n        try {\n          result = handleCache(options)(data);\n          resolve(result);\n        }\n        catch (err) {\n          reject(err);\n        }\n      });\n    }\n    else {\n      throw new Error('Please provide a callback function');\n    }\n  }\n  else {\n    try {\n      result = handleCache(options)(data);\n    }\n    catch (err) {\n      return cb(err);\n    }\n\n    cb(null, result);\n  }\n}\n\n/**\n * fileLoader is independent\n *\n * @param {String} filePath ejs file path.\n * @return {String} The contents of the specified file.\n * @static\n */\n\nfunction fileLoader(filePath){\n  return exports.fileLoader(filePath);\n}\n\n/**\n * Get the template function.\n *\n * If `options.cache` is `true`, then the template is cached.\n *\n * @memberof module:ejs-internal\n * @param {String}  path    path for the specified file\n * @param {Options} options compilation options\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `options.client`, either type might be returned\n * @static\n */\n\nfunction includeFile(path, options) {\n  var opts = utils.shallowCopy(utils.createNullProtoObjWherePossible(), options);\n  opts.filename = getIncludePath(path, opts);\n  if (typeof options.includer === 'function') {\n    var includerResult = options.includer(path, opts.filename);\n    if (includerResult) {\n      if (includerResult.filename) {\n        opts.filename = includerResult.filename;\n      }\n      if (includerResult.template) {\n        return handleCache(opts, includerResult.template);\n      }\n    }\n  }\n  return handleCache(opts);\n}\n\n/**\n * Re-throw the given `err` in context to the `str` of ejs, `filename`, and\n * `lineno`.\n *\n * @implements {RethrowCallback}\n * @memberof module:ejs-internal\n * @param {Error}  err      Error object\n * @param {String} str      EJS source\n * @param {String} flnm     file name of the EJS file\n * @param {Number} lineno   line number of the error\n * @param {EscapeCallback} esc\n * @static\n */\n\nfunction rethrow(err, str, flnm, lineno, esc) {\n  var lines = str.split('\\n');\n  var start = Math.max(lineno - 3, 0);\n  var end = Math.min(lines.length, lineno + 3);\n  var filename = esc(flnm);\n  // Error context\n  var context = lines.slice(start, end).map(function (line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? ' >> ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'ejs') + ':'\n    + lineno + '\\n'\n    + context + '\\n\\n'\n    + err.message;\n\n  throw err;\n}\n\nfunction stripSemi(str){\n  return str.replace(/;(\\s*$)/, '$1');\n}\n\n/**\n * Compile the given `str` of ejs into a template function.\n *\n * @param {String}  template EJS template\n *\n * @param {Options} [opts] compilation options\n *\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `opts.client`, either type might be returned.\n * Note that the return type of the function also depends on the value of `opts.async`.\n * @public\n */\n\nexports.compile = function compile(template, opts) {\n  var templ;\n\n  // v1 compat\n  // 'scope' is 'context'\n  // FIXME: Remove this in a future version\n  if (opts && opts.scope) {\n    if (!scopeOptionWarned){\n      console.warn('`scope` option is deprecated and will be removed in EJS 3');\n      scopeOptionWarned = true;\n    }\n    if (!opts.context) {\n      opts.context = opts.scope;\n    }\n    delete opts.scope;\n  }\n  templ = new Template(template, opts);\n  return templ.compile();\n};\n\n/**\n * Render the given `template` of ejs.\n *\n * If you would like to include options but not data, you need to explicitly\n * call this function with `data` being an empty object or `null`.\n *\n * @param {String}   template EJS template\n * @param {Object}  [data={}] template data\n * @param {Options} [opts={}] compilation and rendering options\n * @return {(String|Promise<String>)}\n * Return value type depends on `opts.async`.\n * @public\n */\n\nexports.render = function (template, d, o) {\n  var data = d || utils.createNullProtoObjWherePossible();\n  var opts = o || utils.createNullProtoObjWherePossible();\n\n  // No options object -- if there are optiony names\n  // in the data, copy them to options\n  if (arguments.length == 2) {\n    utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);\n  }\n\n  return handleCache(opts, template)(data);\n};\n\n/**\n * Render an EJS file at the given `path` and callback `cb(err, str)`.\n *\n * If you would like to include options but not data, you need to explicitly\n * call this function with `data` being an empty object or `null`.\n *\n * @param {String}             path     path to the EJS file\n * @param {Object}            [data={}] template data\n * @param {Options}           [opts={}] compilation and rendering options\n * @param {RenderFileCallback} cb callback\n * @public\n */\n\nexports.renderFile = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var filename = args.shift();\n  var cb;\n  var opts = {filename: filename};\n  var data;\n  var viewOpts;\n\n  // Do we have a callback?\n  if (typeof arguments[arguments.length - 1] == 'function') {\n    cb = args.pop();\n  }\n  // Do we have data/opts?\n  if (args.length) {\n    // Should always have data obj\n    data = args.shift();\n    // Normal passed opts (data obj + opts obj)\n    if (args.length) {\n      // Use shallowCopy so we don't pollute passed in opts obj with new vals\n      utils.shallowCopy(opts, args.pop());\n    }\n    // Special casing for Express (settings + opts-in-data)\n    else {\n      // Express 3 and 4\n      if (data.settings) {\n        // Pull a few things from known locations\n        if (data.settings.views) {\n          opts.views = data.settings.views;\n        }\n        if (data.settings['view cache']) {\n          opts.cache = true;\n        }\n        // Undocumented after Express 2, but still usable, esp. for\n        // items that are unsafe to be passed along with data, like `root`\n        viewOpts = data.settings['view options'];\n        if (viewOpts) {\n          utils.shallowCopy(opts, viewOpts);\n        }\n      }\n      // Express 2 and lower, values set in app.locals, or people who just\n      // want to pass options in their data. NOTE: These values will override\n      // anything previously set in settings  or settings['view options']\n      utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);\n    }\n    opts.filename = filename;\n  }\n  else {\n    data = utils.createNullProtoObjWherePossible();\n  }\n\n  return tryHandleCache(opts, data, cb);\n};\n\n/**\n * Clear intermediate JavaScript cache. Calls {@link Cache#reset}.\n * @public\n */\n\n/**\n * EJS template class\n * @public\n */\nexports.Template = Template;\n\nexports.clearCache = function () {\n  exports.cache.reset();\n};\n\nfunction Template(text, opts) {\n  opts = opts || utils.createNullProtoObjWherePossible();\n  var options = utils.createNullProtoObjWherePossible();\n  this.templateText = text;\n  /** @type {string | null} */\n  this.mode = null;\n  this.truncate = false;\n  this.currentLine = 1;\n  this.source = '';\n  options.client = opts.client || false;\n  options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;\n  options.compileDebug = opts.compileDebug !== false;\n  options.debug = !!opts.debug;\n  options.filename = opts.filename;\n  options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;\n  options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;\n  options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;\n  options.strict = opts.strict || false;\n  options.context = opts.context;\n  options.cache = opts.cache || false;\n  options.rmWhitespace = opts.rmWhitespace;\n  options.root = opts.root;\n  options.includer = opts.includer;\n  options.outputFunctionName = opts.outputFunctionName;\n  options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;\n  options.views = opts.views;\n  options.async = opts.async;\n  options.destructuredLocals = opts.destructuredLocals;\n  options.legacyInclude = typeof opts.legacyInclude != 'undefined' ? !!opts.legacyInclude : true;\n\n  if (options.strict) {\n    options._with = false;\n  }\n  else {\n    options._with = typeof opts._with != 'undefined' ? opts._with : true;\n  }\n\n  this.opts = options;\n\n  this.regex = this.createRegex();\n}\n\nTemplate.modes = {\n  EVAL: 'eval',\n  ESCAPED: 'escaped',\n  RAW: 'raw',\n  COMMENT: 'comment',\n  LITERAL: 'literal'\n};\n\nTemplate.prototype = {\n  createRegex: function () {\n    var str = _REGEX_STRING;\n    var delim = utils.escapeRegExpChars(this.opts.delimiter);\n    var open = utils.escapeRegExpChars(this.opts.openDelimiter);\n    var close = utils.escapeRegExpChars(this.opts.closeDelimiter);\n    str = str.replace(/%/g, delim)\n      .replace(/</g, open)\n      .replace(/>/g, close);\n    return new RegExp(str);\n  },\n\n  compile: function () {\n    /** @type {string} */\n    var src;\n    /** @type {ClientFunction} */\n    var fn;\n    var opts = this.opts;\n    var prepended = '';\n    var appended = '';\n    /** @type {EscapeCallback} */\n    var escapeFn = opts.escapeFunction;\n    /** @type {FunctionConstructor} */\n    var ctor;\n    /** @type {string} */\n    var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : 'undefined';\n\n    if (!this.source) {\n      this.generateSource();\n      prepended +=\n        '  var __output = \"\";\\n' +\n        '  function __append(s) { if (s !== undefined && s !== null) __output += s }\\n';\n      if (opts.outputFunctionName) {\n        if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) {\n          throw new Error('outputFunctionName is not a valid JS identifier.');\n        }\n        prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\\n';\n      }\n      if (opts.localsName && !_JS_IDENTIFIER.test(opts.localsName)) {\n        throw new Error('localsName is not a valid JS identifier.');\n      }\n      if (opts.destructuredLocals && opts.destructuredLocals.length) {\n        var destructuring = '  var __locals = (' + opts.localsName + ' || {}),\\n';\n        for (var i = 0; i < opts.destructuredLocals.length; i++) {\n          var name = opts.destructuredLocals[i];\n          if (!_JS_IDENTIFIER.test(name)) {\n            throw new Error('destructuredLocals[' + i + '] is not a valid JS identifier.');\n          }\n          if (i > 0) {\n            destructuring += ',\\n  ';\n          }\n          destructuring += name + ' = __locals.' + name;\n        }\n        prepended += destructuring + ';\\n';\n      }\n      if (opts._with !== false) {\n        prepended +=  '  with (' + opts.localsName + ' || {}) {' + '\\n';\n        appended += '  }' + '\\n';\n      }\n      appended += '  return __output;' + '\\n';\n      this.source = prepended + this.source + appended;\n    }\n\n    if (opts.compileDebug) {\n      src = 'var __line = 1' + '\\n'\n        + '  , __lines = ' + JSON.stringify(this.templateText) + '\\n'\n        + '  , __filename = ' + sanitizedFilename + ';' + '\\n'\n        + 'try {' + '\\n'\n        + this.source\n        + '} catch (e) {' + '\\n'\n        + '  rethrow(e, __lines, __filename, __line, escapeFn);' + '\\n'\n        + '}' + '\\n';\n    }\n    else {\n      src = this.source;\n    }\n\n    if (opts.client) {\n      src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\\n' + src;\n      if (opts.compileDebug) {\n        src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src;\n      }\n    }\n\n    if (opts.strict) {\n      src = '\"use strict\";\\n' + src;\n    }\n    if (opts.debug) {\n      console.log(src);\n    }\n    if (opts.compileDebug && opts.filename) {\n      src = src + '\\n'\n        + '//# sourceURL=' + sanitizedFilename + '\\n';\n    }\n\n    try {\n      if (opts.async) {\n        // Have to use generated function for this, since in envs without support,\n        // it breaks in parsing\n        try {\n          ctor = (new Function('return (async function(){}).constructor;'))();\n        }\n        catch(e) {\n          if (e instanceof SyntaxError) {\n            throw new Error('This environment does not support async/await');\n          }\n          else {\n            throw e;\n          }\n        }\n      }\n      else {\n        ctor = Function;\n      }\n      fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src);\n    }\n    catch(e) {\n      // istanbul ignore else\n      if (e instanceof SyntaxError) {\n        if (opts.filename) {\n          e.message += ' in ' + opts.filename;\n        }\n        e.message += ' while compiling ejs\\n\\n';\n        e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\\n';\n        e.message += 'https://github.com/RyanZim/EJS-Lint';\n        if (!opts.async) {\n          e.message += '\\n';\n          e.message += 'Or, if you meant to create an async function, pass `async: true` as an option.';\n        }\n      }\n      throw e;\n    }\n\n    // Return a callable function which will execute the function\n    // created by the source-code, with the passed data as locals\n    // Adds a local `include` function which allows full recursive include\n    var returnedFn = opts.client ? fn : function anonymous(data) {\n      var include = function (path, includeData) {\n        var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data);\n        if (includeData) {\n          d = utils.shallowCopy(d, includeData);\n        }\n        return includeFile(path, opts)(d);\n      };\n      return fn.apply(opts.context,\n        [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]);\n    };\n    if (opts.filename && typeof Object.defineProperty === 'function') {\n      var filename = opts.filename;\n      var basename = path.basename(filename, path.extname(filename));\n      try {\n        Object.defineProperty(returnedFn, 'name', {\n          value: basename,\n          writable: false,\n          enumerable: false,\n          configurable: true\n        });\n      } catch (e) {/* ignore */}\n    }\n    return returnedFn;\n  },\n\n  generateSource: function () {\n    var opts = this.opts;\n\n    if (opts.rmWhitespace) {\n      // Have to use two separate replace here as `^` and `$` operators don't\n      // work well with `\\r` and empty lines don't work well with the `m` flag.\n      this.templateText =\n        this.templateText.replace(/[\\r\\n]+/g, '\\n').replace(/^\\s+|\\s+$/gm, '');\n    }\n\n    // Slurp spaces and tabs before <%_ and after _%>\n    this.templateText =\n      this.templateText.replace(/[ \\t]*<%_/gm, '<%_').replace(/_%>[ \\t]*/gm, '_%>');\n\n    var self = this;\n    var matches = this.parseTemplateText();\n    var d = this.opts.delimiter;\n    var o = this.opts.openDelimiter;\n    var c = this.opts.closeDelimiter;\n\n    if (matches && matches.length) {\n      matches.forEach(function (line, index) {\n        var closing;\n        // If this is an opening tag, check for closing tags\n        // FIXME: May end up with some false positives here\n        // Better to store modes as k/v with openDelimiter + delimiter as key\n        // Then this can simply check against the map\n        if ( line.indexOf(o + d) === 0        // If it is a tag\n          && line.indexOf(o + d + d) !== 0) { // and is not escaped\n          closing = matches[index + 2];\n          if (!(closing == d + c || closing == '-' + d + c || closing == '_' + d + c)) {\n            throw new Error('Could not find matching close tag for \"' + line + '\".');\n          }\n        }\n        self.scanLine(line);\n      });\n    }\n\n  },\n\n  parseTemplateText: function () {\n    var str = this.templateText;\n    var pat = this.regex;\n    var result = pat.exec(str);\n    var arr = [];\n    var firstPos;\n\n    while (result) {\n      firstPos = result.index;\n\n      if (firstPos !== 0) {\n        arr.push(str.substring(0, firstPos));\n        str = str.slice(firstPos);\n      }\n\n      arr.push(result[0]);\n      str = str.slice(result[0].length);\n      result = pat.exec(str);\n    }\n\n    if (str) {\n      arr.push(str);\n    }\n\n    return arr;\n  },\n\n  _addOutput: function (line) {\n    if (this.truncate) {\n      // Only replace single leading linebreak in the line after\n      // -%> tag -- this is the single, trailing linebreak\n      // after the tag that the truncation mode replaces\n      // Handle Win / Unix / old Mac linebreaks -- do the \\r\\n\n      // combo first in the regex-or\n      line = line.replace(/^(?:\\r\\n|\\r|\\n)/, '');\n      this.truncate = false;\n    }\n    if (!line) {\n      return line;\n    }\n\n    // Preserve literal slashes\n    line = line.replace(/\\\\/g, '\\\\\\\\');\n\n    // Convert linebreaks\n    line = line.replace(/\\n/g, '\\\\n');\n    line = line.replace(/\\r/g, '\\\\r');\n\n    // Escape double-quotes\n    // - this will be the delimiter during execution\n    line = line.replace(/\"/g, '\\\\\"');\n    this.source += '    ; __append(\"' + line + '\")' + '\\n';\n  },\n\n  scanLine: function (line) {\n    var self = this;\n    var d = this.opts.delimiter;\n    var o = this.opts.openDelimiter;\n    var c = this.opts.closeDelimiter;\n    var newLineCount = 0;\n\n    newLineCount = (line.split('\\n').length - 1);\n\n    switch (line) {\n    case o + d:\n    case o + d + '_':\n      this.mode = Template.modes.EVAL;\n      break;\n    case o + d + '=':\n      this.mode = Template.modes.ESCAPED;\n      break;\n    case o + d + '-':\n      this.mode = Template.modes.RAW;\n      break;\n    case o + d + '#':\n      this.mode = Template.modes.COMMENT;\n      break;\n    case o + d + d:\n      this.mode = Template.modes.LITERAL;\n      this.source += '    ; __append(\"' + line.replace(o + d + d, o + d) + '\")' + '\\n';\n      break;\n    case d + d + c:\n      this.mode = Template.modes.LITERAL;\n      this.source += '    ; __append(\"' + line.replace(d + d + c, d + c) + '\")' + '\\n';\n      break;\n    case d + c:\n    case '-' + d + c:\n    case '_' + d + c:\n      if (this.mode == Template.modes.LITERAL) {\n        this._addOutput(line);\n      }\n\n      this.mode = null;\n      this.truncate = line.indexOf('-') === 0 || line.indexOf('_') === 0;\n      break;\n    default:\n      // In script mode, depends on type of tag\n      if (this.mode) {\n        // If '//' is found without a line break, add a line break.\n        switch (this.mode) {\n        case Template.modes.EVAL:\n        case Template.modes.ESCAPED:\n        case Template.modes.RAW:\n          if (line.lastIndexOf('//') > line.lastIndexOf('\\n')) {\n            line += '\\n';\n          }\n        }\n        switch (this.mode) {\n        // Just executing code\n        case Template.modes.EVAL:\n          this.source += '    ; ' + line + '\\n';\n          break;\n          // Exec, esc, and output\n        case Template.modes.ESCAPED:\n          this.source += '    ; __append(escapeFn(' + stripSemi(line) + '))' + '\\n';\n          break;\n          // Exec and output\n        case Template.modes.RAW:\n          this.source += '    ; __append(' + stripSemi(line) + ')' + '\\n';\n          break;\n        case Template.modes.COMMENT:\n          // Do nothing\n          break;\n          // Literal <%% mode, append as raw output\n        case Template.modes.LITERAL:\n          this._addOutput(line);\n          break;\n        }\n      }\n      // In string mode, just add the output\n      else {\n        this._addOutput(line);\n      }\n    }\n\n    if (self.opts.compileDebug && newLineCount) {\n      this.currentLine += newLineCount;\n      this.source += '    ; __line = ' + this.currentLine + '\\n';\n    }\n  }\n};\n\n/**\n * Escape characters reserved in XML.\n *\n * This is simply an export of {@link module:utils.escapeXML}.\n *\n * If `markup` is `undefined` or `null`, the empty string is returned.\n *\n * @param {String} markup Input string\n * @return {String} Escaped string\n * @public\n * @func\n * */\nexports.escapeXML = utils.escapeXML;\n\n/**\n * Express.js support.\n *\n * This is an alias for {@link module:ejs.renderFile}, in order to support\n * Express.js out-of-the-box.\n *\n * @func\n */\n\nexports.__express = exports.renderFile;\n\n/**\n * Version of EJS.\n *\n * @readonly\n * @type {String}\n * @public\n */\n\nexports.VERSION = _VERSION_STRING;\n\n/**\n * Name for detection of EJS.\n *\n * @readonly\n * @type {String}\n * @public\n */\n\nexports.name = _NAME;\n\n/* istanbul ignore if */\nif (typeof window != 'undefined') {\n  window.ejs = exports;\n}\n", "/**\n * [js-sha3]{@link https://github.com/emn178/js-sha3}\n *\n * @version 0.8.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2015-2018\n * @license MIT\n */\n/*jslint bitwise: true */\n(function () {\n  'use strict';\n\n  var INPUT_ERROR = 'input is invalid type';\n  var FINALIZE_ERROR = 'finalize already called';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_SHA3_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD = typeof define === 'function' && define.amd;\n  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];\n  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];\n  var KECCAK_PADDING = [1, 256, 65536, 16777216];\n  var PADDING = [6, 1536, 393216, 100663296];\n  var SHIFT = [0, 8, 16, 24];\n  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,\n    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,\n    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,\n    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,\n    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];\n  var BITS = [224, 256, 384, 512];\n  var SHAKE_BITS = [128, 256];\n  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];\n  var CSHAKE_BYTEPAD = {\n    '128': 168,\n    '256': 136\n  };\n\n  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function (bits, padding, outputType) {\n    return function (message) {\n      return new Keccak(bits, padding, bits).update(message)[outputType]();\n    };\n  };\n\n  var createShakeOutputMethod = function (bits, padding, outputType) {\n    return function (message, outputBits) {\n      return new Keccak(bits, padding, outputBits).update(message)[outputType]();\n    };\n  };\n\n  var createCshakeOutputMethod = function (bits, padding, outputType) {\n    return function (message, outputBits, n, s) {\n      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();\n    };\n  };\n\n  var createKmacOutputMethod = function (bits, padding, outputType) {\n    return function (key, message, outputBits, s) {\n      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();\n    };\n  };\n\n  var createOutputMethods = function (method, createMethod, bits, padding) {\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createMethod(bits, padding, type);\n    }\n    return method;\n  };\n\n  var createMethod = function (bits, padding) {\n    var method = createOutputMethod(bits, padding, 'hex');\n    method.create = function () {\n      return new Keccak(bits, padding, bits);\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    return createOutputMethods(method, createOutputMethod, bits, padding);\n  };\n\n  var createShakeMethod = function (bits, padding) {\n    var method = createShakeOutputMethod(bits, padding, 'hex');\n    method.create = function (outputBits) {\n      return new Keccak(bits, padding, outputBits);\n    };\n    method.update = function (message, outputBits) {\n      return method.create(outputBits).update(message);\n    };\n    return createOutputMethods(method, createShakeOutputMethod, bits, padding);\n  };\n\n  var createCshakeMethod = function (bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createCshakeOutputMethod(bits, padding, 'hex');\n    method.create = function (outputBits, n, s) {\n      if (!n && !s) {\n        return methods['shake' + bits].create(outputBits);\n      } else {\n        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);\n      }\n    };\n    method.update = function (message, outputBits, n, s) {\n      return method.create(outputBits, n, s).update(message);\n    };\n    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);\n  };\n\n  var createKmacMethod = function (bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createKmacOutputMethod(bits, padding, 'hex');\n    method.create = function (key, outputBits, s) {\n      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);\n    };\n    method.update = function (key, message, outputBits, s) {\n      return method.create(key, outputBits, s).update(message);\n    };\n    return createOutputMethods(method, createKmacOutputMethod, bits, padding);\n  };\n\n  var algorithms = [\n    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },\n    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },\n    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },\n    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },\n    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }\n  ];\n\n  var methods = {}, methodNames = [];\n\n  for (var i = 0; i < algorithms.length; ++i) {\n    var algorithm = algorithms[i];\n    var bits = algorithm.bits;\n    for (var j = 0; j < bits.length; ++j) {\n      var methodName = algorithm.name + '_' + bits[j];\n      methodNames.push(methodName);\n      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);\n      if (algorithm.name !== 'sha3') {\n        var newMethodName = algorithm.name + bits[j];\n        methodNames.push(newMethodName);\n        methods[newMethodName] = methods[methodName];\n      }\n    }\n  }\n\n  function Keccak(bits, padding, outputBits) {\n    this.blocks = [];\n    this.s = [];\n    this.padding = padding;\n    this.outputBits = outputBits;\n    this.reset = true;\n    this.finalized = false;\n    this.block = 0;\n    this.start = 0;\n    this.blockCount = (1600 - (bits << 1)) >> 5;\n    this.byteCount = this.blockCount << 2;\n    this.outputBlocks = outputBits >> 5;\n    this.extraBytes = (outputBits & 31) >> 3;\n\n    for (var i = 0; i < 50; ++i) {\n      this.s[i] = 0;\n    }\n  }\n\n  Keccak.prototype.update = function (message) {\n    if (this.finalized) {\n      throw new Error(FINALIZE_ERROR);\n    }\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n      notString = true;\n    }\n    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,\n      blockCount = this.blockCount, index = 0, s = this.s, i, code;\n\n    while (index < length) {\n      if (this.reset) {\n        this.reset = false;\n        blocks[0] = this.block;\n        for (i = 1; i < blockCount + 1; ++i) {\n          blocks[i] = 0;\n        }\n      }\n      if (notString) {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          code = message.charCodeAt(index);\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          }\n        }\n      }\n      this.lastByteIndex = i;\n      if (i >= byteCount) {\n        this.start = i - byteCount;\n        this.block = blocks[blockCount];\n        for (i = 0; i < blockCount; ++i) {\n          s[i] ^= blocks[i];\n        }\n        f(s);\n        this.reset = true;\n      } else {\n        this.start = i;\n      }\n    }\n    return this;\n  };\n\n  Keccak.prototype.encode = function (x, right) {\n    var o = x & 255, n = 1;\n    var bytes = [o];\n    x = x >> 8;\n    o = x & 255;\n    while (o > 0) {\n      bytes.unshift(o);\n      x = x >> 8;\n      o = x & 255;\n      ++n;\n    }\n    if (right) {\n      bytes.push(n);\n    } else {\n      bytes.unshift(n);\n    }\n    this.update(bytes);\n    return bytes.length;\n  };\n\n  Keccak.prototype.encodeString = function (str) {\n    var notString, type = typeof str;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (str === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {\n          str = new Uint8Array(str);\n        } else if (!Array.isArray(str)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n      notString = true;\n    }\n    var bytes = 0, length = str.length;\n    if (notString) {\n      bytes = length;\n    } else {\n      for (var i = 0; i < str.length; ++i) {\n        var code = str.charCodeAt(i);\n        if (code < 0x80) {\n          bytes += 1;\n        } else if (code < 0x800) {\n          bytes += 2;\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes += 3;\n        } else {\n          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));\n          bytes += 4;\n        }\n      }\n    }\n    bytes += this.encode(bytes * 8);\n    this.update(str);\n    return bytes;\n  };\n\n  Keccak.prototype.bytepad = function (strs, w) {\n    var bytes = this.encode(w);\n    for (var i = 0; i < strs.length; ++i) {\n      bytes += this.encodeString(strs[i]);\n    }\n    var paddingBytes = w - bytes % w;\n    var zeros = [];\n    zeros.length = paddingBytes;\n    this.update(zeros);\n    return this;\n  };\n\n  Keccak.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;\n    blocks[i >> 2] |= this.padding[i & 3];\n    if (this.lastByteIndex === this.byteCount) {\n      blocks[0] = blocks[blockCount];\n      for (i = 1; i < blockCount + 1; ++i) {\n        blocks[i] = 0;\n      }\n    }\n    blocks[blockCount - 1] |= 0x80000000;\n    for (i = 0; i < blockCount; ++i) {\n      s[i] ^= blocks[i];\n    }\n    f(s);\n  };\n\n  Keccak.prototype.toString = Keccak.prototype.hex = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var hex = '', block;\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        block = s[i];\n        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +\n          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +\n          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +\n          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];\n      }\n      if (j % blockCount === 0) {\n        f(s);\n        i = 0;\n      }\n    }\n    if (extraBytes) {\n      block = s[i];\n      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];\n      if (extraBytes > 1) {\n        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];\n      }\n      if (extraBytes > 2) {\n        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];\n      }\n    }\n    return hex;\n  };\n\n  Keccak.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var bytes = this.outputBits >> 3;\n    var buffer;\n    if (extraBytes) {\n      buffer = new ArrayBuffer((outputBlocks + 1) << 2);\n    } else {\n      buffer = new ArrayBuffer(bytes);\n    }\n    var array = new Uint32Array(buffer);\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        array[j] = s[i];\n      }\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n    if (extraBytes) {\n      array[i] = s[i];\n      buffer = buffer.slice(0, bytes);\n    }\n    return buffer;\n  };\n\n  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;\n\n  Keccak.prototype.digest = Keccak.prototype.array = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var array = [], offset, block;\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        offset = j << 2;\n        block = s[i];\n        array[offset] = block & 0xFF;\n        array[offset + 1] = (block >> 8) & 0xFF;\n        array[offset + 2] = (block >> 16) & 0xFF;\n        array[offset + 3] = (block >> 24) & 0xFF;\n      }\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n    if (extraBytes) {\n      offset = j << 2;\n      block = s[i];\n      array[offset] = block & 0xFF;\n      if (extraBytes > 1) {\n        array[offset + 1] = (block >> 8) & 0xFF;\n      }\n      if (extraBytes > 2) {\n        array[offset + 2] = (block >> 16) & 0xFF;\n      }\n    }\n    return array;\n  };\n\n  function Kmac(bits, padding, outputBits) {\n    Keccak.call(this, bits, padding, outputBits);\n  }\n\n  Kmac.prototype = new Keccak();\n\n  Kmac.prototype.finalize = function () {\n    this.encode(this.outputBits, true);\n    return Keccak.prototype.finalize.call(this);\n  };\n\n  var f = function (s) {\n    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,\n      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,\n      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,\n      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\n    for (n = 0; n < 48; n += 2) {\n      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n\n      h = c8 ^ ((c2 << 1) | (c3 >>> 31));\n      l = c9 ^ ((c3 << 1) | (c2 >>> 31));\n      s[0] ^= h;\n      s[1] ^= l;\n      s[10] ^= h;\n      s[11] ^= l;\n      s[20] ^= h;\n      s[21] ^= l;\n      s[30] ^= h;\n      s[31] ^= l;\n      s[40] ^= h;\n      s[41] ^= l;\n      h = c0 ^ ((c4 << 1) | (c5 >>> 31));\n      l = c1 ^ ((c5 << 1) | (c4 >>> 31));\n      s[2] ^= h;\n      s[3] ^= l;\n      s[12] ^= h;\n      s[13] ^= l;\n      s[22] ^= h;\n      s[23] ^= l;\n      s[32] ^= h;\n      s[33] ^= l;\n      s[42] ^= h;\n      s[43] ^= l;\n      h = c2 ^ ((c6 << 1) | (c7 >>> 31));\n      l = c3 ^ ((c7 << 1) | (c6 >>> 31));\n      s[4] ^= h;\n      s[5] ^= l;\n      s[14] ^= h;\n      s[15] ^= l;\n      s[24] ^= h;\n      s[25] ^= l;\n      s[34] ^= h;\n      s[35] ^= l;\n      s[44] ^= h;\n      s[45] ^= l;\n      h = c4 ^ ((c8 << 1) | (c9 >>> 31));\n      l = c5 ^ ((c9 << 1) | (c8 >>> 31));\n      s[6] ^= h;\n      s[7] ^= l;\n      s[16] ^= h;\n      s[17] ^= l;\n      s[26] ^= h;\n      s[27] ^= l;\n      s[36] ^= h;\n      s[37] ^= l;\n      s[46] ^= h;\n      s[47] ^= l;\n      h = c6 ^ ((c0 << 1) | (c1 >>> 31));\n      l = c7 ^ ((c1 << 1) | (c0 >>> 31));\n      s[8] ^= h;\n      s[9] ^= l;\n      s[18] ^= h;\n      s[19] ^= l;\n      s[28] ^= h;\n      s[29] ^= l;\n      s[38] ^= h;\n      s[39] ^= l;\n      s[48] ^= h;\n      s[49] ^= l;\n\n      b0 = s[0];\n      b1 = s[1];\n      b32 = (s[11] << 4) | (s[10] >>> 28);\n      b33 = (s[10] << 4) | (s[11] >>> 28);\n      b14 = (s[20] << 3) | (s[21] >>> 29);\n      b15 = (s[21] << 3) | (s[20] >>> 29);\n      b46 = (s[31] << 9) | (s[30] >>> 23);\n      b47 = (s[30] << 9) | (s[31] >>> 23);\n      b28 = (s[40] << 18) | (s[41] >>> 14);\n      b29 = (s[41] << 18) | (s[40] >>> 14);\n      b20 = (s[2] << 1) | (s[3] >>> 31);\n      b21 = (s[3] << 1) | (s[2] >>> 31);\n      b2 = (s[13] << 12) | (s[12] >>> 20);\n      b3 = (s[12] << 12) | (s[13] >>> 20);\n      b34 = (s[22] << 10) | (s[23] >>> 22);\n      b35 = (s[23] << 10) | (s[22] >>> 22);\n      b16 = (s[33] << 13) | (s[32] >>> 19);\n      b17 = (s[32] << 13) | (s[33] >>> 19);\n      b48 = (s[42] << 2) | (s[43] >>> 30);\n      b49 = (s[43] << 2) | (s[42] >>> 30);\n      b40 = (s[5] << 30) | (s[4] >>> 2);\n      b41 = (s[4] << 30) | (s[5] >>> 2);\n      b22 = (s[14] << 6) | (s[15] >>> 26);\n      b23 = (s[15] << 6) | (s[14] >>> 26);\n      b4 = (s[25] << 11) | (s[24] >>> 21);\n      b5 = (s[24] << 11) | (s[25] >>> 21);\n      b36 = (s[34] << 15) | (s[35] >>> 17);\n      b37 = (s[35] << 15) | (s[34] >>> 17);\n      b18 = (s[45] << 29) | (s[44] >>> 3);\n      b19 = (s[44] << 29) | (s[45] >>> 3);\n      b10 = (s[6] << 28) | (s[7] >>> 4);\n      b11 = (s[7] << 28) | (s[6] >>> 4);\n      b42 = (s[17] << 23) | (s[16] >>> 9);\n      b43 = (s[16] << 23) | (s[17] >>> 9);\n      b24 = (s[26] << 25) | (s[27] >>> 7);\n      b25 = (s[27] << 25) | (s[26] >>> 7);\n      b6 = (s[36] << 21) | (s[37] >>> 11);\n      b7 = (s[37] << 21) | (s[36] >>> 11);\n      b38 = (s[47] << 24) | (s[46] >>> 8);\n      b39 = (s[46] << 24) | (s[47] >>> 8);\n      b30 = (s[8] << 27) | (s[9] >>> 5);\n      b31 = (s[9] << 27) | (s[8] >>> 5);\n      b12 = (s[18] << 20) | (s[19] >>> 12);\n      b13 = (s[19] << 20) | (s[18] >>> 12);\n      b44 = (s[29] << 7) | (s[28] >>> 25);\n      b45 = (s[28] << 7) | (s[29] >>> 25);\n      b26 = (s[38] << 8) | (s[39] >>> 24);\n      b27 = (s[39] << 8) | (s[38] >>> 24);\n      b8 = (s[48] << 14) | (s[49] >>> 18);\n      b9 = (s[49] << 14) | (s[48] >>> 18);\n\n      s[0] = b0 ^ (~b2 & b4);\n      s[1] = b1 ^ (~b3 & b5);\n      s[10] = b10 ^ (~b12 & b14);\n      s[11] = b11 ^ (~b13 & b15);\n      s[20] = b20 ^ (~b22 & b24);\n      s[21] = b21 ^ (~b23 & b25);\n      s[30] = b30 ^ (~b32 & b34);\n      s[31] = b31 ^ (~b33 & b35);\n      s[40] = b40 ^ (~b42 & b44);\n      s[41] = b41 ^ (~b43 & b45);\n      s[2] = b2 ^ (~b4 & b6);\n      s[3] = b3 ^ (~b5 & b7);\n      s[12] = b12 ^ (~b14 & b16);\n      s[13] = b13 ^ (~b15 & b17);\n      s[22] = b22 ^ (~b24 & b26);\n      s[23] = b23 ^ (~b25 & b27);\n      s[32] = b32 ^ (~b34 & b36);\n      s[33] = b33 ^ (~b35 & b37);\n      s[42] = b42 ^ (~b44 & b46);\n      s[43] = b43 ^ (~b45 & b47);\n      s[4] = b4 ^ (~b6 & b8);\n      s[5] = b5 ^ (~b7 & b9);\n      s[14] = b14 ^ (~b16 & b18);\n      s[15] = b15 ^ (~b17 & b19);\n      s[24] = b24 ^ (~b26 & b28);\n      s[25] = b25 ^ (~b27 & b29);\n      s[34] = b34 ^ (~b36 & b38);\n      s[35] = b35 ^ (~b37 & b39);\n      s[44] = b44 ^ (~b46 & b48);\n      s[45] = b45 ^ (~b47 & b49);\n      s[6] = b6 ^ (~b8 & b0);\n      s[7] = b7 ^ (~b9 & b1);\n      s[16] = b16 ^ (~b18 & b10);\n      s[17] = b17 ^ (~b19 & b11);\n      s[26] = b26 ^ (~b28 & b20);\n      s[27] = b27 ^ (~b29 & b21);\n      s[36] = b36 ^ (~b38 & b30);\n      s[37] = b37 ^ (~b39 & b31);\n      s[46] = b46 ^ (~b48 & b40);\n      s[47] = b47 ^ (~b49 & b41);\n      s[8] = b8 ^ (~b0 & b2);\n      s[9] = b9 ^ (~b1 & b3);\n      s[18] = b18 ^ (~b10 & b12);\n      s[19] = b19 ^ (~b11 & b13);\n      s[28] = b28 ^ (~b20 & b22);\n      s[29] = b29 ^ (~b21 & b23);\n      s[38] = b38 ^ (~b30 & b32);\n      s[39] = b39 ^ (~b31 & b33);\n      s[48] = b48 ^ (~b40 & b42);\n      s[49] = b49 ^ (~b41 & b43);\n\n      s[0] ^= RC[n];\n      s[1] ^= RC[n + 1];\n    }\n  };\n\n  if (COMMON_JS) {\n    module.exports = methods;\n  } else {\n    for (i = 0; i < methodNames.length; ++i) {\n      root[methodNames[i]] = methods[methodNames[i]];\n    }\n    if (AMD) {\n      define(function () {\n        return methods;\n      });\n    }\n  }\n})();\n", "import { hash } from './hash';\nimport { Token, Header } from './jwz';\nimport { provingMethodGroth16AuthInstance } from './authGroth16';\nimport {\n  getProvingMethod,\n  ProofInputsPreparerHandlerFunc,\n  ProvingMethod,\n  ProvingMethodAlg,\n  registerProvingMethod,\n  ZKProof,\n  ProofData,\n} from './proving';\nimport { provingMethodGroth16AuthV2Instance } from './authV2Groth16';\n\nregisterProvingMethod(\n  provingMethodGroth16AuthInstance.methodAlg,\n  () => provingMethodGroth16AuthInstance,\n);\n\nregisterProvingMethod(\n  provingMethodGroth16AuthV2Instance.methodAlg,\n  () => provingMethodGroth16AuthV2Instance,\n);\n\nconst proving = {\n  registerProvingMethod,\n  getProvingMethod,\n  provingMethodGroth16AuthInstance,\n  provingMethodGroth16AuthV2Instance,\n};\n\nexport {\n  proving,\n  ProofInputsPreparerHandlerFunc,\n  ProvingMethod,\n  ProvingMethodAlg,\n  Token,\n  hash,\n  ZKProof,\n  ProofData,\n  Header,\n};\n", "import { fromBigEndian } from '@iden3/js-iden3-core';\nimport { poseidon } from '@iden3/js-crypto';\nimport { sha256 } from 'cross-sha256';\n\n// Q is the order of the integer field (Zq) that fits inside the SNARK.\nexport const qString =\n  '21888242871839275222246405745257275088548364400416034343698204186575808495617';\n\nexport function hash(message: Uint8Array): bigint {\n  // 1. sha256 hash\n  const hashBytes = Uint8Array.from(new sha256().update(message).digest());\n\n  // 2. swap hash before hashing\n  const bi = fromBigEndian(hashBytes.reverse());\n\n  let m = BigInt(0);\n  if (checkBigIntInField(bi)) {\n    m = bi;\n  } else {\n    m = bi % BigInt(qString);\n  }\n\n  return poseidon.hash([m]);\n}\n\n// checkBigIntInField checks if given *big.Int fits in a Field Q element\nexport function checkBigIntInField(a: bigint): boolean {\n  return a < BigInt(qString);\n}\n", null, null, null, null, null, null, null, null, null, "\nimport * as _Scalar  from \"./src/scalar.js\";\nexport const Scalar=_Scalar;\n\nexport {default as PolField} from \"./src/polfield.js\";\nexport {default as F1Field} from \"./src/f1field.js\";\nexport {default as F2Field} from \"./src/f2field.js\";\nexport {default as F3Field} from \"./src/f3field.js\";\n\nexport {default as ZqField} from \"./src/f1field.js\";\n\nexport {default as EC} from \"./src/ec.js\";\n\nexport {default as buildBn128} from \"./src/bn128.js\";\nexport {default as buildBls12381} from \"./src/bls12381.js\";\n\nimport * as _utils from \"./src/utils.js\";\nexport const utils = _utils;\nexport {default as ChaCha} from \"./src/chacha.js\";\n\nexport {default as BigBuffer} from \"./src/bigbuffer.js\";\n\nexport {getCurveFromR, getCurveFromQ, getCurveFromName} from \"./src/curves.js\";\n\n", "\n/* global BigInt */\nconst hexLen = [ 0, 1, 2, 2, 3, 3, 3, 3, 4 ,4 ,4 ,4 ,4 ,4 ,4 ,4];\n\nexport function fromString(s, radix) {\n    if ((!radix)||(radix==10)) {\n        return BigInt(s);\n    } else if (radix==16) {\n        if (s.slice(0,2) == \"0x\") {\n            return BigInt(s);\n        } else {\n            return BigInt(\"0x\"+s);\n        }\n    }\n}\n\nexport const e = fromString;\n\nexport function fromArray(a, radix) {\n    let acc =BigInt(0);\n    radix = BigInt(radix);\n    for (let i=0; i<a.length; i++) {\n        acc = acc*radix + BigInt(a[i]);\n    }\n    return acc;\n}\n\nexport function bitLength(a) {\n    const aS =a.toString(16);\n    return (aS.length-1)*4 +hexLen[parseInt(aS[0], 16)];\n}\n\nexport function isNegative(a) {\n    return BigInt(a) < BigInt(0);\n}\n\nexport function isZero(a) {\n    return !a;\n}\n\nexport function shiftLeft(a, n) {\n    return BigInt(a) << BigInt(n);\n}\n\nexport function shiftRight(a, n) {\n    return BigInt(a) >> BigInt(n);\n}\n\nexport const shl = shiftLeft;\nexport const shr = shiftRight;\n\nexport function isOdd(a) {\n    return (BigInt(a) & BigInt(1)) == BigInt(1);\n}\n\n\nexport function naf(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            const z = 2 - Number(E % BigInt(4));\n            res.push( z );\n            E = E - BigInt(z);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\n\nexport function bits(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\nexport function toNumber(s) {\n    if (s>BigInt(Number.MAX_SAFE_INTEGER )) {\n        throw new Error(\"Number too big\");\n    }\n    return Number(s);\n}\n\nexport function toArray(s, radix) {\n    const res = [];\n    let rem = BigInt(s);\n    radix = BigInt(radix);\n    while (rem) {\n        res.unshift( Number(rem % radix));\n        rem = rem / radix;\n    }\n    return res;\n}\n\n\nexport function add(a, b) {\n    return BigInt(a) + BigInt(b);\n}\n\nexport function sub(a, b) {\n    return BigInt(a) - BigInt(b);\n}\n\nexport function neg(a) {\n    return -BigInt(a);\n}\n\nexport function mul(a, b) {\n    return BigInt(a) * BigInt(b);\n}\n\nexport function square(a) {\n    return BigInt(a) * BigInt(a);\n}\n\nexport function pow(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function exp(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function abs(a) {\n    return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);\n}\n\nexport function div(a, b) {\n    return BigInt(a) / BigInt(b);\n}\n\nexport function mod(a, b) {\n    return BigInt(a) % BigInt(b);\n}\n\nexport function eq(a, b) {\n    return BigInt(a) == BigInt(b);\n}\n\nexport function neq(a, b) {\n    return BigInt(a) != BigInt(b);\n}\n\nexport function lt(a, b) {\n    return BigInt(a) < BigInt(b);\n}\n\nexport function gt(a, b) {\n    return BigInt(a) > BigInt(b);\n}\n\nexport function leq(a, b) {\n    return BigInt(a) <= BigInt(b);\n}\n\nexport function geq(a, b) {\n    return BigInt(a) >= BigInt(b);\n}\n\nexport function band(a, b) {\n    return BigInt(a) & BigInt(b);\n}\n\nexport function bor(a, b) {\n    return BigInt(a) | BigInt(b);\n}\n\nexport function bxor(a, b) {\n    return BigInt(a) ^ BigInt(b);\n}\n\nexport function land(a, b) {\n    return BigInt(a) && BigInt(b);\n}\n\nexport function lor(a, b) {\n    return BigInt(a) || BigInt(b);\n}\n\nexport function lnot(a) {\n    return !BigInt(a);\n}\n\n// Returns a buffer with Little Endian Representation\nexport function toRprLE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new Uint32Array(buff.buffer, o, n8/4);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v[i] = parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16);\n    for (let i=l; i<v.length; i++) v[i] = 0;\n    for (let i=v.length*4; i<n8; i++) buff[i] = toNumber(band(shiftRight(e, i*8), 0xFF));\n}\n\n// Returns a buffer with Big Endian Representation\nexport function toRprBE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v.setUint32(n8-i*4 -4, parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16), false);\n    for (let i=0; i<n8/4-l; i++) v[i] = 0;\n}\n\n// Pases a buffer with Little Endian Representation\nexport function fromRprLE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new Uint32Array(buff.buffer, o, n8/4);\n    const a = new Array(n8/4);\n    v.forEach( (ch,i) => a[a.length-i-1] = ch.toString(16).padStart(8,\"0\") );\n    return fromString(a.join(\"\"), 16);\n}\n\n// Pases a buffer with Big Endian Representation\nexport function fromRprBE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const a = new Array(n8/4);\n    for (let i=0; i<n8/4; i++) {\n        a[i] = v.getUint32(i*4, false).toString(16).padStart(8, \"0\");\n    }\n    return fromString(a.join(\"\"), 16);\n}\n\nexport function toString(a, radix) {\n    return a.toString(radix);\n}\n\nexport function toLEBuff(a) {\n    const buff = new Uint8Array(Math.floor((bitLength(a) - 1) / 8) +1);\n    toRprLE(buff, 0, a, buff.byteLength);\n    return buff;\n}\n\nexport const zero = e(0);\nexport const one = e(1);\n\n\n\n\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class PolField {\n    constructor (F) {\n        this.F = F;\n\n        let rem = F.sqrt_t;\n        let s = F.sqrt_s;\n\n        const five = this.F.add(this.F.add(this.F.two, this.F.two), this.F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(five, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n/*        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n    */\n        this._setRoots(15);\n    }\n\n    _setRoots(n) {\n        if (n > this.F.sqrt_s) n = this.s;\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n            this.roots[i] = rootsi;\n        }\n    }\n\n    add(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.add(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.sub(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    mulScalar(p, b) {\n        if (this.F.eq(b, this.F.zero)) return [];\n        if (this.F.eq(b, this.F.one)) return p;\n        const res = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.mul(p[i], b);\n        }\n        return res;\n    }\n\n\n\n    mul(a, b) {\n        if (a.length == 0) return [];\n        if (b.length == 0) return [];\n        if (a.length == 1) return this.mulScalar(b, a[0]);\n        if (b.length == 1) return this.mulScalar(a, b[0]);\n\n        if (b.length > a.length) {\n            [b, a] = [a, b];\n        }\n\n        if ((b.length <= 2) || (b.length < log2(a.length))) {\n            return this.mulNormal(a,b);\n        } else {\n            return this.mulFFT(a,b);\n        }\n    }\n\n    mulNormal(a, b) {\n        let res = [];\n        for (let i=0; i<b.length; i++) {\n            res = this.add(res, this.scaleX(this.mulScalar(a, b[i]), i) );\n        }\n        return res;\n    }\n\n    mulFFT(a,b) {\n        const longestN = Math.max(a.length, b.length);\n        const bitsResult = log2(longestN-1)+2;\n        this._setRoots(bitsResult);\n\n        const m = 1 << bitsResult;\n        const ea = this.extend(a,m);\n        const eb = this.extend(b,m);\n\n        const ta = __fft(this, ea, bitsResult, 0, 1, false);\n        const tb = __fft(this, eb, bitsResult, 0, 1, false);\n\n        const tres = new Array(m);\n\n        for (let i=0; i<m; i++) {\n            tres[i] = this.F.mul(ta[i], tb[i]);\n        }\n\n        const res = __fft(this, tres, bitsResult, 0, 1, true);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return this.reduce(resn);\n    }\n\n\n\n    square(a) {\n        return this.mul(a,a);\n    }\n\n    scaleX(p, n) {\n        if (n==0) {\n            return p;\n        } else if (n>0) {\n            const z = new Array(n).fill(this.F.zero);\n            return z.concat(p);\n        } else {\n            if (-n >= p.length) return [];\n            return p.slice(-n);\n        }\n    }\n\n    eval2(p, x) {\n        let v = this.F.zero;\n        let ix = this.F.one;\n        for (let i=0; i<p.length; i++) {\n            v = this.F.add(v, this.F.mul(p[i], ix));\n            ix = this.F.mul(ix, x);\n        }\n        return v;\n    }\n\n    eval(p,x) {\n        const F = this.F;\n        if (p.length == 0) return F.zero;\n        const m = this._next2Power(p.length);\n        const ep = this.extend(p, m);\n\n        return _eval(ep, x, 0, 1, m);\n\n        function _eval(p, x, offset, step, n) {\n            if (n==1) return p[offset];\n            const newX = F.square(x);\n            const res= F.add(\n                _eval(p, newX, offset, step << 1, n >> 1),\n                F.mul(\n                    x,\n                    _eval(p, newX, offset+step , step << 1, n >> 1)));\n            return res;\n        }\n    }\n\n    lagrange(points) {\n        let roots = [this.F.one];\n        for (let i=0; i<points.length; i++) {\n            roots = this.mul(roots, [this.F.neg(points[i][0]), this.F.one]);\n        }\n\n        let sum = [];\n        for (let i=0; i<points.length; i++) {\n            let mpol = this.ruffini(roots, points[i][0]);\n            const factor =\n                this.F.mul(\n                    this.F.inv(this.eval(mpol, points[i][0])),\n                    points[i][1]);\n            mpol = this.mulScalar(mpol, factor);\n            sum = this.add(sum, mpol);\n        }\n        return sum;\n    }\n\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res = __fft(this, ep, bits, 0, 1);\n        return res;\n    }\n\n    fft2(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res = __fft2(this, ep, bits);\n        return res;\n    }\n\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res =  __fft(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n\n    ifft2(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res =  __fft2(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n    _fft(pall, bits, offset, step) {\n\n        const n = 1 << bits;\n        if (n==1) {\n            return [ pall[offset] ];\n        }\n\n        const ndiv2 = n >> 1;\n        const p1 = this._fft(pall, bits-1, offset, step*2);\n        const p2 = this._fft(pall, bits-1, offset+step, step*2);\n\n        const out = new Array(n);\n\n        let m= this.F.one;\n        for (let i=0; i<ndiv2; i++) {\n            out[i] = this.F.add(p1[i], this.F.mul(m, p2[i]));\n            out[i+ndiv2] = this.F.sub(p1[i], this.F.mul(m, p2[i]));\n            m = this.F.mul(m, this.w[bits]);\n        }\n\n        return out;\n    }\n\n    extend(p, e) {\n        if (e == p.length) return p;\n        const z = new Array(e-p.length).fill(this.F.zero);\n\n        return p.concat(z);\n    }\n\n    reduce(p) {\n        if (p.length == 0) return p;\n        if (! this.F.eq(p[p.length-1], this.F.zero) ) return p;\n        let i=p.length-1;\n        while( i>0 && this.F.eq(p[i], this.F.zero) ) i--;\n        return p.slice(0, i+1);\n    }\n\n    eq(a, b) {\n        const pa = this.reduce(a);\n        const pb = this.reduce(b);\n\n        if (pa.length != pb.length) return false;\n        for (let i=0; i<pb.length; i++) {\n            if (!this.F.eq(pa[i], pb[i])) return false;\n        }\n\n        return true;\n    }\n\n    ruffini(p, r) {\n        const res = new Array(p.length-1);\n        res[res.length-1] = p[p.length-1];\n        for (let i = res.length-2; i>=0; i--) {\n            res[i] = this.F.add(this.F.mul(res[i+1], r), p[i+1]);\n        }\n        return res;\n    }\n\n    _next2Power(v) {\n        v--;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v++;\n        return v;\n    }\n\n    toString(p) {\n        const ap = this.normalize(p);\n        let S = \"\";\n        for (let i=ap.length-1; i>=0; i--) {\n            if (!this.F.eq(p[i], this.F.zero)) {\n                if (S!=\"\") S += \" + \";\n                S = S + p[i].toString(10);\n                if (i>0) {\n                    S = S + \"x\";\n                    if (i>1) {\n                        S = S + \"^\" +i;\n                    }\n                }\n            }\n        }\n        return S;\n    }\n\n    normalize(p) {\n        const res  = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.normalize(p[i]);\n        }\n        return res;\n    }\n\n\n    _reciprocal(p, bits) {\n        const k = 1 << bits;\n        if (k==1) {\n            return [ this.F.inv(p[0]) ];\n        }\n        const np = this.scaleX(p, -k/2);\n        const q = this._reciprocal(np, bits-1);\n        const a = this.scaleX(this.double(q), 3*k/2-2);\n        const b = this.mul( this.square(q), p);\n\n        return this.scaleX(this.sub(a,b),   -(k-2));\n    }\n\n    // divides x^m / v\n    _div2(m, v) {\n        const kbits = log2(v.length-1)+1;\n        const k = 1 << kbits;\n\n        const scaleV = k - v.length;\n\n        // rec = x^(k - 2) / v* x^scaleV =>\n        // rec = x^(k-2-scaleV)/ v\n        //\n        // res = x^m/v = x^(m + (2*k-2 - scaleV) - (2*k-2 - scaleV)) /v =>\n        // res = rec * x^(m - (2*k-2 - scaleV)) =>\n        // res = rec * x^(m - 2*k + 2 + scaleV)\n\n        const rec = this._reciprocal(this.scaleX(v, scaleV), kbits);\n        const res = this.scaleX(rec, m - 2*k + 2 + scaleV);\n\n        return res;\n    }\n\n    div(_u, _v) {\n        if (_u.length < _v.length) return [];\n        const kbits = log2(_v.length-1)+1;\n        const k = 1 << kbits;\n\n        const u = this.scaleX(_u, k-_v.length);\n        const v = this.scaleX(_v, k-_v.length);\n\n        const n = v.length-1;\n        let m = u.length-1;\n\n        const s = this._reciprocal(v, kbits);\n        let t;\n        if (m>2*n) {\n            t = this.sub(this.scaleX([this.F.one], 2*n), this.mul(s, v));\n        }\n\n        let q = [];\n        let rem = u;\n        let us, ut;\n        let finish = false;\n\n        while (!finish) {\n            us = this.mul(rem, s);\n            q = this.add(q, this.scaleX(us, -2*n));\n\n            if ( m > 2*n ) {\n                ut = this.mul(rem, t);\n                rem = this.scaleX(ut, -2*n);\n                m = rem.length-1;\n            } else {\n                finish = true;\n            }\n        }\n\n        return q;\n    }\n\n\n    // returns the ith nth-root of one\n    oneRoot(n, i) {\n        let nbits = log2(n-1)+1;\n        let res = this.F.one;\n        let r = i;\n\n        if(i>=n) {\n            throw new Error(\"Given 'i' should be lower than 'n'\");\n        }\n        else if (1<<nbits !== n) {\n            throw new Error(`Internal errlr: ${n} should equal ${1<<nbits}`);\n        }\n\n        while (r>0) {\n            if (r & 1 == 1) {\n                res = this.F.mul(res, this.w[nbits]);\n            }\n            r = r >> 1;\n            nbits --;\n        }\n        return res;\n    }\n\n    computeVanishingPolinomial(bits, t) {\n        const m = 1 << bits;\n        return this.F.sub(this.F.pow(t, m), this.F.one);\n    }\n\n    evaluateLagrangePolynomials(bits, t) {\n        const m= 1 << bits;\n        const tm = this.F.pow(t, m);\n        const u= new Array(m).fill(this.F.zero);\n        this._setRoots(bits);\n        const omega = this.w[bits];\n\n        if (this.F.eq(tm, this.F.one)) {\n            for (let i = 0; i < m; i++) {\n                if (this.F.eq(this.roots[bits][0],t)) { // i.e., t equals omega^i\n                    u[i] = this.F.one;\n                    return u;\n                }\n            }\n        }\n\n        const z = this.F.sub(tm, this.F.one);\n        //        let l = this.F.mul(z,  this.F.pow(this.F.twoinv, m));\n        let l = this.F.mul(z,  this.F.inv(this.F.e(m)));\n        for (let i = 0; i < m; i++) {\n            u[i] = this.F.mul(l, this.F.inv(this.F.sub(t,this.roots[bits][i])));\n            l = this.F.mul(l, omega);\n        }\n\n        return u;\n    }\n\n    log2(V) {\n        return log2(V);\n    }\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.F.add(pall[offset], pall[offset + step]),\n            PF.F.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\n\nfunction __fft2(PF, pall, bits) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[0] ];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft2(PF, pall.slice(0, ndiv2), bits-1);\n    const p2 = __fft2(PF, pall.slice(ndiv2), bits-1);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction rev(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\nfunction __bitReverse(p, bits) {\n    for (let k=0; k<p.length; k++) {\n        const r = rev(k, bits);\n        if (r>k) {\n            const tmp= p[k];\n            p[k] = p[r];\n            p[r] = tmp;\n        }\n    }\n\n}\n\n\n", "/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\nimport * as futils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\nimport {getRandomBytes} from \"./random.js\";\nimport FFFT from \"./fft.js\";\n\nexport default class ZqField {\n    constructor(p) {\n        this.type=\"F1\";\n        this.one = BigInt(1);\n        this.zero = BigInt(0);\n        this.p = BigInt(p);\n        this.m = 1;\n        this.negone = this.p-this.one;\n        this.two = BigInt(2);\n        this.half = this.p >> this.one;\n        this.bitLength = Scalar.bitLength(this.p);\n        this.mask = (this.one << BigInt(this.bitLength)) - this.one;\n\n        this.n64 = Math.floor((this.bitLength - 1) / 64)+1;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n        this.R = this.e(this.one << BigInt(this.n64*64));\n        this.Ri = this.inv(this.R);\n\n        const e = this.negone >> this.one;\n        this.nqr = this.two;\n        let r = this.pow(this.nqr, e);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.nqr + this.one;\n            r = this.pow(this.nqr, e);\n        }\n\n\n        this.s = 0;\n        this.t = this.negone;\n\n        while ((this.t & this.one) == this.zero) {\n            this.s = this.s + 1;\n            this.t = this.t >> this.one;\n        }\n\n        this.nqr_to_t = this.pow(this.nqr, this.t);\n\n        buildSqrt(this);\n\n        this.FFT = new FFFT(this, this, this.mul.bind(this));\n\n        this.fft = this.FFT.fft.bind(this.FFT);\n        this.ifft = this.FFT.ifft.bind(this.FFT);\n        this.w = this.FFT.w;\n        this.wi = this.FFT.wi; \n    \n        this.shift = this.square(this.nqr);\n        this.k = this.exp(this.nqr, 2**this.s);\n    }\n\n    e(a,b) {\n        let res;\n        if (!b) {\n            res = BigInt(a);\n        } else if (b==16) {\n            res = BigInt(\"0x\"+a);\n        }\n        if (res < 0) {\n            let nres = -res;\n            if (nres >= this.p) nres = nres % this.p;\n            return this.p - nres;\n        } else {\n            return (res>= this.p) ? res%this.p : res;\n        }\n\n    }\n\n    add(a, b) {\n        const res = a + b;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    sub(a, b) {\n        return (a >= b) ? a-b : this.p-b+a;\n    }\n\n    neg(a) {\n        return a ? this.p-a : a;\n    }\n\n    mul(a, b) {\n        return (a*b)%this.p;\n    }\n\n    mulScalar(base, s) {\n        return (base * this.e(s)) % this.p;\n    }\n\n    square(a) {\n        return (a*a) % this.p;\n    }\n\n    eq(a, b) {\n        return a==b;\n    }\n\n    neq(a, b) {\n        return a!=b;\n    }\n\n    lt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa < bb;\n    }\n\n    gt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa > bb;\n    }\n\n    leq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa <= bb;\n    }\n\n    geq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa >= bb;\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    idiv(a, b) {\n        if (!b) throw new Error(\"Division by zero\");\n        return a / b;\n    }\n\n    inv(a) {\n        if (!a) throw new Error(\"Division by zero\");\n\n        let t = this.zero;\n        let r = this.p;\n        let newt = this.one;\n        let newr = a % this.p;\n        while (newr) {\n            let q = r/newr;\n            [t, newt] = [newt, t-q*newt];\n            [r, newr] = [newr, r-q*newr];\n        }\n        if (t<this.zero) t += this.p;\n        return t;\n    }\n\n    mod(a, b) {\n        return a % b;\n    }\n\n    pow(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    exp(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    band(a, b) {\n        const res =  ((a & b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bor(a, b) {\n        const res =  ((a | b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bxor(a, b) {\n        const res =  ((a ^ b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bnot(a) {\n        const res = a ^ this.mask;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    shl(a, b) {\n        if (Number(b) < this.bitLength) {\n            const res = (a << b) & this.mask;\n            return res >= this.p ? res-this.p : res;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                return a >> nb;\n            } else {\n                return this.zero;\n            }\n        }\n    }\n\n    shr(a, b) {\n        if (Number(b) < this.bitLength) {\n            return a >> b;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                const res = (a << nb) & this.mask;\n                return res >= this.p ? res-this.p : res;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    land(a, b) {\n        return (a && b) ? this.one : this.zero;\n    }\n\n    lor(a, b) {\n        return (a || b) ? this.one : this.zero;\n    }\n\n    lnot(a) {\n        return (a) ? this.zero : this.one;\n    }\n\n    sqrt_old(n) {\n\n        if (n == this.zero) return this.zero;\n\n        // Test that have solution\n        const res = this.pow(n, this.negone >> this.one);\n        if ( res != this.one ) return null;\n\n        let m = this.s;\n        let c = this.nqr_to_t;\n        let t = this.pow(n, this.t);\n        let r = this.pow(n, this.add(this.t, this.one) >> this.one );\n\n        while ( t != this.one ) {\n            let sq = this.square(t);\n            let i = 1;\n            while (sq != this.one ) {\n                i++;\n                sq = this.square(sq);\n            }\n\n            // b = c ^ m-i-1\n            let b = c;\n            for (let j=0; j< m-i-1; j ++) b = this.square(b);\n\n            m = i;\n            c = this.square(b);\n            t = this.mul(t, c);\n            r = this.mul(r, b);\n        }\n\n        if (r > (this.p >> this.one)) {\n            r = this.neg(r);\n        }\n\n        return r;\n    }\n\n    normalize(a, b) {\n        a = BigInt(a,b);\n        if (a < 0) {\n            let na = -a;\n            if (na >= this.p) na = na % this.p;\n            return this.p - na;\n        } else {\n            return (a>= this.p) ? a%this.p : a;\n        }\n    }\n\n    random() {\n        const nBytes = (this.bitLength*2 / 8);\n        let res =this.zero;\n        for (let i=0; i<nBytes; i++) {\n            res = (res << BigInt(8)) + BigInt(getRandomBytes(1)[0]);\n        }\n        return res % this.p;\n    }\n\n    toString(a, base) {\n        base = base || 10;\n        let vs;\n        if ((a > this.half)&&(base == 10)) {\n            const v = this.p-a;\n            vs = \"-\"+v.toString(base);\n        } else {\n            vs = a.toString(base);\n        }\n        return vs;\n    }\n\n    isZero(a) {\n        return a == this.zero;\n    }\n\n    fromRng(rng) {\n        let v;\n        do {\n            v=this.zero;\n            for (let i=0; i<this.n64; i++) {\n                v += rng.nextU64() << BigInt(64 *i);\n            }\n            v &= this.mask;\n        } while (v >= this.p);\n        v = (v * this.Ri) % this.p;   // Convert from montgomery\n        return v;\n    }\n\n    fft(a) {\n        return this.FFT.fft(a);\n    }\n\n    ifft(a) {\n        return this.FFT.ifft(a);\n    }\n\n    // Returns a buffer with Little Endian Representation\n    toRprLE(buff, o, e) {\n        Scalar.toRprLE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Representation\n    toRprBE(buff, o, e) {\n        Scalar.toRprBE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Montgomery Representation\n    toRprBEM(buff, o, e) {\n        return this.toRprBE(buff, o, this.mul(this.R, e));\n    }\n\n    toRprLEM(buff, o, e) {\n        return this.toRprLE(buff, o, this.mul(this.R, e));\n    }\n\n\n    // Pases a buffer with Little Endian Representation\n    fromRprLE(buff, o) {\n        return Scalar.fromRprLE(buff, o, this.n8);\n    }\n\n    // Pases a buffer with Big Endian Representation\n    fromRprBE(buff, o) {\n        return Scalar.fromRprBE(buff, o, this.n8);\n    }\n\n    fromRprLEM(buff, o) {\n        return this.mul(this.fromRprLE(buff, o), this.Ri);\n    }\n\n    fromRprBEM(buff, o) {\n        return this.mul(this.fromRprBE(buff, o), this.Ri);\n    }\n\n    toObject(a) {\n        return a;\n    }\n}", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as Scalar from \"./scalar.js\";\n\n\nexport function mulScalar(F, base, e) {\n    let res;\n\n    if (Scalar.isZero(e)) return F.zero;\n\n    const n = Scalar.naf(e);\n\n    if (n[n.length-1] == 1) {\n        res = base;\n    } else if (n[n.length-1] == -1) {\n        res = F.neg(base);\n    } else {\n        throw new Error(\"invlaud NAF\");\n    }\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.double(res);\n\n        if (n[i] == 1) {\n            res = F.add(res, base);\n        } else if (n[i] == -1) {\n            res = F.sub(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n/*\nexports.mulScalar = (F, base, e) =>{\n    let res = F.zero;\n    let rem = bigInt(e);\n    let exp = base;\n\n    while (! rem.eq(bigInt.zero)) {\n        if (rem.and(bigInt.one).eq(bigInt.one)) {\n            res = F.add(res, exp);\n        }\n        exp = F.double(exp);\n        rem = rem.shiftRight(1);\n    }\n\n    return res;\n};\n*/\n\n\nexport function exp(F, base, e) {\n\n    if (Scalar.isZero(e)) return F.one;\n\n    const n = Scalar.bits(e);\n\n    if (n.length==0) return F.one;\n\n    let res = base;\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.square(res);\n\n        if (n[i]) {\n            res = F.mul(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n", "import * as Scalar from \"./scalar.js\";\n// Check here: https://eprint.iacr.org/2012/685.pdf\n\nexport default function buildSqrt (F) {\n    if ((F.m % 2) == 1) {\n        if (Scalar.eq(Scalar.mod(F.p, 4), 1 )) {\n            if (Scalar.eq(Scalar.mod(F.p, 8), 1 )) {\n                if (Scalar.eq(Scalar.mod(F.p, 16), 1 )) {\n                    // alg7_muller(F);\n                    alg5_tonelliShanks(F);\n                } else if (Scalar.eq(Scalar.mod(F.p, 16), 9 )) {\n                    alg4_kong(F);\n                } else {\n                    throw new Error(\"Field withot sqrt\");\n                }\n            } else if (Scalar.eq(Scalar.mod(F.p, 8), 5 )) {\n                alg3_atkin(F);\n            } else {\n                throw new Error(\"Field withot sqrt\");\n            }\n        } else if (Scalar.eq(Scalar.mod(F.p, 4), 3 )) {\n            alg2_shanks(F);\n        }\n    } else {\n        const pm2mod4 = Scalar.mod(Scalar.pow(F.p, F.m/2), 4);\n        if (pm2mod4 == 1) {\n            alg10_adj(F);\n        } else if (pm2mod4 == 3) {\n            alg9_adj(F);\n        } else {\n            alg8_complex(F);\n        }\n\n    }\n}\n\n\nfunction alg5_tonelliShanks(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n\n    F.sqrt_s = 0;\n    F.sqrt_t = Scalar.sub(F.sqrt_q, 1);\n\n    while (!Scalar.isOdd(F.sqrt_t)) {\n        F.sqrt_s = F.sqrt_s + 1;\n        F.sqrt_t = Scalar.div(F.sqrt_t, 2);\n    }\n\n    let c0 = F.one;\n\n    while (F.eq(c0, F.one)) {\n        const c = F.random();\n        F.sqrt_z = F.pow(c, F.sqrt_t);\n        c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s-1) );\n    }\n\n    F.sqrt_tm1d2 = Scalar.div(Scalar.sub(F.sqrt_t, 1),2);\n\n    F.sqrt = function(a) {\n        const F=this;\n        if (F.isZero(a)) return F.zero;\n        let w = F.pow(a, F.sqrt_tm1d2);\n        const a0 = F.pow( F.mul(F.square(w), a), 2 ** (F.sqrt_s-1) );\n        if (F.eq(a0, F.negone)) return null;\n\n        let v = F.sqrt_s;\n        let x = F.mul(a, w);\n        let b = F.mul(x, w);\n        let z = F.sqrt_z;\n        while (!F.eq(b, F.one)) {\n            let b2k = F.square(b);\n            let k=1;\n            while (!F.eq(b2k, F.one)) {\n                b2k = F.square(b2k);\n                k++;\n            }\n\n            w = z;\n            for (let i=0; i<v-k-1; i++) {\n                w = F.square(w);\n            }\n            z = F.square(w);\n            b = F.mul(b, z);\n            x = F.mul(x, w);\n            v = k;\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg4_kong(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 4 not implemented\");\n    };\n}\n\nfunction alg3_atkin(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 3 not implemented\");\n    };\n}\n\nfunction alg2_shanks(F) {\n\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n    F.sqrt_e1 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n\n    F.sqrt = function(a) {\n        if (this.isZero(a)) return this.zero;\n\n        // Test that have solution\n        const a1 = this.pow(a, this.sqrt_e1);\n\n        const a0 = this.mul(this.square(a1), a);\n\n        if ( this.eq(a0, this.negone) ) return null;\n\n        const x = this.mul(a1, a);\n\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg10_adj(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 10 not implemented\");\n    };\n}\n\nfunction alg9_adj(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m/2);\n    F.sqrt_e34 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n    F.sqrt_e12 = Scalar.div( Scalar.sub(F.sqrt_q, 1) , 2);\n\n    F.frobenius = function(n, x) {\n        if ((n%2) == 1) {\n            return F.conjugate(x);\n        } else {\n            return x;\n        }\n    };\n\n    F.sqrt = function(a) {\n        const F = this;\n        const a1 = F.pow(a, F.sqrt_e34);\n        const alfa = F.mul(F.square(a1), a);\n        const a0 = F.mul(F.frobenius(1, alfa), alfa);\n        if (F.eq(a0, F.negone)) return null;\n        const x0 = F.mul(a1, a);\n        let x;\n        if (F.eq(alfa, F.negone)) {\n            x = F.mul(x0, [F.F.zero, F.F.one]);\n        } else {\n            const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n            x = F.mul(b, x0);\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\n\nfunction alg8_complex(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 8 not implemented\");\n    };\n}\n", "import ChaCha from \"./chacha.js\";\nimport crypto from \"crypto\";\n\nexport function getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (process.browser) { // Browser\n        if (typeof globalThis.crypto !== \"undefined\") { // Supported\n            globalThis.crypto.getRandomValues(array);\n        } else { // fallback\n            for (let i=0; i<n; i++) {\n                array[i] = (Math.random()*4294967296)>>>0;\n            }\n        }\n    }\n    else { // NodeJS\n        crypto.randomFillSync(array);\n    }\n    return array;\n}\n\nexport function getRandomSeed() {\n    const arr = getRandomBytes(32);\n    const arrV = new Uint32Array(arr.buffer);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed.push(arrV[i]);\n    }\n    return seed;\n}\n\nlet threadRng = null;\n\nexport function getThreadRng() {\n    if (threadRng) return threadRng;\n    threadRng = new ChaCha(getRandomSeed());\n    return threadRng;\n}\n", "\n\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction quarterRound(st, a, b, c, d) {\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 16) | ((st[d]>>>16) & 0xFFFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 12) | ((st[b]>>>20) & 0xFFF)) >>> 0;\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 8) | ((st[d]>>>24) & 0xFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 7) | ((st[b]>>>25) & 0x7F)) >>> 0;\n}\n\nfunction doubleRound(st) {\n    quarterRound(st, 0, 4, 8,12);\n    quarterRound(st, 1, 5, 9,13);\n    quarterRound(st, 2, 6,10,14);\n    quarterRound(st, 3, 7,11,15);\n\n    quarterRound(st, 0, 5,10,15);\n    quarterRound(st, 1, 6,11,12);\n    quarterRound(st, 2, 7, 8,13);\n    quarterRound(st, 3, 4, 9,14);\n}\n\nexport default class ChaCha {\n\n    constructor(seed) {\n        seed = seed || [0,0,0,0,0,0,0,0];\n        this.state = [\n            0x61707865,\n            0x3320646E,\n            0x79622D32,\n            0x6B206574,\n            seed[0],\n            seed[1],\n            seed[2],\n            seed[3],\n            seed[4],\n            seed[5],\n            seed[6],\n            seed[7],\n            0,\n            0,\n            0,\n            0\n        ];\n        this.idx = 16;\n        this.buff = new Array(16);\n    }\n\n    nextU32() {\n        if (this.idx == 16) this.update();\n        return this.buff[this.idx++];\n    }\n\n    nextU64() {\n        return Scalar.add(Scalar.mul(this.nextU32(), 0x100000000), this.nextU32());\n    }\n\n    nextBool() {\n        return (this.nextU32() & 1) == 1;\n    }\n\n    update() {\n        // Copy the state\n        for (let i=0; i<16; i++) this.buff[i] = this.state[i];\n\n        // Apply the rounds\n        for (let i=0; i<10; i++) doubleRound(this.buff);\n\n        // Add to the initial\n        for (let i=0; i<16; i++) this.buff[i] = (this.buff[i] + this.state[i]) >>> 0;\n\n        this.idx = 0;\n\n        this.state[12] = (this.state[12] + 1) >>> 0;\n        if (this.state[12] != 0) return;\n        this.state[13] = (this.state[13] + 1) >>> 0;\n        if (this.state[13] != 0) return;\n        this.state[14] = (this.state[14] + 1) >>> 0;\n        if (this.state[14] != 0) return;\n        this.state[15] = (this.state[15] + 1) >>> 0;\n    }\n}\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class FFT {\n    constructor (G, F, opMulGF) {\n        this.F = F;\n        this.G = G;\n        this.opMulGF = opMulGF;\n\n        let rem = F.sqrt_t || F.t;\n        let s = F.sqrt_s || F.s;\n\n        let nqr = F.one;\n        while (F.eq(F.pow(nqr, F.half), F.one)) nqr = F.add(nqr, F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(nqr, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n        /*\n        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n        */\n        this._setRoots(Math.min(s, 15));\n    }\n\n    _setRoots(n) {\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots[i] = rootsi;\n        }\n    }\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res = __fft(this, p, bits, 0, 1);\n        return res;\n    }\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res =  __fft(this, p, bits, 0, 1);\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.opMulGF(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n    }\n\n\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.G.add(pall[offset], pall[offset + step]),\n            PF.G.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n        out[i+ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n    }\n\n    return out;\n}\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\n\nexport default class F2Field {\n    constructor(F, nonResidue) {\n        this.type=\"F2\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*2;\n        this.p = F.p;\n        this.n64 = F.n64*2;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n\n        buildSqrt(this);\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    conjugate(a) {\n        return [\n            a[0],\n            this.F.neg(a[1])\n        ];\n    }\n\n    mul(a, b) {\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n\n        return [\n            this.F.add( aA , this._mulByNonResidue(bB)),\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]),\n                    this.F.add(b[0], b[1])),\n                this.F.add(aA, bB))];\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);\n        const t1 = this.F.square(a[1]);\n        const t2 = this.F.sub(t0, this._mulByNonResidue(t1));\n        const t3 = this.F.inv(t2);\n        return [\n            this.F.mul(a[0], t3),\n            this.F.neg(this.F.mul( a[1], t3)) ];\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const ab = this.F.mul(a[0] , a[1]);\n\n        /*\n        [\n            (a + b) * (a + non_residue * b) - ab - non_residue * ab,\n            ab + ab\n        ];\n        */\n\n        return [\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]) ,\n                    this.F.add(\n                        a[0] ,\n                        this._mulByNonResidue(a[1]))),\n                this.F.add(\n                    ab,\n                    this._mulByNonResidue(ab))),\n            this.F.add(ab, ab)\n        ];\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        return [c0, c1];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        return false;\n    }\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBE(buff, o);\n        const c0 = this.F.fromRprBE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBEM(buff, o);\n        const c0 = this.F.fromRprBEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    toObject(a) {\n        return a;\n    }\n\n}\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\n\nexport default class F3Field {\n    constructor(F, nonResidue) {\n        this.type=\"F3\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*3;\n        this.p = F.p;\n        this.n64 = F.n64*3;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1]), this.F.copy(a[2])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1]),\n            this.F.add(a[2], b[2])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1]),\n            this.F.sub(a[2], b[2])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    mul(a, b) {\n\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n        const cC = this.F.mul(a[2] , b[2]);\n\n        return [\n            this.F.add(\n                aA,\n                this._mulByNonResidue(\n                    this.F.sub(\n                        this.F.mul(\n                            this.F.add(a[1], a[2]),\n                            this.F.add(b[1], b[2])),\n                        this.F.add(bB, cC)))),    // aA + non_residue*((b+c)*(B+C)-bB-cC),\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[1]),\n                        this.F.add(b[0], b[1])),\n                    this.F.add(aA, bB)),\n                this._mulByNonResidue( cC)),   // (a+b)*(A+B)-aA-bB+non_residue*cC\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[2]),\n                        this.F.add(b[0], b[2])),\n                    this.F.add(aA, cC)),\n                bB)];                           // (a+c)*(A+C)-aA+bB-cC)\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);             // t0 = a^2 ;\n        const t1 = this.F.square(a[1]);             // t1 = b^2 ;\n        const t2 = this.F.square(a[2]);             // t2 = c^2;\n        const t3 = this.F.mul(a[0],a[1]);           // t3 = ab\n        const t4 = this.F.mul(a[0],a[2]);           // t4 = ac\n        const t5 = this.F.mul(a[1],a[2]);           // t5 = bc;\n        // c0 = t0 - non_residue * t5;\n        const c0 = this.F.sub(t0, this._mulByNonResidue(t5));\n        // c1 = non_residue * t2 - t3;\n        const c1 = this.F.sub(this._mulByNonResidue(t2), t3);\n        const c2 = this.F.sub(t1, t4);              // c2 = t1-t4\n\n        // t6 = (a * c0 + non_residue * (c * c1 + b * c2)).inv();\n        const t6 =\n            this.F.inv(\n                this.F.add(\n                    this.F.mul(a[0], c0),\n                    this._mulByNonResidue(\n                        this.F.add(\n                            this.F.mul(a[2], c1),\n                            this.F.mul(a[1], c2)))));\n\n        return [\n            this.F.mul(t6, c0),         // t6*c0\n            this.F.mul(t6, c1),         // t6*c1\n            this.F.mul(t6, c2)];        // t6*c2\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const s0 = this.F.square(a[0]);                   // s0 = a^2\n        const ab = this.F.mul(a[0], a[1]);                // ab = a*b\n        const s1 = this.F.add(ab, ab);                    // s1 = 2ab;\n        const s2 = this.F.square(\n            this.F.add(this.F.sub(a[0],a[1]), a[2]));     // s2 = (a - b + c)^2;\n        const bc = this.F.mul(a[1],a[2]);                 // bc = b*c\n        const s3 = this.F.add(bc, bc);                    // s3 = 2*bc\n        const s4 = this.F.square(a[2]);                   // s4 = c^2\n\n\n        return [\n            this.F.add(\n                s0,\n                this._mulByNonResidue(s3)),           // s0 + non_residue * s3,\n            this.F.add(\n                s1,\n                this._mulByNonResidue(s4)),           // s1 + non_residue * s4,\n            this.F.sub(\n                this.F.add( this.F.add(s1, s2) , s3 ),\n                this.F.add(s0, s4))];                      // s1 + s2 + s3 - s0 - s4\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]) && this.F.isZero(a[2]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]) && this.F.eq(a[2], b[2]);\n    }\n\n    affine(a) {\n        return [this.F.affine(a[0]), this.F.affine(a[1]), this.F.affine(a[2])];\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])}, ${this.F.toString(a[2])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        return [c0, c1, c2];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        if (this.F.gt(b[1], a[1])) return false;\n        if (this.F.gt(a[2], b[2])) return true;\n        return false;\n    }\n\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n        this.F.toRprLE(buff, o+this.F.n8*2, e[2]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[2]);\n        this.F.toRprBE(buff, o+this.F.n8, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8*2, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprLEM(buff, o+this.F.n8*2, e[2]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[2]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8*2, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.n8);\n        const c2 = this.F.fromRprLE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBE(buff, o);\n        const c1 = this.F.fromRprBE(buff, o+this.n8);\n        const c0 = this.F.fromRprBE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.n8);\n        const c2 = this.F.fromRprLEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBEM(buff, o);\n        const c1 = this.F.fromRprBEM(buff, o+this.n8);\n        const c0 = this.F.fromRprBEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nimport * as fUtils from \"./futils.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction isGreatest(F, a) {\n    if (Array.isArray(a)) {\n        for (let i=a.length-1; i>=0; i--) {\n            if (!F.F.isZero(a[i])) {\n                return isGreatest(F.F, a[i]);\n            }\n        }\n        return 0;\n    } else {\n        const na = F.neg(a);\n        return Scalar.gt(a, na);\n    }\n}\n\n\nexport default class EC {\n\n    constructor(F, g) {\n        this.F = F;\n        this.g = g;\n        if (this.g.length == 2) this.g[2] = this.F.one;\n        this.zero = [this.F.zero, this.F.one, this.F.zero];\n    }\n\n    add(p1, p2) {\n\n        const F = this.F;\n\n        if (this.eq(p1, this.zero)) return p2;\n        if (this.eq(p2, this.zero)) return p1;\n\n        const res = new Array(3);\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );     // U1 = X1  * Z2Z2\n        const U2 = F.mul( p2[0] , Z1Z1 );     // U2 = X2  * Z1Z1\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);  // S1 = Y1 * Z2 * Z2Z2\n        const S2 = F.mul( p2[1] , Z1_cubed);  // S2 = Y2 * Z1 * Z1Z1\n\n        if (F.eq(U1,U2) && F.eq(S1,S2)) {\n            return this.double(p1);\n        }\n\n        const H = F.sub( U2 , U1 );                    // H = U2-U1\n\n        const S2_minus_S1 = F.sub( S2 , S1 );\n\n        const I = F.square( F.add(H,H) );         // I = (2 * H)^2\n        const J = F.mul( H , I );                      // J = H * I\n\n        const r = F.add( S2_minus_S1 , S2_minus_S1 );  // r = 2 * (S2-S1)\n        const V = F.mul( U1 , I );                     // V = U1 * I\n\n        res[0] =\n            F.sub(\n                F.sub( F.square(r) , J ),\n                F.add( V , V ));                       // X3 = r^2 - J - 2 * V\n\n        const S1_J = F.mul( S1 , J );\n\n        res[1] =\n            F.sub(\n                F.mul( r , F.sub(V,res[0])),\n                F.add( S1_J,S1_J ));                   // Y3 = r * (V-X3)-2 S1 J\n\n        res[2] =\n            F.mul(\n                H,\n                F.sub(\n                    F.square( F.add(p1[2],p2[2]) ),\n                    F.add( Z1Z1 , Z2Z2 )));            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2) * H\n\n        return res;\n    }\n\n    neg(p) {\n        return [p[0], this.F.neg(p[1]), p[2]];\n    }\n\n    sub(a, b) {\n        return this.add(a, this.neg(b));\n    }\n\n    double(p) {\n        const F = this.F;\n\n        const res = new Array(3);\n\n        if (this.eq(p, this.zero)) return p;\n\n        const A = F.square( p[0] );                    // A = X1^2\n        const B = F.square( p[1] );                    // B = Y1^2\n        const C = F.square( B );                       // C = B^2\n\n        let D =\n            F.sub(\n                F.square( F.add(p[0] , B )),\n                F.add( A , C));\n        D = F.add(D,D);                    // D = 2 * ((X1 + B)^2 - A - C)\n\n        const E = F.add( F.add(A,A), A);          // E = 3 * A\n        const FF =F.square( E );                       // F = E^2\n\n        res[0] = F.sub( FF , F.add(D,D) );         // X3 = F - 2 D\n\n        let eightC = F.add( C , C );\n        eightC = F.add( eightC , eightC );\n        eightC = F.add( eightC , eightC );\n\n        res[1] =\n            F.sub(\n                F.mul(\n                    E,\n                    F.sub( D, res[0] )),\n                eightC);                                    // Y3 = E * (D - X3) - 8 * C\n\n        const Y1Z1 = F.mul( p[1] , p[2] );\n        res[2] = F.add( Y1Z1 , Y1Z1 );                 // Z3 = 2 * Y1 * Z1\n\n        return res;\n    }\n\n    timesScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    affine(p) {\n        const F = this.F;\n        if (this.isZero(p)) {\n            return this.zero;\n        } else if (F.eq(p[2], F.one)) {\n            return p;\n        } else {\n            const Z_inv = F.inv(p[2]);\n            const Z2_inv = F.square(Z_inv);\n            const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n            const res = new Array(3);\n            res[0] = F.mul(p[0],Z2_inv);\n            res[1] = F.mul(p[1],Z3_inv);\n            res[2] = F.one;\n\n            return res;\n        }\n    }\n\n    multiAffine(arr) {\n        const keys = Object.keys(arr);\n        const F = this.F;\n        const accMul = new Array(keys.length+1);\n        accMul[0] = F.one;\n        for (let i = 0; i< keys.length; i++) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i+1] = accMul[i];\n            } else {\n                accMul[i+1] = F.mul(accMul[i], arr[keys[i]][2]);\n            }\n        }\n\n        accMul[keys.length] = F.inv(accMul[keys.length]);\n\n        for (let i = keys.length-1; i>=0; i--) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i] = accMul[i+1];\n                arr[keys[i]] = this.zero;\n            } else {\n                const Z_inv = F.mul(accMul[i], accMul[i+1]);\n                accMul[i] = F.mul(arr[keys[i]][2], accMul[i+1]);\n\n                const Z2_inv = F.square(Z_inv);\n                const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n                arr[keys[i]][0] = F.mul(arr[keys[i]][0],Z2_inv);\n                arr[keys[i]][1] = F.mul(arr[keys[i]][1],Z3_inv);\n                arr[keys[i]][2] = F.one;\n            }\n        }\n\n    }\n\n    eq(p1, p2) {\n        const F = this.F;\n\n        if (this.F.eq(p1[2], this.F.zero)) return this.F.eq(p2[2], this.F.zero);\n        if (this.F.eq(p2[2], this.F.zero)) return false;\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );\n        const U2 = F.mul( p2[0] , Z1Z1 );\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);\n        const S2 = F.mul( p2[1] , Z1_cubed);\n\n        return (F.eq(U1,U2) && F.eq(S1,S2));\n    }\n\n    isZero(p) {\n        return this.F.isZero(p[2]);\n    }\n\n    toString(p) {\n        const cp = this.affine(p);\n        return `[ ${this.F.toString(cp[0])} , ${this.F.toString(cp[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n            P[1] = F.sqrt(x3b);\n        } while ((P[1] == null)||(F.isZero[P]));\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        if (this.cofactor) {\n            P = this.mulScalar(P, this.cofactor);\n        }\n\n        P = this.affine(P);\n\n        return P;\n\n    }\n\n    toRprLE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLE(buff, o, p[0]);\n        this.F.toRprLE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprBE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n        this.F.toRprBE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEJM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n        this.F.toRprLEM(buff, o+2*this.F.n8, p[2]);\n    }\n\n\n    toRprBEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBEM(buff, o, p[0]);\n        this.F.toRprBEM(buff, o+this.F.n8, p[1]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLE(buff, o);\n        const y = this.F.fromRprLE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBE(buff, o);\n        const y = this.F.fromRprBE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEJM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        const z = this.F.fromRprLEM(buff, o+this.F.n8*2);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, z];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBEM(buff, o);\n        const y = this.F.fromRprBEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprCompressed(buff, o) {\n        const F = this.F;\n        const v = new Uint8Array(buff.buffer, o, F.n8);\n        if (v[0] & 0x40) return this.zero;\n        const P = new Array(3);\n\n        const greatest = ((v[0] & 0x80) != 0);\n        v[0] = v[0] & 0x7F;\n        P[0] = F.fromRprBE(buff, o);\n        if (greatest) v[0] = v[0] | 0x80;  // set back again the old value\n\n        const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        P[1] = F.sqrt(x3b);\n\n        if (P[1] === null) {\n            throw new Error(\"Invalid Point!\");\n        }\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        return P;\n    }\n\n    toRprCompressed(buff, o, p) {\n        p = this.affine(p);\n        const v = new Uint8Array(buff.buffer, o, this.F.n8);\n        if (this.isZero(p)) {\n            v.fill(0);\n            v[0] = 0x40;\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n\n        if (isGreatest(this.F, p[1])) {\n            v[0] = v[0] | 0x80;\n        }\n    }\n\n\n    fromRprUncompressed(buff, o) {\n        if (buff[0] & 0x40) return this.zero;\n\n        return this.fromRprBE(buff, o);\n    }\n\n    toRprUncompressed(buff, o, p) {\n        this.toRprBE(buff, o, p);\n\n        if (this.isZero(p)) {\n            buff[o] = buff[o] | 0x40;\n        }\n    }\n\n\n}\n\n\n", "import { buildBn128 as buildBn128wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bn128 = null;\n\nexport default async function buildBn128(singleThread, plugins) {\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBn128wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bn128wasm = {};\n\n    bn128wasm.code = moduleBuilder.build();\n    bn128wasm.pq = moduleBuilder.modules.f1m.pq;\n    bn128wasm.pr = moduleBuilder.modules.frm.pq;\n    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;\n    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;\n    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;\n    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;\n    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;\n    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;\n    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;\n    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;\n    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;\n    bn128wasm.n8q = 32;\n    bn128wasm.n8r = 32;\n    bn128wasm.q = moduleBuilder.modules.bn128.q;\n    bn128wasm.r = moduleBuilder.modules.bn128.r;\n\n    if ((!singleThread) && (globalThis.curve_bn128)) return globalThis.curve_bn128;\n    const params = {\n        name: \"bn128\",\n        wasm: bn128wasm,\n        q: Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\"),\n        r: Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\"),\n        n8q: 32,\n        n8r: 32,\n        cofactorG2: Scalar.e(\"30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bn128 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bn128 = curve;\n    }\n\n    return curve;\n}\n\n", "import WasmField1 from \"./wasm_field1.js\";\nimport WasmField2 from \"./wasm_field2.js\";\nimport WasmField3 from \"./wasm_field3.js\";\nimport WasmCurve from \"./wasm_curve.js\";\nimport buildThreadManager from \"./threadman.js\";\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchApplyKey from \"./engine_applykey.js\";\nimport buildPairing from \"./engine_pairing.js\";\nimport buildMultiExp from \"./engine_multiexp.js\";\nimport buildFFT from \"./engine_fft.js\";\n\nexport default async function buildEngine(params) {\n\n    const tm = await buildThreadManager(params.wasm, params.singleThread);\n\n\n    const curve = {};\n\n    curve.q = Scalar.e(params.wasm.q.toString());\n    curve.r = Scalar.e(params.wasm.r.toString());\n    curve.name = params.name;\n    curve.tm = tm;\n    curve.prePSize = params.wasm.prePSize;\n    curve.preQSize = params.wasm.preQSize;\n    curve.Fr = new WasmField1(tm, \"frm\", params.n8r, params.r);\n    curve.F1 = new WasmField1(tm, \"f1m\", params.n8q, params.q);\n    curve.F2 = new WasmField2(tm, \"f2m\", curve.F1);\n    curve.G1 = new WasmCurve(tm, \"g1m\", curve.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);\n    curve.G2 = new WasmCurve(tm, \"g2m\", curve.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);\n    curve.F6 = new WasmField3(tm, \"f6m\", curve.F2);\n    curve.F12 = new WasmField2(tm, \"ftm\", curve.F6);\n\n    curve.Gt = curve.F12;\n\n    buildBatchApplyKey(curve, \"G1\");\n    buildBatchApplyKey(curve, \"G2\");\n    buildBatchApplyKey(curve, \"Fr\");\n\n    buildMultiExp(curve, \"G1\");\n    buildMultiExp(curve, \"G2\");\n\n    buildFFT(curve, \"G1\");\n    buildFFT(curve, \"G2\");\n    buildFFT(curve, \"Fr\");\n\n    buildPairing(curve);\n\n    curve.array2buffer = function(arr, sG) {\n        const buff = new Uint8Array(sG*arr.length);\n\n        for (let i=0; i<arr.length; i++) {\n            buff.set(arr[i], i*sG);\n        }\n\n        return buff;\n    };\n\n    curve.buffer2array = function(buff , sG) {\n        const n= buff.byteLength / sG;\n        const arr = new Array(n);\n        for (let i=0; i<n; i++) {\n            arr[i] = buff.slice(i*sG, i*sG+sG);\n        }\n        return arr;\n    };\n\n    return curve;\n}\n\n\n", "import * as Scalar from \"./scalar.js\";\nimport * as utils from \"./utils.js\";\nimport { getThreadRng } from \"./random.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default class WasmField1 {\n\n    constructor(tm, prefix, n8, p) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.p = p;\n        this.n8 = n8;\n        this.type = \"F1\";\n        this.m = 1;\n\n        this.half = Scalar.shiftRight(p, Scalar.one);\n        this.bitLength = Scalar.bitLength(p);\n        this.mask = Scalar.sub(Scalar.shiftLeft(Scalar.one, this.bitLength), Scalar.one);\n\n        this.pOp1 = tm.alloc(n8);\n        this.pOp2 = tm.alloc(n8);\n        this.pOp3 = tm.alloc(n8);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = this.tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.n64 = Math.floor(n8/8);\n        this.n32 = Math.floor(n8/4);\n\n        if(this.n64*8 != this.n8) {\n            throw new Error(\"n8 must be a multiple of 8\");\n        }\n\n        this.half = Scalar.shiftRight(this.p, Scalar.one);\n        this.nqr = this.two;\n        let r = this.exp(this.nqr, this.half);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.add(this.nqr, this.one);\n            r = this.exp(this.nqr, this.half);\n        }\n\n        this.shift = this.mul(this.nqr, this.nqr);\n        this.shiftInv = this.inv(this.shift);\n\n        this.s = 0;\n        let t = Scalar.sub(this.p, Scalar.one);\n\n        while ( !Scalar.isOdd(t) ) {\n            this.s = this.s + 1;\n            t = Scalar.shiftRight(t, Scalar.one);\n        }\n\n        this.w = [];\n        this.w[this.s] = this.exp(this.nqr, t);\n\n        for (let i= this.s-1; i>=0; i--) {\n            this.w[i] = this.square(this.w[i+1]);\n        }\n\n        if (!this.eq(this.w[0], this.one)) {\n            throw new Error(\"Error calculating roots of unity\");\n        }\n\n        this.batchToMontgomery = buildBatchConvert(tm, prefix + \"_batchToMontgomery\", this.n8, this.n8);\n        this.batchFromMontgomery = buildBatchConvert(tm, prefix + \"_batchFromMontgomery\", this.n8, this.n8);\n    }\n\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        let ra = Scalar.e(a, b);\n        if (Scalar.isNegative(ra)) {\n            ra = Scalar.neg(ra);\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n            ra = Scalar.sub(this.p, ra);\n        } else {\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n        }\n        const buff = utils.leInt2Buff(ra, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toString(a, radix) {\n        const an = this.fromMontgomery(a);\n        const s = Scalar.fromRprLE(an, 0);\n        return Scalar.toString(s, radix);\n    }\n\n    fromRng(rng) {\n        let v;\n        const buff = new Uint8Array(this.n8);\n        do {\n            v = Scalar.zero;\n            for (let i=0; i<this.n64; i++) {\n                v = Scalar.add(v,  Scalar.shiftLeft(rng.nextU64(), 64*i));\n            }\n            v = Scalar.band(v, this.mask);\n        } while (Scalar.geq(v, this.p));\n        Scalar.toRprLE(buff, 0, v, this.n8);\n        return buff;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const an = this.fromMontgomery(a);\n        return Scalar.fromRprLE(an, 0);\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.n8);\n        Scalar.toRprLE(buff, 0, a, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toRprLE(buff, offset, a) {\n        buff.set(this.fromMontgomery(a), offset);\n    }\n\n    toRprBE(buff, offset, a) {\n        const buff2 = this.fromMontgomery(a);\n        for (let i=0; i<this.n8/2; i++) {\n            const aux = buff2[i];\n            buff2[i] = buff2[this.n8-1-i];\n            buff2[this.n8-1-i] = aux;\n        }\n        buff.set(buff2, offset);\n    }\n\n    fromRprLE(buff, offset) {\n        offset = offset || 0;\n        const res = buff.slice(offset, offset + this.n8);\n        return this.toMontgomery(res);\n    }\n\n    async batchInverse(buffIn) {\n        let returnArray = false;\n        const sIn = this.n8;\n        const sOut = this.n8;\n\n        if (Array.isArray(buffIn)) {\n            buffIn = utils.array2buffer(buffIn, sIn );\n            returnArray = true;\n        } else {\n            buffIn = buffIn.slice(0, buffIn.byteLength);\n        }\n\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/this.tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<this.tm.concurrency; i++) {\n            let n;\n            if (i< this.tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: this.prefix + \"_batchInverse\", params: [\n                    {var: 0},\n                    {val: sIn},\n                    {val: n},\n                    {var: 1},\n                    {val: sOut},\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                this.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        if (returnArray) {\n            return utils.buffer2array(fullBuffOut, sOut);\n        } else {\n            return fullBuffOut;\n        }\n\n    }\n\n}\n\n\n", "/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\n\nexport function stringifyBigInts(o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return Scalar.fromRprLE(o, 0);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigInts);\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyBigInts(o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return BigInt(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return BigInt(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyBigInts);\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function beBuff2int(buff) {\n    let res = BigInt(0);\n    let i = buff.length;\n    let offset = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i > 0) {\n        if (i >= 4) {\n            i -= 4;\n            res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);\n            offset += 4;\n        } else if (i >= 2) {\n            i -= 2;\n            res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);\n            offset += 2;\n        } else {\n            i -= 1;\n            res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);\n            offset += 1;\n        }\n    }\n    return res;\n}\n\nexport function beInt2Buff(n, len) {\n    let r = n;\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = len;\n    while (o > 0) {\n        if (o - 4 >= 0) {\n            o -= 4;\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)));\n            r = r >> BigInt(32);\n        } else if (o - 2 >= 0) {\n            o -= 2;\n            buffV.setUint16(o, Number(r & BigInt(0xffff)));\n            r = r >> BigInt(16);\n        } else {\n            o -= 1;\n            buffV.setUint8(o, Number(r & BigInt(0xff)));\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function leBuff2int(buff) {\n    let res = BigInt(0);\n    let i = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i < buff.length) {\n        if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);\n            i += 4;\n        } else if (i + 2 <= buff.length) {\n            res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);\n            i += 2;\n        } else {\n            res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);\n            i += 1;\n        }\n    }\n    return res;\n}\n\nexport function leInt2Buff(n, len) {\n    let r = n;\n    if (typeof len === \"undefined\") {\n        len = Math.floor((Scalar.bitLength(n) - 1) / 8) + 1;\n        if (len == 0) len = 1;\n    }\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = 0;\n    while (o < len) {\n        if (o + 4 <= len) {\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)), true);\n            o += 4;\n            r = r >> BigInt(32);\n        } else if (o + 2 <= len) {\n            buffV.setUint16(o, Number(r & BigInt(0xffff)), true);\n            o += 2;\n            r = r >> BigInt(16);\n        } else {\n            buffV.setUint8(o, Number(r & BigInt(0xff)), true);\n            o += 1;\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function stringifyFElements(F, o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return F.toString(F.e(o));\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyFElements(F, o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return F.e(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return F.e(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nconst _revTable = [];\nfor (let i = 0; i < 256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res = 0;\n    let a = idx;\n    for (let i = 0; i < bits; i++) {\n        res <<= 1;\n        res = res | (a & 1);\n        a >>= 1;\n    }\n    return res;\n}\n\nexport function bitReverse(idx, bits) {\n    return (\n        (_revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xff] << 8) |\n        (_revTable[(idx >>> 8) & 0xff] << 16) |\n        (_revTable[idx & 0xff] << 24)) >>>\n        (32 - bits)\n    );\n}\n\nexport function log2(V) {\n    return (\n        ((V & 0xffff0000) !== 0 ? ((V &= 0xffff0000), 16) : 0) |\n        ((V & 0xff00ff00) !== 0 ? ((V &= 0xff00ff00), 8) : 0) |\n        ((V & 0xf0f0f0f0) !== 0 ? ((V &= 0xf0f0f0f0), 4) : 0) |\n        ((V & 0xcccccccc) !== 0 ? ((V &= 0xcccccccc), 2) : 0) |\n        ((V & 0xaaaaaaaa) !== 0)\n    );\n}\n\nexport function buffReverseBits(buff, eSize) {\n    const n = buff.byteLength / eSize;\n    const bits = log2(n);\n    if (n != 1 << bits) {\n        throw new Error(\"Invalid number of pointers\");\n    }\n    for (let i = 0; i < n; i++) {\n        const r = bitReverse(i, bits);\n        if (i > r) {\n            const tmp = buff.slice(i * eSize, (i + 1) * eSize);\n            buff.set(buff.slice(r * eSize, (r + 1) * eSize), i * eSize);\n            buff.set(tmp, r * eSize);\n        }\n    }\n}\n\nexport function array2buffer(arr, sG) {\n    const buff = new Uint8Array(sG * arr.length);\n\n    for (let i = 0; i < arr.length; i++) {\n        buff.set(arr[i], i * sG);\n    }\n\n    return buff;\n}\n\nexport function buffer2array(buff, sG) {\n    const n = buff.byteLength / sG;\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = buff.slice(i * sG, i * sG + sG);\n    }\n    return arr;\n}\n", "import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchConvert(tm, fnName, sIn, sOut) {\n    return async function batchConvert(buffIn) {\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1}\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n", "\nconst PAGE_SIZE = 1<<30;\n\nexport default class BigBuffer {\n\n    constructor(size) {\n        this.buffers = [];\n        this.byteLength = size;\n        for (let i=0; i<size; i+= PAGE_SIZE) {\n            const n = Math.min(size-i, PAGE_SIZE);\n            this.buffers.push(new Uint8Array(n));\n        }\n\n    }\n\n    slice(fr, to) {\n        if ( to === undefined ) to = this.byteLength;\n        if ( fr === undefined ) fr = 0;\n        const len = to-fr;\n\n        const firstPage = Math.floor(fr / PAGE_SIZE);\n        const lastPage = Math.floor((fr+len-1) / PAGE_SIZE);\n\n        if ((firstPage == lastPage)||(len==0))\n            return this.buffers[firstPage].slice(fr%PAGE_SIZE, fr%PAGE_SIZE + len);\n\n        let buff;\n\n        let p = firstPage;\n        let o = fr % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset+o, l);\n            if (l == len) return srcView.slice();\n            if (!buff) {\n                if (len <= PAGE_SIZE) {\n                    buff = new Uint8Array(len);\n                } else {\n                    buff = new BigBuffer(len);\n                }\n            }\n            buff.set(srcView, len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        return buff;\n    }\n\n    set(buff, offset) {\n        if (offset === undefined) offset = 0;\n\n        const len = buff.byteLength;\n\n        if (len==0) return;\n\n        const firstPage = Math.floor(offset / PAGE_SIZE);\n        const lastPage = Math.floor((offset+len-1) / PAGE_SIZE);\n\n        if (firstPage == lastPage) {\n            if ((buff instanceof BigBuffer)&&(buff.buffers.length==1)) {\n                return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);\n            } else {\n                return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);\n            }\n\n        }\n\n\n        let p = firstPage;\n        let o = offset % PAGE_SIZE;\n        let r = len;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice( len -r, len -r+l);\n            const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n    }\n}\n", "import { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField2 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F2\";\n        this.m = F.m * 2;\n        this.n8 = this.F.n8*2;\n        this.n32 = this.F.n32*2;\n        this.n64 = this.F.n64*2;\n\n        this.pOp1 = tm.alloc(F.n8*2);\n        this.pOp2 = tm.alloc(F.n8*2);\n        this.pOp3 = tm.alloc(F.n8*2);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    mul1(a,b) {\n        return this.op2(\"_mul1\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 2)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const res = new Uint8Array(this.F.n8*2);\n            res.set(c1);\n            res.set(c2, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F2\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8), radix);\n        return `[${s1}, ${s2}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*2);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        return [c1, c2];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8);\n    }\n\n}\n\n", "\n\nimport { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField3 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F3\";\n        this.m = F.m * 3;\n        this.n8 = this.F.n8*3;\n        this.n32 = this.F.n32*3;\n        this.n64 = this.F.n64*3;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 3)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const c3 = this.F.e(a[2], b);\n            const res = new Uint8Array(this.F.n8*3);\n            res.set(c1);\n            res.set(c2, this.F.n8);\n            res.set(c3, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F3\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n        const s3 = this.F.toString(a.slice(this.F.n8*2), radix);\n        return `[${s1}, ${s2}, ${s3}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const c3 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*3);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        res.set(c3, this.F.n8*2);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        const c3 = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        return [c1, c2, c3];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*3);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        const b3 = this.F.fromObject(a[2]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        buff.set(b3, this.F.n8*2);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8, this.F.n8*2);\n    }\n\n    c3(a) {\n        return a.slice(this.F.n8*2);\n    }\n\n}\n\n\n", "\n\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\n\nexport default class WasmCurve {\n\n    constructor(tm, prefix, F, pGen, pGb, cofactor) {\n        this.tm = tm;\n        this.prefix = prefix;\n        this.F = F;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, F.n8*3);\n        this.tm.instance.exports[prefix + \"_zeroAffine\"](this.pOp1);\n        this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8*2);\n        this.one = this.tm.getBuff(pGen, F.n8*3);\n        this.g = this.one;\n        this.oneAffine = this.tm.getBuff(pGen, F.n8*2);\n        this.gAffine = this.oneAffine;\n        this.b = this.tm.getBuff(pGb, F.n8);\n\n        if (cofactor) {\n            this.cofactor = Scalar.toLEBuff(cofactor);\n        }\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.batchLEMtoC = buildBatchConvert(tm, prefix + \"_batchLEMtoC\", F.n8*2, F.n8);\n        this.batchLEMtoU = buildBatchConvert(tm, prefix + \"_batchLEMtoU\", F.n8*2, F.n8*2);\n        this.batchCtoLEM = buildBatchConvert(tm, prefix + \"_batchCtoLEM\", F.n8, F.n8*2);\n        this.batchUtoLEM = buildBatchConvert(tm, prefix + \"_batchUtoLEM\", F.n8*2, F.n8*2);\n        this.batchToJacobian = buildBatchConvert(tm, prefix + \"_batchToJacobian\", F.n8*2, F.n8*3);\n        this.batchToAffine = buildBatchConvert(tm, prefix + \"_batchToAffine\", F.n8*3, F.n8*2);\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op2bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op1Affine(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*2);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_add\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_addMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    sub(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_sub\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_subMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    neg(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_neg\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Affine(\"_negAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    double(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_double\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_doubleAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isZero(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Bool(\"_isZero\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Bool(\"_isZeroAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    timesScalar(a, s) {\n        if (!(s instanceof Uint8Array)) {\n            s = Scalar.toLEBuff(Scalar.e(s));\n        }\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesScalar\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesScalarAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    timesFr(a, s) {\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesFr\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesFrAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    eq(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eq\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eqMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toAffine(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Affine(\"_toAffine\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return a;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toJacobian(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return a;\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_toJacobian\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toRprUncompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoU\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n        arr.set(res, offset);\n    }\n\n    fromRprUncompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8*2);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_UtoLEM\"](this.pOp1, this.pOp1);\n        return this.tm.getBuff(this.pOp1, this.F.n8*2);\n    }\n\n    toRprCompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoC\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8);\n        arr.set(res, offset);\n    }\n\n    fromRprCompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_CtoLEM\"](this.pOp1, this.pOp2);\n        return this.tm.getBuff(this.pOp2, this.F.n8*2);\n    }\n\n    toUncompressed(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        this.toRprUncompressed(buff, 0, a);\n        return buff;\n    }\n\n    toRprLEM(arr, offset, a) {\n        if (a.byteLength == this.F.n8*2) {\n            arr.set(a, offset);\n            return;\n        } else if (a.byteLength == this.F.n8*3) {\n            this.tm.setBuff(this.pOp1, a);\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n            const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n            arr.set(res, offset);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    fromRprLEM(arr, offset) {\n        offset = offset || 0;\n        return arr.slice(offset, offset+this.F.n8*2);\n    }\n\n    toString(a, radix) {\n        if (a.byteLength == this.F.n8*3) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n            const z = this.F.toString(a.slice(this.F.n8*2), radix);\n            return `[ ${x}, ${y}, ${z} ]`;\n        } else if (a.byteLength == this.F.n8*2) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8), radix);\n            return `[ ${x}, ${y} ]`;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isValid(a) {\n        if (this.isZero(a)) return true;\n        const F = this.F;\n        const aa = this.toAffine(a);\n        const x = aa.slice(0, this.F.n8);\n        const y = aa.slice(this.F.n8, this.F.n8*2);\n        const x3b = F.add(F.mul(F.square(x),x), this.b);\n        const y2 = F.square(y);\n        return F.eq(x3b, y2);\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        let x3b;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        } while (!F.isSquare(x3b));\n\n        P[1] = F.sqrt(x3b);\n\n        const s = F.isNegative(P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n\n        let Pbuff = new Uint8Array(this.F.n8*2);\n        Pbuff.set(P[0]);\n        Pbuff.set(P[1], this.F.n8);\n\n        if (this.cofactor) {\n            Pbuff = this.timesScalar(Pbuff, this.cofactor);\n        }\n\n        return Pbuff;\n    }\n\n\n\n    toObject(a) {\n        if (this.isZero(a)) {\n            return [\n                this.F.toObject(this.F.zero),\n                this.F.toObject(this.F.one),\n                this.F.toObject(this.F.zero),\n            ];\n        }\n        const x = this.F.toObject(a.slice(0, this.F.n8));\n        const y = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        let z;\n        if (a.byteLength == this.F.n8*3) {\n            z = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        } else {\n            z = this.F.toObject(this.F.one);\n        }\n        return [x, y, z];\n    }\n\n    fromObject(a) {\n        const x = this.F.fromObject(a[0]);\n        const y = this.F.fromObject(a[1]);\n        let z;\n        if (a.length==3) {\n            z = this.F.fromObject(a[2]);\n        } else {\n            z = this.F.one;\n        }\n        if (this.F.isZero(z, this.F.one)) {\n            return this.zeroAffine;\n        } else if (this.F.eq(z, this.F.one)) {\n            const buff = new Uint8Array(this.F.n8*2);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            return buff;\n        } else {\n            const buff = new Uint8Array(this.F.n8*3);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            buff.set(z, this.F.n8*2);\n            return buff;\n        }\n    }\n\n    e(a) {\n        if (a instanceof Uint8Array) return a;\n        return this.fromObject(a);\n    }\n\n    x(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(0, this.F.n8);\n    }\n\n    y(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(this.F.n8);\n    }\n\n}\n\n\n", "/* global navigator, WebAssembly */\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// const MEM_SIZE = 1000;  // Memory size in 64K Pakes (512Mb)\nconst MEM_SIZE = 25;  // Memory size in 64K Pakes (1600Kb)\n\n\nimport thread from \"./threadman_thread.js\";\nimport os from \"os\";\nimport Worker from \"web-worker\";\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject)=> {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction stringToBase64(str) {\n    if (process.browser) {\n        return globalThis.btoa(str);\n    } else {\n        return Buffer.from(str).toString(\"base64\");\n    }\n}\n\nconst threadSource = stringToBase64(\"(\" + thread.toString() + \")(self)\");\nconst workerSource = \"data:application/javascript;base64,\" + threadSource;\n\n\n\nexport default async function buildThreadManager(wasm, singleThread) {\n    const tm = new ThreadManager();\n\n    tm.memory = new WebAssembly.Memory({initial:MEM_SIZE});\n    tm.u8 = new Uint8Array(tm.memory.buffer);\n    tm.u32 = new Uint32Array(tm.memory.buffer);\n\n    const wasmModule = await WebAssembly.compile(wasm.code);\n\n    tm.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": tm.memory\n        }\n    });\n\n    tm.singleThread = singleThread;\n    tm.initalPFree = tm.u32[0];   // Save the Pointer to free space.\n    tm.pq = wasm.pq;\n    tm.pr = wasm.pr;\n    tm.pG1gen = wasm.pG1gen;\n    tm.pG1zero = wasm.pG1zero;\n    tm.pG2gen = wasm.pG2gen;\n    tm.pG2zero = wasm.pG2zero;\n    tm.pOneT = wasm.pOneT;\n\n    //    tm.pTmp0 = tm.alloc(curve.G2.F.n8*3);\n    //    tm.pTmp1 = tm.alloc(curve.G2.F.n8*3);\n\n\n    if (singleThread) {\n        tm.code = wasm.code;\n        tm.taskManager = thread();\n        await tm.taskManager([{\n            cmd: \"INIT\",\n            init: MEM_SIZE,\n            code: tm.code.slice()\n        }]);\n        tm.concurrency  = 1;\n    } else {\n        tm.workers = [];\n        tm.pendingDeferreds = [];\n        tm.working = [];\n\n        let concurrency;\n\n        if ((typeof(navigator) === \"object\") && navigator.hardwareConcurrency) {\n            concurrency = navigator.hardwareConcurrency;\n        } else {\n            concurrency = os.cpus().length;\n        }\n\n        if(concurrency == 0){\n            concurrency = 2;\n        }\n\n        // Limit to 64 threads for memory reasons.\n        if (concurrency>64) concurrency=64;\n        tm.concurrency = concurrency;\n\n        for (let i = 0; i<concurrency; i++) {\n\n            tm.workers[i] = new Worker(workerSource);\n\n            tm.workers[i].addEventListener(\"message\", getOnMsg(i));\n\n            tm.working[i]=false;\n        }\n\n        const initPromises = [];\n        for (let i=0; i<tm.workers.length;i++) {\n            const copyCode = wasm.code.slice();\n            initPromises.push(tm.postAction(i, [{\n                cmd: \"INIT\",\n                init: MEM_SIZE,\n                code: copyCode\n            }], [copyCode.buffer]));\n        }\n\n        await Promise.all(initPromises);\n\n    }\n    return tm;\n\n    function getOnMsg(i) {\n        return function(e) {\n            let data;\n            if ((e)&&(e.data)) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            tm.working[i]=false;\n            tm.pendingDeferreds[i].resolve(data);\n            tm.processWorks();\n        };\n    }\n\n}\n\nclass ThreadManager {\n    constructor() {\n        this.actionQueue = [];\n        this.oldPFree = 0;\n    }\n\n    startSyncOp() {\n        if (this.oldPFree != 0) throw new Error(\"Sync operation in progress\");\n        this.oldPFree = this.u32[0];\n    }\n\n    endSyncOp() {\n        if (this.oldPFree == 0) throw new Error(\"No sync operation in progress\");\n        this.u32[0] = this.oldPFree;\n        this.oldPFree = 0;\n    }\n\n    postAction(workerId, e, transfers, _deferred) {\n        if (this.working[workerId]) {\n            throw new Error(\"Posting a job t a working worker\");\n        }\n        this.working[workerId] = true;\n\n        this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();\n        this.workers[workerId].postMessage(e, transfers);\n\n        return this.pendingDeferreds[workerId].promise;\n    }\n\n    processWorks() {\n        for (let i=0; (i<this.workers.length)&&(this.actionQueue.length > 0); i++) {\n            if (this.working[i] == false) {\n                const work = this.actionQueue.shift();\n                this.postAction(i, work.data, work.transfers, work.deferred);\n            }\n        }\n    }\n\n    queueAction(actionData, transfers) {\n        const d = new Deferred();\n\n        if (this.singleThread) {\n            const res = this.taskManager(actionData);\n            d.resolve(res);\n        } else {\n            this.actionQueue.push({\n                data: actionData,\n                transfers: transfers,\n                deferred: d\n            });\n            this.processWorks();\n        }\n        return d.promise;\n    }\n\n    resetMemory() {\n        this.u32[0] = this.initalPFree;\n    }\n\n    allocBuff(buff) {\n        const pointer = this.alloc(buff.byteLength);\n        this.setBuff(pointer, buff);\n        return pointer;\n    }\n\n    getBuff(pointer, length) {\n        return this.u8.slice(pointer, pointer+ length);\n    }\n\n    setBuff(pointer, buffer) {\n        this.u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    alloc(length) {\n        while (this.u32[0] & 3) this.u32[0]++;  // Return always aligned pointers\n        const res = this.u32[0];\n        this.u32[0] += length;\n        return res;\n    }\n\n    async terminate() {\n        for (let i=0; i<this.workers.length; i++) {\n            this.workers[i].postMessage([{cmd: \"TERMINATE\"}]);\n        }\n        await sleep(200);\n    }\n\n}\n", "/* global WebAssembly */\n\nexport default function thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == \"INIT\") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == \"TERMINATE\") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == \"INIT\") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case \"ALLOCSET\":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case \"ALLOC\":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case \"SET\":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case \"CALL\": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== \"undefined\") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != \"undefined\") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case \"GET\":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error(\"Invalid cmd\");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}\n", "/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 CoderPuppy\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\nvar _endianness;\nexport function endianness() {\n  if (typeof _endianness === 'undefined') {\n    var a = new ArrayBuffer(2);\n    var b = new Uint8Array(a);\n    var c = new Uint16Array(a);\n    b[0] = 1;\n    b[1] = 2;\n    if (c[0] === 258) {\n      _endianness = 'BE';\n    } else if (c[0] === 513){\n      _endianness = 'LE';\n    } else {\n      throw new Error('unable to figure out endianess');\n    }\n  }\n  return _endianness;\n}\n\nexport function hostname() {\n  if (typeof global.location !== 'undefined') {\n    return global.location.hostname\n  } else return '';\n}\n\nexport function loadavg() {\n  return [];\n}\n\nexport function uptime() {\n  return 0;\n}\n\nexport function freemem() {\n  return Number.MAX_VALUE;\n}\n\nexport function totalmem() {\n  return Number.MAX_VALUE;\n}\n\nexport function cpus() {\n  return [];\n}\n\nexport function type() {\n  return 'Browser';\n}\n\nexport function release () {\n  if (typeof global.navigator !== 'undefined') {\n    return global.navigator.appVersion;\n  }\n  return '';\n}\n\nexport function networkInterfaces(){}\nexport function getNetworkInterfaces(){}\n\nexport function arch() {\n  return 'javascript';\n}\n\nexport function platform() {\n  return 'browser';\n}\n\nexport function tmpDir() {\n  return '/tmp';\n}\nexport var tmpdir = tmpDir;\n\nexport var EOL = '\\n';\nexport default {\n  EOL: EOL,\n  tmpdir: tmpdir,\n  tmpDir: tmpDir,\n  networkInterfaces:networkInterfaces,\n  getNetworkInterfaces: getNetworkInterfaces,\n  release: release,\n  type: type,\n  cpus: cpus,\n  totalmem: totalmem,\n  freemem: freemem,\n  uptime: uptime,\n  loadavg: loadavg,\n  hostname: hostname,\n  endianness: endianness,\n}\n", "import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchApplyKey(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = curve.tm;\n\n    curve[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        let fnName, fnAffine;\n        let sGin, sGmid, sGout;\n        if (groupName == \"G1\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g1m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g1m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g1m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g2m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g2m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g2m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_batchApplyKey\";\n            sGin = G.n8;\n            sGmid = G.n8;\n            sGout = G.n8;\n        } else {\n            throw new Error(\"Invalid group: \" + groupName);\n        }\n        const nPoints = Math.floor(buff.byteLength / sGin);\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        inc = Fr.e(inc);\n        let t = Fr.e(first);\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({\n                cmd: \"ALLOCSET\",\n                var: 0,\n                buff: buff.slice(i*pointsPerChunk*sGin, i*pointsPerChunk*sGin + n*sGin)\n            });\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: t});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: inc});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*Math.max(sGmid, sGout)});\n            task.push({\n                cmd: \"CALL\",\n                fnName: fnName,\n                params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1},\n                    {var: 2},\n                    {var:3}\n                ]\n            });\n            if (fnAffine) {\n                task.push({\n                    cmd: \"CALL\",\n                    fnName: fnAffine,\n                    params: [\n                        {var: 3},\n                        {val: n},\n                        {var: 3},\n                    ]\n                });\n            }\n            task.push({cmd: \"GET\", out: 0, var: 3, len: n*sGout});\n\n            opPromises.push(tm.queueAction(task));\n            t = Fr.mul(t, Fr.exp(inc, n));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let outBuff;\n        if (buff instanceof BigBuffer) {\n            outBuff = new BigBuffer(nPoints*sGout);\n        } else {\n            outBuff = new Uint8Array(nPoints*sGout);\n        }\n\n        let p=0;\n        for (let i=0; i<result.length; i++) {\n            outBuff.set(result[i][0], p);\n            p += result[i][0].byteLength;\n        }\n\n        return outBuff;\n    };\n}\n", "\nexport default function buildPairing(curve) {\n    const tm = curve.tm;\n    curve.pairing = function pairing(a, b) {\n\n        tm.startSyncOp();\n        const pA = tm.allocBuff(curve.G1.toJacobian(a));\n        const pB = tm.allocBuff(curve.G2.toJacobian(b));\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports[curve.name + \"_pairing\"](pA, pB, pRes);\n\n        const res = tm.getBuff(pRes, curve.Gt.n8);\n\n        tm.endSyncOp();\n        return res;\n    };\n\n    curve.pairingEq = async function pairingEq() {\n        let  buffCt;\n        let nEqs;\n        if ((arguments.length % 2) == 1) {\n            buffCt = arguments[arguments.length-1];\n            nEqs = (arguments.length -1) /2;\n        } else {\n            buffCt = curve.Gt.one;\n            nEqs = arguments.length /2;\n        }\n\n        const opPromises = [];\n        for (let i=0; i<nEqs; i++) {\n\n            const task = [];\n\n            const g1Buff = curve.G1.toJacobian(arguments[i*2]);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: g1Buff});\n            task.push({cmd: \"ALLOC\", var: 1, len: curve.prePSize});\n\n            const g2Buff = curve.G2.toJacobian(arguments[i*2 +1]);\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: g2Buff});\n            task.push({cmd: \"ALLOC\", var: 3, len: curve.preQSize});\n\n            task.push({cmd: \"ALLOC\", var: 4, len: curve.Gt.n8});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG1\", params: [\n                {var: 0},\n                {var: 1}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG2\", params: [\n                {var: 2},\n                {var: 3}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_millerLoop\", params: [\n                {var: 1},\n                {var: 3},\n                {var: 4}\n            ]});\n\n            task.push({cmd: \"GET\", out: 0, var: 4, len: curve.Gt.n8});\n\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        tm.startSyncOp();\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports.ftm_one(pRes);\n\n        for (let i=0; i<result.length; i++) {\n            const pMR = tm.allocBuff(result[i][0]);\n            tm.instance.exports.ftm_mul(pRes, pMR, pRes);\n        }\n        tm.instance.exports[curve.name + \"_finalExponentiation\"](pRes, pRes);\n\n        const pCt = tm.allocBuff(buffCt);\n\n        const r = !!tm.instance.exports.ftm_eq(pRes, pCt);\n\n        tm.endSyncOp();\n\n        return r;\n    };\n\n    curve.prepareG1 = function(p) {\n        this.tm.startSyncOp();\n        const pP = this.tm.allocBuff(p);\n        const pPrepP = this.tm.alloc(this.prePSize);\n        this.tm.instance.exports[this.name + \"_prepareG1\"](pP, pPrepP);\n        const res = this.tm.getBuff(pPrepP, this.prePSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.prepareG2 = function(q) {\n        this.tm.startSyncOp();\n        const pQ = this.tm.allocBuff(q);\n        const pPrepQ = this.tm.alloc(this.preQSize);\n        this.tm.instance.exports[this.name + \"_prepareG2\"](pQ, pPrepQ);\n        const res = this.tm.getBuff(pPrepQ, this.preQSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.millerLoop = function(preP, preQ) {\n        this.tm.startSyncOp();\n        const pPreP = this.tm.allocBuff(preP);\n        const pPreQ = this.tm.allocBuff(preQ);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_millerLoop\"](pPreP, pPreQ, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.finalExponentiation = function(a) {\n        this.tm.startSyncOp();\n        const pA = this.tm.allocBuff(a);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_finalExponentiation\"](pA, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n}\n", "import { log2 } from \"./utils.js\";\n\nconst pTSizes = [\n    1 ,  1,  1,  1,    2,  3,  4,  5,\n    6 ,  7,  7,  8,    9, 10, 11, 12,\n    13, 13, 14, 15,   16, 16, 17, 17,\n    17, 17, 17, 17,   17, 17, 17, 17\n];\n\nexport default function buildMultiexp(curve, groupName) {\n    const G = curve[groupName];\n    const tm = G.tm;\n    async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {\n        if ( ! (buffBases instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n        }\n        if ( ! (buffScalars instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n        }\n        inType = inType || \"affine\";\n\n        let sGIn;\n        let fnName;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                fnName = \"g1m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g1m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                fnName = \"g2m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g2m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff: buffBases},\n                {cmd: \"ALLOCSET\", var: 1, buff: buffScalars},\n                {cmd: \"ALLOC\", var: 2, len: G.F.n8*3},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {var: 1},\n                    {val: sScalar},\n                    {val: nPoints},\n                    {val: i*bitChunkSize},\n                    {val: Math.min(sScalar*8 - i*bitChunkSize, bitChunkSize)},\n                    {var: 2}\n                ]},\n                {cmd: \"GET\", out: 0, var: 2, len: G.F.n8*3}\n            ];\n            opPromises.push(\n                G.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            if (!G.isZero(res)) {\n                for (let j=0; j<bitChunkSize; j++) res = G.double(res);\n            }\n            res = G.add(res, result[i][0]);\n        }\n\n        return res;\n    }\n\n    async function _multiExp(buffBases, buffScalars, inType, logger, logText) {\n        const MAX_CHUNK_SIZE = 1 << 22;\n        const MIN_CHUNK_SIZE = 1 << 10;\n        let sGIn;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        let chunkSize;\n        chunkSize = Math.floor(nPoints / (tm.concurrency /nChunks));\n        if (chunkSize>MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n        if (chunkSize<MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n\n        const opPromises = [];\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n            const buffBasesChunk = buffBases.slice(i*sGIn, (i+n)*sGIn);\n            const buffScalarsChunk = buffScalars.slice(i*sScalar, (i+n)*sScalar);\n            opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then( (r) => {\n                if (logger) logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);\n                return r;\n            }));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            res = G.add(res, result[i]);\n        }\n\n        return res;\n    }\n\n    G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"jacobian\", logger, logText);\n    };\n    G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"affine\", logger, logText);\n    };\n}\n", "import {log2, buffReverseBits, array2buffer, buffer2array} from \"./utils.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default function buildFFT(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = G.tm;\n    async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {\n\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        const MAX_BITS_THREAD = 14;\n\n        let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g1m_fftFinal\";\n            }\n            fnFFTJoin = \"g1m_fftJoin\";\n            fnFFTMix = \"g1m_fftMix\";\n\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g1m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g2m_fftFinal\";\n            }\n            fnFFTJoin = \"g2m_fftJoin\";\n            fnFFTMix = \"g2m_fftMix\";\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g2m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = G.n8;\n            sMid = G.n8;\n            sOut = G.n8;\n            if (inverse) {\n                fnFFTFinal = \"frm_fftFinal\";\n            }\n            fnFFTMix = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        }\n\n\n        let returnArray = false;\n        if (Array.isArray(buff)) {\n            buff = array2buffer(buff, sIn);\n            returnArray = true;\n        } else {\n            buff = buff.slice(0, buff.byteLength);\n        }\n\n        const nPoints = buff.byteLength / sIn;\n        const bits = log2(nPoints);\n\n        if  ((1 << bits) != nPoints) {\n            throw new Error(\"fft must be multiple of 2\" );\n        }\n\n        if (bits == Fr.s +1) {\n            let buffOut;\n\n            if (inverse) {\n                buffOut =  await _fftExtInv(buff, inType, outType, logger, loggerTxt);\n            } else {\n                buffOut =  await _fftExt(buff, inType, outType, logger, loggerTxt);\n            }\n\n            if (returnArray) {\n                return buffer2array(buffOut, sOut);\n            } else {\n                return buffOut;\n            }\n        }\n\n        let inv;\n        if (inverse) {\n            inv = Fr.inv(Fr.e(nPoints));\n        }\n\n        let buffOut;\n\n        buffReverseBits(buff, sIn);\n\n        let chunks;\n        let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);\n        let nChunks = nPoints / pointsInChunk;\n\n        while ((nChunks < tm.concurrency)&&(pointsInChunk>=16)) {\n            nChunks *= 2;\n            pointsInChunk /= 2;\n        }\n\n        const l2Chunk = log2(pointsInChunk);\n\n        const promises = [];\n        for (let i = 0; i< nChunks; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix start: ${i}/${nChunks}`);\n            const task = [];\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*pointsInChunk});\n            const buffChunk = buff.slice( (pointsInChunk * i)*sIn, (pointsInChunk * (i+1))*sIn);\n            task.push({cmd: \"SET\", var: 0, buff: buffChunk});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n            }\n            for (let j=1; j<=l2Chunk;j++) {\n                task.push({cmd: \"CALL\", fnName:fnFFTMix, params: [{var:0}, {val: pointsInChunk}, {val: j}]});\n            }\n\n            if (l2Chunk==bits) {\n                if (fnFFTFinal) {\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: inv});\n                    task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                        {var: 0},\n                        {val: pointsInChunk},\n                        {var: 1},\n                    ]});\n                }\n                if (fnMid2Out) {\n                    task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                }\n                task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n            } else {\n                task.push({cmd: \"GET\", out:0, var: 0, len: sMid*pointsInChunk});\n            }\n            promises.push(tm.queueAction(task).then( (r) => {\n                if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix end: ${i}/${nChunks}`);\n                return r;\n            }));\n        }\n\n        chunks = await Promise.all(promises);\n        for (let i = 0; i< nChunks; i++) chunks[i] = chunks[i][0];\n\n        for (let i = l2Chunk+1;   i<=bits; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft  ${bits}  join: ${i}/${bits}`);\n            const nGroups = 1 << (bits - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsInChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsInChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    if (i==bits) {\n                        if (fnFFTFinal) {\n                            task.push({cmd: \"ALLOCSET\", var: 4, buff: inv});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 0},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 1},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                        }\n                        if (fnMid2Out) {\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: pointsInChunk}, {var: 1}]});\n                        }\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sOut});\n                    } else {\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sMid});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sMid});\n                    }\n                    opPromises.push(tm.queueAction(task).then( (r) => {\n                        if (logger) logger.debug(`${loggerTxt}: fft ${bits} join  ${i}/${bits}  ${j+1}/${nGroups} ${k}/${nChunksPerGroup/2}`);\n                        return r;\n                    }));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        if (buff instanceof BigBuffer) {\n            buffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            buffOut = new Uint8Array(nPoints*sOut);\n        }\n        if (inverse) {\n            buffOut.set(chunks[0].slice((pointsInChunk-1)*sOut));\n            let p= sOut;\n            for (let i=nChunks-1; i>0; i--) {\n                buffOut.set(chunks[i], p);\n                p += pointsInChunk*sOut;\n                delete chunks[i];  // Liberate mem\n            }\n            buffOut.set(chunks[0].slice(0, (pointsInChunk-1)*sOut), p);\n            delete chunks[0];\n        } else {\n            for (let i=0; i<nChunks; i++) {\n                buffOut.set(chunks[i], pointsInChunk*sOut*i);\n                delete chunks[i];\n            }\n        }\n\n        if (returnArray) {\n            return buffer2array(buffOut, sOut);\n        } else {\n            return buffOut;\n        }\n    }\n\n    async function _fftExt(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        [b1, b2] = await _fftJoinExt(b1, b2, \"fftJoinExt\", Fr.one, Fr.shift, inType, \"jacobian\", logger, loggerTxt);\n\n        promises.push( _fft(b1, false, \"jacobian\", outType, logger, loggerTxt));\n        promises.push( _fft(b2, false, \"jacobian\", outType, logger, loggerTxt));\n\n        const res1 = await Promise.all(promises);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n    async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        promises.push( _fft(b1, true, inType, \"jacobian\", logger, loggerTxt));\n        promises.push( _fft(b2, true, inType, \"jacobian\", logger, loggerTxt));\n\n        [b1, b2] = await Promise.all(promises);\n\n        const res1 = await _fftJoinExt(b1, b2, \"fftJoinExtInv\", Fr.one, Fr.shiftInv, \"jacobian\", outType, logger, loggerTxt);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n\n    async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const MIN_CHUNK_SIZE = 1<<4;\n\n        let fnName;\n        let fnIn2Mid, fnMid2Out;\n        let sOut, sIn, sMid;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            fnName = \"g1m_\"+fn;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g1m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            fnName = \"g2m_\"+fn;\n            sMid = G.F.n8*3;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g2m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n            sOut = Fr.n8;\n            sMid = Fr.n8;\n            fnName = \"frm_\" + fn;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sIn);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let chunkSize = Math.floor(nPoints /tm.concurrency);\n        if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n        if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n\n        const opPromises = [];\n\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n\n            const firstChunk = Fr.mul(first, Fr.exp( inc, i));\n            const task = [];\n\n            const b1 = buff1.slice(i*sIn, (i+n)*sIn);\n            const b2 = buff2.slice(i*sIn, (i+n)*sIn);\n\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*n});\n            task.push({cmd: \"SET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOC\", var: 1, len: sMid*n});\n            task.push({cmd: \"SET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: n},\n                {var: 2},\n                {var: 3},\n                {val: Fr.s},\n            ]});\n            if (fnMid2Out) {\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sOut});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: n*sOut});\n            opPromises.push(\n                tm.queueAction(task).then( (r) => {\n                    if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);\n                    return r;\n                })\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (nPoints * sOut > 1<<28) {\n            fullBuffOut1 = new BigBuffer(nPoints*sOut);\n            fullBuffOut2 = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sOut);\n            fullBuffOut2 = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    }\n\n\n    G.fft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, false, inType, outType, logger, loggerTxt);\n    };\n\n    G.ifft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, true, inType, outType, logger, loggerTxt);\n    };\n\n    G.lagrangeEvaluations = async function (buff, inType, outType, logger, loggerTxt) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n\n        let sIn;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = buff.byteLength /sIn;\n        const bits = log2(nPoints);\n\n        if ((2 ** bits)*sIn != buff.byteLength) {\n            if (logger) logger.error(\"lagrangeEvaluations iinvalid input size\");\n            throw new Error(\"lagrangeEvaluations invalid Input size\");\n        }\n\n        if (bits <= Fr.s) {\n            return await G.ifft(buff, inType, outType, logger, loggerTxt);\n        }\n\n        if (bits > Fr.s+1) {\n            if (logger) logger.error(\"lagrangeEvaluations input too big\");\n            throw new Error(\"lagrangeEvaluations input too big\");\n        }\n\n        let t0 = buff.slice(0, buff.byteLength/2);\n        let t1 = buff.slice(buff.byteLength/2, buff.byteLength);\n\n\n        const shiftToSmallM = Fr.exp(Fr.shift, nPoints/2);\n        const sConst = Fr.inv( Fr.sub(Fr.one, shiftToSmallM));\n\n        [t0, t1] = await _fftJoinExt(t0, t1, \"prepareLagrangeEvaluation\", sConst, Fr.shiftInv, inType, \"jacobian\", logger, loggerTxt + \" prep\");\n\n        const promises = [];\n\n        promises.push( _fft(t0, true, \"jacobian\", outType, logger, loggerTxt + \" t0\"));\n        promises.push( _fft(t1, true, \"jacobian\", outType, logger, loggerTxt + \" t1\"));\n\n        [t0, t1] = await Promise.all(promises);\n\n        let buffOut;\n        if (t0.byteLength > (1<<28)) {\n            buffOut = new BigBuffer(t0.byteLength*2);\n        } else {\n            buffOut = new Uint8Array(t0.byteLength*2);\n        }\n\n        buffOut.set(t0);\n        buffOut.set(t1, t0.byteLength);\n\n        return buffOut;\n    };\n\n    G.fftMix = async function fftMix(buff) {\n        const sG = G.F.n8*3;\n        let fnName, fnFFTJoin;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftMix\";\n            fnFFTJoin = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftMix\";\n            fnFFTJoin = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        const power = log2(nPoints);\n\n        let nChunks = 1 << log2(tm.concurrency);\n\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n        const powerChunk = log2(pointsPerChunk);\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            for (let j=1; j<=powerChunk; j++) {\n                task.push({cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: pointsPerChunk},\n                    {val: j}\n                ]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        const chunks = [];\n        for (let i=0; i<result.length; i++) chunks[i] = result[i][0];\n\n\n        for (let i = powerChunk+1; i<=power; i++) {\n            const nGroups = 1 << (power - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsPerChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsPerChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n                    task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n                    opPromises.push(tm.queueAction(task));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sG);\n        }\n        let p =0;\n        for (let i=0; i<nChunks; i++) {\n            fullBuffOut.set(chunks[i], p);\n            p+=chunks[i].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n\n    G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {\n        const sG = G.F.n8*3;\n        let fnName;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let nChunks = 1 << log2(tm.concurrency);\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n\n            const firstChunk = Fr.mul(first, Fr.exp(inc, i*pointsPerChunk));\n            const b1 = buff1.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            const b2 = buff2.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: pointsPerChunk},\n                {var: 2},\n                {var: 3}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (buff1 instanceof BigBuffer) {\n            fullBuffOut1 = new BigBuffer(nPoints*sG);\n            fullBuffOut2 = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sG);\n            fullBuffOut2 = new Uint8Array(nPoints*sG);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    };\n\n\n\n    G.fftFinal =  async function fftFinal(buff, factor) {\n        const sG = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnName, fnToAffine;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftFinal\";\n            fnToAffine = \"g1m_batchToAffine\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftFinal\";\n            fnToAffine = \"g2m_batchToAffine\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        const pointsPerChunk = Math.floor(nPoints / tm.concurrency);\n\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, (i*pointsPerChunk+n)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: factor});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {val: n},\n                {var: 1},\n            ]});\n            task.push({cmd: \"CALL\", fnName: fnToAffine, params: [\n                {var: 0},\n                {val: n},\n                {var: 0},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sGout});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sGout);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sGout);\n        }\n\n        let p =0;\n        for (let i=result.length-1; i>=0; i--) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport { ModuleBuilder } from \"./src/modulebuilder.js\";\nexport { ModuleBuilderWat } from \"./src/modulebuilder_wat.js\";\nexport { buildProtoboard } from \"./src/protoboard.js\";\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nimport { FunctionBuilder } from \"./functionbuilder.js\";\nimport * as utils from \"./utils.js\";\n\nexport class ModuleBuilder {\n\n    constructor() {\n        this.functions = [];\n        this.functionIdxByName = {};\n        this.nImportFunctions = 0;\n        this.nInternalFunctions =0;\n        this.memory = {\n            pagesSize: 1,\n            moduleName: \"env\",\n            fieldName: \"memory\"\n        };\n        this.free = 8;\n        this.datas = [];\n        this.modules = {};\n        this.exports = [];\n        this.functionsTable = [];\n    }\n\n    build() {\n        this._setSignatures();\n        return new Uint8Array([\n            ...utils.u32(0x6d736100),\n            ...utils.u32(1),\n            ...this._buildType(),\n            ...this._buildImport(),\n            ...this._buildFunctionDeclarations(),\n            ...this._buildFunctionsTable(),\n            ...this._buildExports(),\n            ...this._buildElements(),\n            ...this._buildCode(),\n            ...this._buildData()\n        ]);\n    }\n\n    addFunction(fnName) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilder(this, fnName, \"internal\"));\n\n        this.nInternalFunctions++;\n        return this.functions[idx];\n    }\n\n    addIimportFunction(fnName, moduleName, _fieldName) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        if (  (this.functions.length>0)\n            &&(this.functions[this.functions.length-1].type == \"internal\"))\n            throw new Error(`Import functions must be declared before internal: ${fnName}`);\n\n        let fieldName = _fieldName || fnName;\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilder(this, fnName, \"import\", moduleName, fieldName));\n\n        this.nImportFunctions ++;\n        return this.functions[idx];\n    }\n\n    setMemory(pagesSize, moduleName, fieldName) {\n        this.memory = {\n            pagesSize: pagesSize,\n            moduleName: moduleName || \"env\",\n            fieldName: fieldName || \"memory\"\n        };\n    }\n\n    exportFunction(fnName, _exportName) {\n        const exportName = _exportName || fnName;\n        if (typeof(this.functionIdxByName[fnName]) === \"undefined\")\n            throw new Error(`Function not defined: ${fnName}`);\n        const idx = this.functionIdxByName[fnName];\n        if (exportName != fnName) {\n            this.functionIdxByName[exportName] = idx;\n        }\n        this.exports.push({\n            exportName: exportName,\n            idx: idx\n        });\n    }\n\n    addFunctionToTable(fnName) {\n        const idx = this.functionIdxByName[fnName];\n        this.functionsTable.push(idx);\n    }\n\n    addData(offset, bytes) {\n        this.datas.push({\n            offset: offset,\n            bytes: bytes\n        });\n    }\n\n    alloc(a, b) {\n        let size;\n        let bytes;\n        if ((Array.isArray(a) || ArrayBuffer.isView(a)) && (typeof(b) === \"undefined\")) {\n            size = a.length;\n            bytes = a;\n        } else {\n            size = a;\n            bytes = b;\n        }\n        size = (((size-1)>>3) +1)<<3;       // Align to 64 bits.\n        const p = this.free;\n        this.free += size;\n        if (bytes) {\n            this.addData(p, bytes);\n        }\n        return p;\n    }\n\n    allocString(s) {\n        const encoder = new globalThis.TextEncoder();\n        const uint8array = encoder.encode(s);\n        return this.alloc([...uint8array, 0]);\n    }\n\n    _setSignatures() {\n        this.signatures = [];\n        const signatureIdxByName = {};\n        if (this.functionsTable.length>0) {\n            const signature = this.functions[this.functionsTable[0]].getSignature();\n            const signatureName = \"s_\"+utils.toHexString(signature);\n            signatureIdxByName[signatureName] = 0;\n            this.signatures.push(signature);\n        }\n        for (let i=0; i<this.functions.length; i++) {\n            const signature = this.functions[i].getSignature();\n            const signatureName = \"s_\"+utils.toHexString(signature);\n            if (typeof(signatureIdxByName[signatureName]) === \"undefined\") {\n                signatureIdxByName[signatureName] = this.signatures.length;\n                this.signatures.push(signature);\n            }\n\n            this.functions[i].signatureIdx = signatureIdxByName[signatureName];\n        }\n\n    }\n\n    _buildSection(sectionType, section) {\n        return [sectionType, ...utils.varuint32(section.length), ...section];\n    }\n\n    _buildType() {\n        return this._buildSection(\n            0x01,\n            [\n                ...utils.varuint32(this.signatures.length),\n                ...[].concat(...this.signatures)\n            ]\n        );\n    }\n\n    _buildImport() {\n        const entries = [];\n        entries.push([\n            ...utils.string(this.memory.moduleName),\n            ...utils.string(this.memory.fieldName),\n            0x02,\n            0x00,   //Flags no init valua\n            ...utils.varuint32(this.memory.pagesSize)\n        ]);\n        for (let i=0; i< this.nImportFunctions; i++) {\n            entries.push([\n                ...utils.string(this.functions[i].moduleName),\n                ...utils.string(this.functions[i].fieldName),\n                0x00,\n                ...utils.varuint32(this.functions[i].signatureIdx)\n            ]);\n        }\n        return this._buildSection(\n            0x02,\n            utils.varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildFunctionDeclarations() {\n        const entries = [];\n        for (let i=this.nImportFunctions; i< this.nImportFunctions + this.nInternalFunctions; i++) {\n            entries.push(...utils.varuint32(this.functions[i].signatureIdx));\n        }\n        return this._buildSection(\n            0x03,\n            [\n                ...utils.varuint32(entries.length),\n                ...[...entries]\n            ]\n        );\n    }\n\n    _buildFunctionsTable() {\n        if (this.functionsTable.length == 0) return [];\n        return this._buildSection(\n            0x04,\n            [\n                ...utils.varuint32(1),\n                0x70, 0, ...utils.varuint32(this.functionsTable.length)\n            ]\n        );\n    }\n\n    _buildElements() {\n        if (this.functionsTable.length == 0) return [];\n        const entries = [];\n        for (let i=0; i<this.functionsTable.length; i++) {\n            entries.push(...utils.varuint32(this.functionsTable[i]));\n        }\n        return this._buildSection(\n            0x09,\n            [\n                ...utils.varuint32(1),      // 1 entry\n                ...utils.varuint32(0),      // Table (0 in MVP)\n                0x41,                       // offset 0\n                ...utils.varint32(0),\n                0x0b,\n                ...utils.varuint32(this.functionsTable.length), // Number of elements\n                ...[...entries]\n            ]\n        );\n    }\n\n    _buildExports() {\n        const entries = [];\n        for (let i=0; i< this.exports.length; i++) {\n            entries.push([\n                ...utils.string(this.exports[i].exportName),\n                0x00,\n                ...utils.varuint32(this.exports[i].idx)\n            ]);\n        }\n        return this._buildSection(\n            0x07,\n            utils.varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildCode() {\n        const entries = [];\n        for (let i=this.nImportFunctions; i< this.nImportFunctions + this.nInternalFunctions; i++) {\n            entries.push(this.functions[i].getBody());\n        }\n        return this._buildSection(\n            0x0a,\n            utils.varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildData() {\n        const entries = [];\n        entries.push([\n            0x00,\n            0x41,\n            0x00,\n            0x0b,\n            0x04,\n            ...utils.u32(this.free)\n        ]);\n        for (let i=0; i< this.datas.length; i++) {\n            entries.push([\n                0x00,\n                0x41,\n                ...utils.varint32(this.datas[i].offset),\n                0x0b,\n                ...utils.varuint32(this.datas[i].bytes.length),\n                ...this.datas[i].bytes,\n            ]);\n        }\n        return this._buildSection(\n            0x0b,\n            utils.varuint32(entries.length).concat(...entries)\n        );\n    }\n\n}\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { CodeBuilder } from \"./codebuilder.js\";\nimport * as utils from \"./utils.js\";\n\nconst typeCodes = {\n    \"i32\": 0x7f,\n    \"i64\": 0x7e,\n    \"f32\": 0x7d,\n    \"f64\": 0x7c,\n    \"anyfunc\": 0x70,\n    \"func\": 0x60,\n    \"emptyblock\": 0x40\n};\n\n\nexport class FunctionBuilder {\n\n    constructor (module, fnName, fnType, moduleName, fieldName) {\n        if (fnType == \"import\") {\n            this.fnType = \"import\";\n            this.moduleName = moduleName;\n            this.fieldName = fieldName;\n        } else if (fnType == \"internal\") {\n            this.fnType = \"internal\";\n        } else {\n            throw new Error(\"Invalid function fnType: \" + fnType);\n        }\n        this.module = module;\n        this.fnName = fnName;\n        this.params = [];\n        this.locals = [];\n        this.localIdxByName = {};\n        this.code = [];\n        this.returnType = null;\n        this.nextLocal =0;\n    }\n\n    addParam(paramName, paramType) {\n        if (this.localIdxByName[paramName])\n            throw new Error(`param already exists. Function: ${this.fnName}, Param: ${paramName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[paramName] = idx;\n        this.params.push({\n            type: paramType\n        });\n    }\n\n    addLocal(localName, localType, _length) {\n        const length = _length || 1;\n        if (this.localIdxByName[localName])\n            throw new Error(`local already exists. Function: ${this.fnName}, Param: ${localName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[localName] = idx;\n        this.locals.push({\n            type: localType,\n            length: length\n        });\n    }\n\n    setReturnType(returnType) {\n        if (this.returnType)\n            throw new Error(`returnType already defined. Function: ${this.fnName}`);\n        this.returnType = returnType;\n    }\n\n    getSignature() {\n        const params = [...utils.varuint32(this.params.length), ...this.params.map((p) => typeCodes[p.type])];\n        const returns = this.returnType ? [0x01, typeCodes[this.returnType]] : [0];\n        return [0x60, ...params, ...returns];\n    }\n\n    getBody() {\n        const locals = this.locals.map((l) => [\n            ...utils.varuint32(l.length),\n            typeCodes[l.type]\n        ]);\n\n        const body = [\n            ...utils.varuint32(this.locals.length),\n            ...[].concat(...locals),\n            ...this.code,\n            0x0b\n        ];\n        return [\n            ...utils.varuint32(body.length),\n            ...body\n        ];\n    }\n\n    addCode(...code) {\n        this.code.push(...[].concat(...[...code]));\n    }\n\n    getCodeBuilder() {\n        return new CodeBuilder(this);\n    }\n}\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as utils from \"./utils.js\";\n\nexport class CodeBuilder {\n    constructor(func) {\n        this.func = func;\n        this.functionName = func.functionName;\n        this.module = func.module;\n    }\n\n    setLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [...valCode, 0x21, ...utils.varuint32( idx )];\n    }\n\n    teeLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [...valCode, 0x22, ...utils.varuint32( idx )];\n    }\n\n    getLocal(localName) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [0x20, ...utils.varuint32( idx )];\n    }\n\n    i64_load8_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 8 bits alignment by default\n        return [...idxCode, 0x30, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load8_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 8 bits alignment by default\n        return [...idxCode, 0x31, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load16_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 16 bits alignment by default\n        return [...idxCode, 0x32, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load16_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 16 bits alignment by default\n        return [...idxCode, 0x33, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load32_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x34, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load32_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x35, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 3 : _align;  // 64 bits alignment by default\n        return [...idxCode, 0x29, align, ...utils.varuint32(offset)];\n    }\n\n\n    i64_store(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 3;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 3;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x37, align, ...utils.varuint32(offset)];\n    }\n\n    i64_store32(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 2;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 2;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3e, align, ...utils.varuint32(offset)];\n    }\n\n\n    i64_store16(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 1;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 1;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3d, align, ...utils.varuint32(offset)];\n    }\n\n\n    i64_store8(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 0;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 0;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3c, align, ...utils.varuint32(offset)];\n    }\n\n    i32_load8_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2c, align, ...utils.varuint32(offset)];\n    }\n\n    i32_load8_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2d, align, ...utils.varuint32(offset)];\n    }\n\n    i32_load16_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2e, align, ...utils.varuint32(offset)];\n    }\n\n    i32_load16_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2f, align, ...utils.varuint32(offset)];\n    }\n\n    i32_load(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x28, align, ...utils.varuint32(offset)];\n    }\n\n    i32_store(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 2;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 2;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x36, align, ...utils.varuint32(offset)];\n    }\n\n\n    i32_store16(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 1;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 1;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3b, align, ...utils.varuint32(offset)];\n    }\n\n    i32_store8(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 0;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 0;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3a, align, ...utils.varuint32(offset)];\n    }\n\n    call(fnName, ...args) {\n        const idx = this.module.functionIdxByName[fnName];\n        if (idx === undefined)\n            throw new Error(`Function not defined: Function: ${fnName}`);\n        return [...[].concat(...args), 0x10, ...utils.varuint32(idx)];\n    }\n\n    call_indirect(fnIdx, ...args) {\n        return [...[].concat(...args), ...fnIdx, 0x11, 0, 0];\n    }\n\n    if(condCode, thenCode, elseCode) {\n        if (elseCode) {\n            return [...condCode, 0x04, 0x40, ...thenCode, 0x05, ...elseCode, 0x0b];\n        } else {\n            return [...condCode, 0x04, 0x40, ...thenCode, 0x0b];\n        }\n    }\n\n    block(bCode) { return [0x02, 0x40, ...bCode, 0x0b]; }\n    loop(...args) {\n        return [0x03, 0x40, ...[].concat(...[...args]), 0x0b];\n    }\n    br_if(relPath, condCode) { return [...condCode, 0x0d, ...utils.varuint32(relPath)]; }\n    br(relPath) { return [0x0c, ...utils.varuint32(relPath)]; }\n    ret(rCode) { return [...rCode, 0x0f]; }\n    drop(dCode) { return [...dCode,  0x1a]; }\n\n    i64_const(num) { return [0x42, ...utils.varint64(num)]; }\n    i32_const(num) { return [0x41, ...utils.varint32(num)]; }\n\n\n    i64_eqz(opcode) { return [...opcode, 0x50]; }\n    i64_eq(op1code, op2code) { return [...op1code, ...op2code, 0x51]; }\n    i64_ne(op1code, op2code) { return [...op1code, ...op2code, 0x52]; }\n    i64_lt_s(op1code, op2code) { return [...op1code, ...op2code, 0x53]; }\n    i64_lt_u(op1code, op2code) { return [...op1code, ...op2code, 0x54]; }\n    i64_gt_s(op1code, op2code) { return [...op1code, ...op2code, 0x55]; }\n    i64_gt_u(op1code, op2code) { return [...op1code, ...op2code, 0x56]; }\n    i64_le_s(op1code, op2code) { return [...op1code, ...op2code, 0x57]; }\n    i64_le_u(op1code, op2code) { return [...op1code, ...op2code, 0x58]; }\n    i64_ge_s(op1code, op2code) { return [...op1code, ...op2code, 0x59]; }\n    i64_ge_u(op1code, op2code) { return [...op1code, ...op2code, 0x5a]; }\n    i64_add(op1code, op2code) { return [...op1code, ...op2code, 0x7c]; }\n    i64_sub(op1code, op2code) { return [...op1code, ...op2code, 0x7d]; }\n    i64_mul(op1code, op2code) { return [...op1code, ...op2code, 0x7e]; }\n    i64_div_s(op1code, op2code) { return [...op1code, ...op2code, 0x7f]; }\n    i64_div_u(op1code, op2code) { return [...op1code, ...op2code, 0x80]; }\n    i64_rem_s(op1code, op2code) { return [...op1code, ...op2code, 0x81]; }\n    i64_rem_u(op1code, op2code) { return [...op1code, ...op2code, 0x82]; }\n    i64_and(op1code, op2code) { return [...op1code, ...op2code, 0x83]; }\n    i64_or(op1code, op2code) { return [...op1code, ...op2code, 0x84]; }\n    i64_xor(op1code, op2code) { return [...op1code, ...op2code, 0x85]; }\n    i64_shl(op1code, op2code) { return [...op1code, ...op2code, 0x86]; }\n    i64_shr_s(op1code, op2code) { return [...op1code, ...op2code, 0x87]; }\n    i64_shr_u(op1code, op2code) { return [...op1code, ...op2code, 0x88]; }\n    i64_extend_i32_s(op1code) { return [...op1code, 0xac]; }\n    i64_extend_i32_u(op1code) { return [...op1code, 0xad]; }\n    i64_clz(op1code) { return [...op1code, 0x79]; }\n    i64_ctz(op1code) { return [...op1code, 0x7a]; }\n\n    i32_eqz(op1code) { return [...op1code, 0x45]; }\n    i32_eq(op1code, op2code) { return [...op1code, ...op2code, 0x46]; }\n    i32_ne(op1code, op2code) { return [...op1code, ...op2code, 0x47]; }\n    i32_lt_s(op1code, op2code) { return [...op1code, ...op2code, 0x48]; }\n    i32_lt_u(op1code, op2code) { return [...op1code, ...op2code, 0x49]; }\n    i32_gt_s(op1code, op2code) { return [...op1code, ...op2code, 0x4a]; }\n    i32_gt_u(op1code, op2code) { return [...op1code, ...op2code, 0x4b]; }\n    i32_le_s(op1code, op2code) { return [...op1code, ...op2code, 0x4c]; }\n    i32_le_u(op1code, op2code) { return [...op1code, ...op2code, 0x4d]; }\n    i32_ge_s(op1code, op2code) { return [...op1code, ...op2code, 0x4e]; }\n    i32_ge_u(op1code, op2code) { return [...op1code, ...op2code, 0x4f]; }\n    i32_add(op1code, op2code) { return [...op1code, ...op2code, 0x6a]; }\n    i32_sub(op1code, op2code) { return [...op1code, ...op2code, 0x6b]; }\n    i32_mul(op1code, op2code) { return [...op1code, ...op2code, 0x6c]; }\n    i32_div_s(op1code, op2code) { return [...op1code, ...op2code, 0x6d]; }\n    i32_div_u(op1code, op2code) { return [...op1code, ...op2code, 0x6e]; }\n    i32_rem_s(op1code, op2code) { return [...op1code, ...op2code, 0x6f]; }\n    i32_rem_u(op1code, op2code) { return [...op1code, ...op2code, 0x70]; }\n    i32_and(op1code, op2code) { return [...op1code, ...op2code, 0x71]; }\n    i32_or(op1code, op2code) { return [...op1code, ...op2code, 0x72]; }\n    i32_xor(op1code, op2code) { return [...op1code, ...op2code, 0x73]; }\n    i32_shl(op1code, op2code) { return [...op1code, ...op2code, 0x74]; }\n    i32_shr_s(op1code, op2code) { return [...op1code, ...op2code, 0x75]; }\n    i32_shr_u(op1code, op2code) { return [...op1code, ...op2code, 0x76]; }\n    i32_rotl(op1code, op2code) { return [...op1code, ...op2code, 0x77]; }\n    i32_rotr(op1code, op2code) { return [...op1code, ...op2code, 0x78]; }\n    i32_wrap_i64(op1code) { return [...op1code, 0xa7]; }\n    i32_clz(op1code) { return [...op1code, 0x67]; }\n    i32_ctz(op1code) { return [...op1code, 0x68]; }\n\n    unreachable() { return [ 0x0 ]; }\n\n    current_memory() { return [ 0x3f, 0]; }\n\n    comment() { return []; }\n}\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport function toNumber(n) {\n    return BigInt(n);\n}\n\nexport function isNegative(n) {\n    return n < 0n;\n}\n\nexport function isZero(n) {\n    return n === 0n;\n}\n\nexport function bitLength(n) {\n    if (isNegative(n)) {\n        return n.toString(2).length - 1; // discard the - sign\n    } else {\n        return n.toString(2).length;\n    }\n}\n\nexport function u32(n) {\n    const b = [];\n    const v = toNumber(n);\n    b.push(Number(v & 0xFFn));\n    b.push(Number(v >> 8n & 0xFFn));\n    b.push(Number(v >> 16n & 0xFFn));\n    b.push(Number(v >> 24n & 0xFFn));\n    return b;\n}\n\nexport function u64(n) {\n    const b = [];\n    const v = toNumber(n);\n    b.push(Number(v & 0xFFn));\n    b.push(Number(v >> 8n & 0xFFn));\n    b.push(Number(v >> 16n & 0xFFn));\n    b.push(Number(v >> 24n & 0xFFn));\n    b.push(Number(v >> 32n & 0xFFn));\n    b.push(Number(v >> 40n & 0xFFn));\n    b.push(Number(v >> 48n & 0xFFn));\n    b.push(Number(v >> 56n & 0xFFn));\n    return b;\n}\n\nexport function toUTF8Array(str) {\n    var utf8 = [];\n    for (var i=0; i < str.length; i++) {\n        var charcode = str.charCodeAt(i);\n        if (charcode < 0x80) utf8.push(charcode);\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6),\n                0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12),\n                0x80 | ((charcode>>6) & 0x3f),\n                0x80 | (charcode & 0x3f));\n        }\n        // surrogate pair\n        else {\n            i++;\n            // UTF-16 encodes 0x10000-0x10FFFF by\n            // subtracting 0x10000 and splitting the\n            // 20 bits of 0x0-0xFFFFF into two halves\n            charcode = 0x10000 + (((charcode & 0x3ff)<<10)\n                      | (str.charCodeAt(i) & 0x3ff));\n            utf8.push(0xf0 | (charcode >>18),\n                0x80 | ((charcode>>12) & 0x3f),\n                0x80 | ((charcode>>6) & 0x3f),\n                0x80 | (charcode & 0x3f));\n        }\n    }\n    return utf8;\n}\n\nexport function string(str) {\n    const bytes = toUTF8Array(str);\n    return [ ...varuint32(bytes.length), ...bytes ];\n}\n\nexport function varuint(n) {\n    const code = [];\n    let v = toNumber(n);\n    if (isNegative(v)) throw new Error(\"Number cannot be negative\");\n    while (!isZero(v)) {\n        code.push(Number(v & 0x7Fn));\n        v = v >> 7n;\n    }\n    if (code.length==0) code.push(0);\n    for (let i=0; i<code.length-1; i++) {\n        code[i] = code[i] | 0x80;\n    }\n    return code;\n}\n\nexport function varint(_n) {\n    let n, sign;\n    const bits = bitLength(_n);\n    if (_n<0) {\n        sign = true;\n        n = (1n << BigInt(bits)) + _n;\n    } else {\n        sign = false;\n        n = toNumber(_n);\n    }\n    const paddingBits = 7 - (bits % 7);\n\n    const padding = ((1n << BigInt(paddingBits)) - 1n) << BigInt(bits);\n    const paddingMask = ((1 << (7 - paddingBits))-1) | 0x80;\n\n    const code = varuint(n + padding);\n\n    if (!sign) {\n        code[code.length-1] = code[code.length-1] & paddingMask;\n    }\n\n    return code;\n}\n\nexport function varint32(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFn) throw new Error(\"Number too big\");\n    if (v > 0x7FFFFFFFn) v = v - 0x100000000n;\n    // bigInt(\"-80000000\", 16) as base10\n    if (v < -2147483648n) throw new Error(\"Number too small\");\n    return varint(v);\n}\n\nexport function varint64(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFFFFFFFFFn) throw new Error(\"Number too big\");\n    if (v > 0x7FFFFFFFFFFFFFFFn) v = v - 0x10000000000000000n;\n    // bigInt(\"-8000000000000000\", 16) as base10\n    if (v < -9223372036854775808n) throw new Error(\"Number too small\");\n    return varint(v);\n}\n\nexport function varuint32(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFn) throw new Error(\"Number too big\");\n    return varuint(v);\n}\n\nexport function varuint64(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFFFFFFFFFn) throw new Error(\"Number too big\");\n    return varuint(v);\n}\n\nexport function toHexString(byteArray) {\n    return Array.from(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nexport function ident(text) {\n    if (typeof text === \"string\") {\n        let lines = text.split(\"\\n\");\n        for (let i=0; i<lines.length; i++) {\n            if (lines[i]) lines[i] = \"    \"+lines[i];\n        }\n        return lines.join(\"\\n\");\n    } else if (Array.isArray(text)) {\n        for (let i=0; i<text.length; i++ ) {\n            text[i] = ident(text[i]);\n        }\n        return text;\n    }\n}\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nimport { FunctionBuilderWat } from \"./functionbuilder_wat.js\";\nimport * as utils from \"./utils.js\";\n\nexport class ModuleBuilderWat {\n\n    constructor() {\n        this.functions = [];\n        this.functionIdxByName = {};\n        this.nImportFunctions = 0;\n        this.nInternalFunctions =0;\n        this.memory = {\n            pagesSize: 1,\n            moduleName: \"env\",\n            fieldName: \"memory\"\n        };\n        this.free = 8;\n        this.datas = [];\n        this.modules = {};\n        this.exports = [];\n        this.functionsTable = [];\n    }\n\n    build() {\n        const src = [];\n        this._setSignatures();\n        src.push(this._buildType());\n        src.push(this._buildImport());\n        if (this.functionsTable.length>0) {\n            src.push(this._buildFunctionsTable());\n        }\n        if (this.exports.length > 0) {\n            src.push(this._buildExports());\n        }\n        if (this.functionsTable.length>0) {\n            src.push(this._buildElements());\n        }\n        if (this.nInternalFunctions>0) {\n            src.push(this._buildFunctions());\n        }\n        src.push(this._buildData());\n        return [\n            \"(module\",\n            utils.ident(src),\n            \")\"\n        ];\n    }\n\n    addFunction(fnName, comment) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilderWat(this, fnName, \"internal\", comment));\n\n        this.nInternalFunctions++;\n        return this.functions[idx];\n    }\n\n    addIimportFunction(fnName, moduleName, _fieldName) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        if (  (this.functions.length>0)\n            &&(this.functions[this.functions.length-1].type == \"internal\"))\n            throw new Error(`Import functions must be declared before internal: ${fnName}`);\n\n        let fieldName = _fieldName || fnName;\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilderWat(this, fnName, \"import\", moduleName, fieldName));\n\n        this.nImportFunctions ++;\n        return this.functions[idx];\n    }\n\n    setMemory(pagesSize, moduleName, fieldName) {\n        this.memory = {\n            pagesSize: pagesSize,\n            moduleName: moduleName || \"env\",\n            fieldName: fieldName || \"memory\"\n        };\n    }\n\n    exportFunction(fnName, _exportName) {\n        const exportName = _exportName || fnName;\n        if (typeof(this.functionIdxByName[fnName]) === \"undefined\")\n            throw new Error(`Function not defined: ${fnName}`);\n        const idx = this.functionIdxByName[fnName];\n        if (exportName != fnName) {\n            this.functionIdxByName[exportName] = idx;\n        }\n        this.exports.push({\n            exportName: exportName,\n            idx: idx\n        });\n    }\n\n    addFunctionToTable(fnName) {\n        const idx = this.functionIdxByName[fnName];\n        this.functionsTable.push(idx);\n    }\n\n    addData(offset, bytes) {\n        this.datas.push({\n            offset: offset,\n            bytes: bytes\n        });\n    }\n\n    alloc(a, b) {\n        let size;\n        let bytes;\n        if ((Array.isArray(a) || ArrayBuffer.isView(a)) && (typeof(b) === \"undefined\")) {\n            size = a.length;\n            bytes = a;\n        } else {\n            size = a;\n            bytes = b;\n        }\n        size = (((size-1)>>3) +1)<<3;       // Align to 64 bits.\n        const p = this.free;\n        this.free += size;\n        if (bytes) {\n            this.addData(p, bytes);\n        }\n        return p;\n    }\n\n    allocString(s) {\n        const encoder = new TextEncoder();\n        const uint8array = encoder.encode(s);\n        return this.alloc([...uint8array, 0]);\n    }\n\n    _setSignatures() {\n        this.signatures = [];\n        const signatureIdxByName = {};\n        if (this.functionsTable.length>0) {\n            const signature = this.functions[this.functionsTable[0]].getSignature();\n            const signatureName = this.functions[this.functionsTable[0]].getSignatureName();\n            signatureIdxByName[signatureName] = 0;\n            this.signatures.push(signature);\n        }\n        for (let i=0; i<this.functions.length; i++) {\n            const signature = this.functions[i].getSignature();\n            const signatureName = this.functions[i].getSignatureName();\n            if (typeof(signatureIdxByName[signatureName]) === \"undefined\") {\n                signatureIdxByName[signatureName] = this.signatures.length;\n                this.signatures.push(signature);\n            }\n\n            this.functions[i].signatureIdx = signatureIdxByName[signatureName];\n            this.functions[i].signatureName = signatureName;\n        }\n\n    }\n\n    _buildType() {\n        return this.signatures;\n    }\n\n    _buildImport() {\n        const src = [];\n        src.push(`(import \"${this.memory.moduleName}\" \"${this.memory.fieldName}\" (memory ${this.memory.pagesSize}))`);\n        for (let i=0; i< this.nImportFunctions; i++) {\n            src.push(`(import \"${this.functions[i].moduleName}\" \"${this.functions[i].fieldName}\" (func $${this.functions[i].fnName} (type $${this.functions[i].getSignatureName()})))`);\n        }\n        return src;\n    }\n\n    _buildFunctionsTable() {\n        return `(table ${this.functionsTable.length} anyfunc)`;\n    }\n\n    _buildElements() {\n        let funcs=\"\";\n        for (let i=0; i<this.functionsTable.length; i++) {\n            funcs += \" $\"+this.functions[this.functionsTable[i]].fnName;\n        }\n        return `(elem (i32.const 0) ${funcs})`;\n    }\n\n    _buildExports() {\n        const src = [];\n        for (let i=0; i< this.exports.length; i++) {\n            src.push(`(export \"${this.exports[i].exportName}\" (func $${this.functions[this.exports[i].idx].fnName}))`);\n        }\n        return src;\n    }\n\n    _buildFunctions() {\n        const src = [];\n        for (let i=this.nImportFunctions; i< this.nImportFunctions + this.nInternalFunctions; i++) {\n            src.push(this.functions[i].getBody());\n        }\n        return src;\n    }\n\n    _buildData() {\n        const src = [];\n        const buf = Buffer.alloc(4);\n        buf.writeUInt32LE(this.free, 0);\n        src.push(`(data (i32.const 0) ${bytes2string(buf)})`);\n        for (let i=0; i< this.datas.length; i++) {\n            src.push(`(data (i32.const ${this.datas[i].offset}) ${bytes2string(this.datas[i].bytes)})`);\n        }\n        return src;\n\n        function bytes2string(b) {\n            let S = \"\\\"\";\n            for (let i=0; i<b.length; i++) {\n                if (b[i]<32 || b[i] >126 || b[i] == 34 || b[i]==92) {\n                    let h=b[i].toString(16);\n                    while (h.length<2) h = \"0\"+h;\n                    S += \"\\\\\" + h;\n                } else {\n                    S += String.fromCharCode(b[i]);\n                }\n            }\n            S +=  \"\\\"\";\n            return S;\n        }\n    }\n\n}\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { CodeBuilderWat } from \"./codebuilder_wat.js\";\nimport * as utils from \"./utils.js\";\n\nexport class FunctionBuilderWat {\n\n    constructor (module, fnName, fnType, moduleName, fieldName) {\n        if (fnType == \"import\") {\n            this.fnType = \"import\";\n            this.moduleName = moduleName;\n            this.fieldName = fieldName;\n        } else if (fnType == \"internal\") {\n            this.fnType = \"internal\";\n            this.comment = moduleName;\n        } else {\n            throw new Error(\"Invalid function fnType: \" + fnType);\n        }\n        this.module = module;\n        this.fnName = fnName;\n        this.params = [];\n        this.locals = [];\n        this.localIdxByName = {};\n        this.code = [];\n        this.returnType = null;\n        this.nextLocal =0;\n    }\n\n    addParam(paramName, paramType) {\n        if (this.localIdxByName[paramName])\n            throw new Error(`param already exists. Function: ${this.fnName}, Param: ${paramName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[paramName] = idx;\n        this.params.push({\n            type: paramType,\n            name: paramName\n        });\n    }\n\n    addLocal(localName, localType, _length) {\n        if ((typeof _length != \"undefined\") && (_length != 1)) {\n            throw new Error(\"Locals greater than 1 not implemented\");\n        }\n        if (this.localIdxByName[localName])\n            throw new Error(`local already exists. Function: ${this.fnName}, Param: ${localName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[localName] = idx;\n        this.locals.push({\n            type: localType,\n            name: localName,\n        });\n    }\n\n    setReturnType(returnType) {\n        if (this.returnType)\n            throw new Error(`returnType already defined. Function: ${this.fnName}`);\n        this.returnType = returnType;\n    }\n\n    getSignature() {\n        let p = \"\";\n        for (let i=0; i<this.params.length; i++) {\n            if (i==0) p += \" (param\";\n            p += \" \" + this.params[i].type;\n        }\n        if (p!=\"\") p+= \")\";\n        let r = \"\";\n        if (this.returnType) {\n            r += ` (result ${this.returnType})`;\n        }\n        return `(type $${this.getSignatureName()} (func ${p}${r}))`;\n    }\n\n    getSignatureName() {\n        let s = \"_sig_\";\n        for (let i=0; i<this.params.length; i++) {\n            s += this.params[i].type;\n        }\n        if (this.returnType) {\n            s+=\"r\"+this.returnType;\n        }\n        return s;\n    }\n\n    getBody() {\n        const src = [];\n\n        for (let i=0; i<this.params.length; i++) {\n            src.push(` (param $${this.params[i].name} ${this.params[i].type})`);\n        }\n        if (this.returnType) {\n            src.push(`(result ${this.returnType})`);\n        }\n        for (let i=0; i<this.locals.length; i++) {\n            src.push(` (local $${this.locals[i].name} ${this.locals[i].type})`);\n        }\n        src.push(this.code);\n\n        let Ss;\n        if (this.comment) {\n            Ss = this.comment.split(\"\\n\");\n            for (let i=0; i<Ss.length; i++) {\n                Ss[i] = \";; \" + Ss[i];\n            }\n        } else {\n            Ss = [];\n        }\n\n        return [\n            ...Ss,\n            `(func $${this.fnName} (type $${this.getSignatureName()})`,\n            utils.ident(src),\n            \")\"\n        ];\n\n    }\n\n    addCode(...code) {\n        this.code.push(code);\n    }\n\n    getCodeBuilder() {\n        return new CodeBuilderWat(this);\n    }\n}\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as utils from \"./utils.js\";\n\nexport class CodeBuilderWat {\n    constructor(func) {\n        this.func = func;\n        this.functionName = func.functionName;\n        this.module = func.module;\n    }\n\n    setLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [valCode, `set_local $${localName}`];\n    }\n\n    teeLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [valCode, `tee_local $${localName}`];\n    }\n\n    getLocal(localName) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return `get_local $${localName}`;\n    }\n\n    genLoad(inst, def_align, idxCode, _offset, _align) {\n        let S = inst;\n        const offset = _offset || 0;\n        if (offset>0) S += ` offset=${offset}`;\n        const align = (_align === undefined) ? def_align : _align;  // 8 bits alignment by default\n        if (align!=def_align) S += ` align=${1 << align}`;\n        return [idxCode, S];\n    }\n\n\n    genStore(inst, def_align, idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (typeof _align === \"undefined\") {\n            offset = 0;\n            align = def_align;\n            codeVal = _offset;\n        } else if (typeof _codeVal === \"undefined\") {\n            offset = _offset;\n            align = def_align;\n            codeVal = _align;\n        } else {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        let S = inst;\n        if (offset>0) S += ` offset=${offset}`;\n        if (align!=def_align) S += ` align=${1 << align}`;\n        return [idxCode, codeVal, S];\n    }\n\n    i64_load8_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load8_s\", 0, idxCode, _offset, _align);\n    }\n\n    i64_load8_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load8_u\", 0, idxCode, _offset, _align);\n    }\n\n    i64_load16_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load16_s\", 1,idxCode, _offset, _align);\n    }\n\n    i64_load16_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load16_u\", 1, idxCode, _offset, _align);\n    }\n\n    i64_load32_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load32_s\", 2, idxCode, _offset, _align);\n    }\n\n    i64_load32_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load32_u\", 2, idxCode, _offset, _align);\n    }\n\n    i64_load(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load\", 3, idxCode, _offset, _align);\n    }\n\n\n    i64_store(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store\", 3, idxCode, _offset, _align, _codeVal);\n    }\n\n    i64_store32(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store32\", 2, idxCode, _offset, _align, _codeVal);\n    }\n\n    i64_store16(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store16\", 1, idxCode, _offset, _align, _codeVal);\n    }\n\n    i64_store8(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store8\", 0, idxCode, _offset, _align, _codeVal);\n    }\n\n    i32_load8_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load8_s\", 0, idxCode, _offset, _align);\n    }\n\n    i32_load8_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load8_u\", 0, idxCode, _offset, _align);\n    }\n\n    i32_load16_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load16_s\", 1, idxCode, _offset, _align);\n    }\n\n    i32_load16_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load16_u\", 1, idxCode, _offset, _align);\n    }\n\n    i32_load(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load\", 2, idxCode, _offset, _align);\n    }\n\n    i32_store(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i32.store\", 2, idxCode, _offset, _align, _codeVal);\n    }\n\n    i32_store16(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i32.store16\", 1, idxCode, _offset, _align, _codeVal);\n    }\n\n    i32_store8(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i32.store8\", 0, idxCode, _offset, _align, _codeVal);\n    }\n\n    call(fnName, ...args) {\n        const idx = this.module.functionIdxByName[fnName];\n        if (idx === undefined)\n            throw new Error(`Function not defined: Function: ${fnName}`);\n        return [args, `call $${fnName}`];\n    }\n\n    call_indirect(fnIdx, ...args) {\n        return [args, fnIdx, \"call_indirect (type 0)\"];\n    }\n\n    if(condCode, thenCode, elseCode) {\n        if (elseCode) {\n            return [condCode, \"if\", utils.ident(thenCode), \"else\", utils.ident(elseCode), \"end\"];\n        } else {\n            return [condCode, \"if\", utils.ident(thenCode), \"end\"];\n        }\n    }\n\n    block(bCode) { return [\"block\", utils.ident(bCode), \"end\"]; }\n    loop(...args) { return [\"loop\", utils.ident(args), \"end\"]; }\n    br_if(relPath, condCode) { return [condCode, `br_if ${relPath}`]; }\n    br(relPath) { return `br ${relPath}`; }\n    ret(rCode) { return [rCode, \"return\"]; }\n    drop(dCode) { return [dCode,  \"drop\"]; }\n\n    i64_const(num) { return `i64.const ${num}`; }\n    i32_const(num) { return `i32.const ${num}`; }\n\n    i64_eqz(opcode) { return [opcode, \"i64.eqz\"]; }\n    i64_eq(op1code, op2code) { return [op1code, op2code, \"i64.eq\"]; }\n    i64_ne(op1code, op2code) { return [op1code, op2code, \"i64.ne\"]; }\n    i64_lt_s(op1code, op2code) { return [op1code, op2code, \"i64.lt_s\"]; }\n    i64_lt_u(op1code, op2code) { return [op1code, op2code, \"i64.lt_u\"]; }\n    i64_gt_s(op1code, op2code) { return [op1code, op2code, \"i64.gt_s\"]; }\n    i64_gt_u(op1code, op2code) { return [op1code, op2code, \"i64.gt_u\"]; }\n    i64_le_s(op1code, op2code) { return [op1code, op2code, \"i64.le_s\"]; }\n    i64_le_u(op1code, op2code) { return [op1code, op2code, \"i64.le_u\"]; }\n    i64_ge_s(op1code, op2code) { return [op1code, op2code, \"i64.ge_s\"]; }\n    i64_ge_u(op1code, op2code) { return [op1code, op2code, \"i64.ge_u\"]; }\n    i64_add(op1code, op2code) { return [op1code, op2code, \"i64.add\"]; }\n    i64_sub(op1code, op2code) { return [op1code, op2code, \"i64.sub\"]; }\n    i64_mul(op1code, op2code) { return [op1code, op2code, \"i64.mul\"]; }\n    i64_div_s(op1code, op2code) { return [op1code, op2code, \"i64.div_s\"]; }\n    i64_div_u(op1code, op2code) { return [op1code, op2code, \"i64.div_u\"]; }\n    i64_rem_s(op1code, op2code) { return [op1code, op2code, \"i64.rem_s\"]; }\n    i64_rem_u(op1code, op2code) { return [op1code, op2code, \"i64.rem_u\"]; }\n    i64_and(op1code, op2code) { return [op1code, op2code, \"i64.and\"]; }\n    i64_or(op1code, op2code) { return [op1code, op2code, \"i64.or\"]; }\n    i64_xor(op1code, op2code) { return [op1code, op2code, \"i64.xor\"]; }\n    i64_shl(op1code, op2code) { return [op1code, op2code, \"i64.shl\"]; }\n    i64_shr_s(op1code, op2code) { return [op1code, op2code, \"i64.shr_s\"]; }\n    i64_shr_u(op1code, op2code) { return [op1code, op2code, \"i64.shr_u\"]; }\n    i64_extend_i32_s(op1code) { return [op1code, \"i64.extend_s/i32\"]; }\n    i64_extend_i32_u(op1code) { return [op1code, \"i64.extend_u/i32\"]; }\n\n\n    i32_eqz(op1code) { return [op1code, \"i32.eqz\"]; }\n    i32_eq(op1code, op2code) { return [op1code, op2code, \"i32.eq\"]; }\n    i32_ne(op1code, op2code) { return [op1code, op2code, \"i32.ne\"]; }\n    i32_lt_s(op1code, op2code) { return [op1code, op2code, \"i32.lt_s\"]; }\n    i32_lt_u(op1code, op2code) { return [op1code, op2code, \"i32.lt_u\"]; }\n    i32_gt_s(op1code, op2code) { return [op1code, op2code, \"i32.gt_s\"]; }\n    i32_gt_u(op1code, op2code) { return [op1code, op2code, \"i32.gt_u\"]; }\n    i32_le_s(op1code, op2code) { return [op1code, op2code, \"i32.le_s\"]; }\n    i32_le_u(op1code, op2code) { return [op1code, op2code, \"i32.le_u\"]; }\n    i32_ge_s(op1code, op2code) { return [op1code, op2code, \"i32.ge_s\"]; }\n    i32_ge_u(op1code, op2code) { return [op1code, op2code, \"i32.ge_u\"]; }\n    i32_add(op1code, op2code) { return [op1code, op2code, \"i32.add\"]; }\n    i32_sub(op1code, op2code) { return [op1code, op2code, \"i32.sub\"]; }\n    i32_mul(op1code, op2code) { return [op1code, op2code, \"i32.mul\"]; }\n    i32_div_s(op1code, op2code) { return [op1code, op2code, \"i32.div_s\"]; }\n    i32_div_u(op1code, op2code) { return [op1code, op2code, \"i32.div_u\"]; }\n    i32_rem_s(op1code, op2code) { return [op1code, op2code, \"i32.rem_s\"]; }\n    i32_rem_u(op1code, op2code) { return [op1code, op2code, \"i32.rem_u\"]; }\n    i32_and(op1code, op2code) { return [op1code, op2code, \"i32.and\"]; }\n    i32_or(op1code, op2code) { return [op1code, op2code, \"i32.or\"]; }\n    i32_xor(op1code, op2code) { return [op1code, op2code, \"i32.xor\"]; }\n    i32_shl(op1code, op2code) { return [op1code, op2code, \"i32.shl\"]; }\n    i32_shr_s(op1code, op2code) { return [op1code, op2code, \"i32.shr_s\"]; }\n    i32_shr_u(op1code, op2code) { return [op1code, op2code, \"i32.shr_u\"]; }\n    i32_rotl(op1code, op2code) { return [op1code, op2code, \"i32.rotl\"]; }\n    i32_rotr(op1code, op2code) { return [op1code, op2code, \"i32.rotr\"]; }\n    i32_wrap_i64(op1code) { return [op1code, \"i32.wrap/i64\"]; }\n\n    ureachable() { return \"unreachable\"; }\n\n    current_memory() { return \"current_memory\"; }\n\n    comment(c) { return \";; \" + c; }\n\n}\n", "/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of websnark (Web Assembly zkSnark Prover).\n\n    websnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    websnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with websnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { ModuleBuilder } from \"./modulebuilder.js\";\n\nexport async function buildProtoboard(builder, defBytes, bitsPerBytes) {\n    const protoboard = new Protoboard();\n\n    protoboard.defBytes = defBytes;\n    protoboard.bitsPerBytes = bitsPerBytes || 32;\n\n    protoboard.memory = new WebAssembly.Memory({initial:20000});\n    protoboard.i32 = new Uint32Array(protoboard.memory.buffer);\n    protoboard.i8 = new Uint8Array(protoboard.memory.buffer);\n\n    const moduleBuilder = new ModuleBuilder();\n\n    const fLog32 = moduleBuilder.addIimportFunction(\"debug_log32\", \"debug\", \"log32\");\n    fLog32.addParam(\"x\", \"i32\");\n    const fLog64 = moduleBuilder.addIimportFunction(\"debug_log64\", \"debug\", \"log64\");\n    fLog64.addParam(\"x\", \"i32\");\n    fLog64.addParam(\"y\", \"i32\");\n\n    buildLog32(moduleBuilder);\n    buildLog64(moduleBuilder);\n\n    builder(moduleBuilder, protoboard);\n\n\n    const code = moduleBuilder.build();\n\n    const wasmModule = await WebAssembly.compile(code);\n\n    protoboard.log = console.log;\n\n    protoboard.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": protoboard.memory\n        },\n        debug: {\n            log32: function (c1) {\n                if (c1<0) c1 = 0x100000000+c1;\n                let s=c1.toString(16);\n                while (s.length<8) s = \"0\"+s;\n                protoboard.log(s + \": \" + c1.toString());\n            },\n            log64: function (c1, c2) {\n                if (c1<0) c1 = 0x100000000+c1;\n                if (c2<0) c2 = 0x100000000+c2;\n                const n = BigInt(c1) + (BigInt(c2) << 32n);\n                let s=n.toString(16);\n                while (s.length<16) s = \"0\"+s;\n                protoboard.log(s + \": \" + n.toString());\n            }\n        }\n    });\n\n    Object.assign(protoboard, protoboard.instance.exports);\n    Object.assign(protoboard, moduleBuilder.modules);\n\n    return protoboard;\n\n    function buildLog32(module) {\n\n        const f = module.addFunction(\"log32\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(\"debug_log32\", c.getLocal(\"x\")));\n    }\n\n    function buildLog64(module) {\n\n        const f = module.addFunction(\"log64\");\n        f.addParam(\"x\", \"i64\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(\n            \"debug_log64\",\n            c.i32_wrap_i64(c.getLocal(\"x\")),\n            c.i32_wrap_i64(\n                c.i64_shr_u(\n                    c.getLocal(\"x\"),\n                    c.i64_const(32)\n                )\n            )\n        ));\n    }\n\n}\n\nclass Protoboard {\n\n    constructor() {\n\n    }\n\n    alloc(length) {\n        if (typeof length === \"undefined\") {\n            length = this.defBytes;\n        }\n        length = (((length-1)>>3) +1)<<3;       // Align to 64 bits.\n\n        const res = this.i32[0];\n        this.i32[0] += length;\n        return res;\n    }\n\n    set(pos, nums, nBytes) {\n        if (!Array.isArray(nums)) {\n            nums = [nums];\n        }\n        if (typeof nBytes === \"undefined\") {\n            nBytes = this.defBytes;\n        }\n\n        const words = Math.floor((nBytes -1)/4)+1;\n        let p = pos;\n\n        const CHUNK = 1n << BigInt(this.bitsPerBytes);\n\n        for (let i=0; i<nums.length; i++) {\n            let v = BigInt(nums[i]);\n            for (let j=0; j<words; j++) {\n                const quotient = v / CHUNK;\n                const remainder = v % CHUNK;\n                this.i32[p>>2] = Number(remainder);\n                v = quotient;\n                p += 4;\n            }\n            if (v !== 0n) {\n                throw new Error(\"Expected v to be 0\");\n            }\n        }\n\n        return pos;\n    }\n\n    get(pos, nElements, nBytes) {\n        if (typeof nBytes == \"undefined\") {\n            if (typeof nElements == \"undefined\") {\n                nElements = 1;\n                nBytes = this.defBytes;\n            } else {\n                nElements = nBytes;\n                nBytes = this.defBytes;\n            }\n        }\n\n        const words = Math.floor((nBytes -1)/4)+1;\n\n        const CHUNK = 1n << BigInt(this.bitsPerBytes);\n\n\n        const nums = [];\n        for (let i=0; i<nElements; i++) {\n            let acc = 0n;\n            for (let j=words-1; j>=0; j--) {\n                acc = acc * CHUNK;\n                let v = this.i32[(pos>>2)+j];\n                if (this.bitsPerBytes <32) {\n                    if (v&0x80000000) v = v-0x100000000;\n                }\n                acc = acc + BigInt(v);\n            }\n            nums.push(acc);\n            pos += words*4;\n        }\n\n        if (nums.length == 1) return nums[0];\n        return nums;\n    }\n}\n", "import { buildBls12381 as buildBls12381wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bls12381 = null;\n\nexport default async function buildBls12381(singleThread, plugins) {\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBls12381wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bls12381wasm = {};\n\n    bls12381wasm.code = moduleBuilder.build();\n    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;\n    bls12381wasm.pr = moduleBuilder.modules.frm.pq;\n    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;\n    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;\n    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;\n    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;\n    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;\n    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;\n    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;\n    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;\n    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;\n    bls12381wasm.n8q = 48;\n    bls12381wasm.n8r = 32;\n    bls12381wasm.q = moduleBuilder.modules.bls12381.q;\n    bls12381wasm.r = moduleBuilder.modules.bls12381.r;\n\n\n    if ((!singleThread) && (globalThis.curve_bls12381)) return globalThis.curve_bls12381;\n    const params = {\n        name: \"bls12381\",\n        wasm: bls12381wasm,\n        q: Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16),\n        r: Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16),\n        n8q: 48,\n        n8r: 32,\n        cofactorG1: Scalar.e(\"0x396c8c005555e1568c00aaab0000aaab\", 16),\n        cofactorG2: Scalar.e(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bls12381 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bls12381 = curve;\n    }\n\n    return curve;\n}\n\n", "import * as Scalar from \"./scalar.js\";\nimport {default as buildBn128} from \"./bn128.js\";\nimport {default as buildBls12381} from \"./bls12381.js\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nexport async function getCurveFromR(r, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(r, bn128r)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(r, bls12381r)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromQ(q, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(q, bn128q)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(q, bls12381q)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(q, 16)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromName(name, singleThread, plugins) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n", null, null, null, null, null, null, null, null, "import { hash } from './hash';\nimport {\n  ZKProof,\n  ProvingMethod,\n  ProvingMethodAlg,\n  ProofInputsPreparerHandlerFunc,\n  getProvingMethod,\n  prepare,\n} from './proving';\n\nimport { base64url as base64 } from 'rfc4648';\nimport { toBigEndian } from '@iden3/js-iden3-core';\n\nexport enum Header {\n  Type = 'typ',\n  Alg = 'alg',\n  CircuitId = 'circuitId',\n  Critical = 'crit',\n}\n\nexport interface IRawJSONWebZeroknowledge {\n  payload: Uint8Array;\n  protectedHeaders: Uint8Array;\n  header: { [key: string]: unknown };\n  zkp: Uint8Array;\n\n  sanitized(): Promise<Token>;\n}\n\nexport class RawJSONWebZeroknowledge implements IRawJSONWebZeroknowledge {\n  constructor(\n    public payload: Uint8Array,\n    public protectedHeaders: Uint8Array,\n    public header: { [key: string]: unknown },\n    public zkp: Uint8Array,\n  ) {}\n\n  async sanitized(): Promise<Token> {\n    if (!this.payload) {\n      throw new Error('iden3/js-jwz: missing payload in JWZ message');\n    }\n\n    const headers: { [key: string]: unknown } = JSON.parse(\n      new TextDecoder().decode(this.protectedHeaders),\n    );\n    const criticalHeaders = headers[Header.Critical] as string[];\n    criticalHeaders.forEach((key: string) => {\n      if (!headers[key]) {\n        throw new Error(\n          `iden3/js-jwz: header is listed in critical ${key}, but not presented`,\n        );\n      }\n    });\n\n    const alg = headers[Header.Alg] as string;\n    const circuitId = headers[Header.CircuitId] as string;\n\n    const method = await getProvingMethod(new ProvingMethodAlg(alg, circuitId));\n    const zkp = JSON.parse(new TextDecoder().decode(this.zkp));\n    const token = new Token(method, new TextDecoder().decode(this.payload));\n    token.alg = alg;\n    token.circuitId = circuitId;\n    token.zkProof = zkp;\n    for (const [key, value] of Object.entries(headers)) {\n      token.setHeader(key, value);\n    }\n\n    return token;\n  }\n}\n\n// Token represents a JWZ Token.\nexport class Token {\n  public alg: string;\n  public circuitId: string;\n  private raw: IRawJSONWebZeroknowledge;\n  public zkProof: ZKProof = {} as ZKProof;\n\n  constructor(\n    public readonly method: ProvingMethod,\n    payload: string,\n    private readonly inputsPreparer?: ProofInputsPreparerHandlerFunc,\n  ) {\n    this.alg = this.method.alg;\n    this.circuitId = this.method.circuitId;\n    this.raw = {} as IRawJSONWebZeroknowledge;\n    this.raw.header = this.getDefaultHeaders();\n\n    this.raw.payload = new TextEncoder().encode(payload);\n  }\n\n  public setHeader(key: string, value: unknown): void {\n    this.raw.header[key] = value;\n  }\n\n  public getPayload(): string {\n    return new TextDecoder().decode(this.raw.payload);\n  }\n\n  private getDefaultHeaders(): { [key: string]: string | string[] } {\n    return {\n      [Header.Alg]: this.alg,\n      [Header.Critical]: [Header.CircuitId],\n      [Header.CircuitId]: this.circuitId,\n      [Header.Type]: 'JWZ',\n    };\n  }\n\n  // Parse parses a jwz message in compact or full serialization format.\n  static parse(tokenStr: string): Promise<Token> {\n    // Parse parses a jwz message in compact or full serialization format.\n    const token = tokenStr?.trim();\n    return token.startsWith('{')\n      ? Token.parseFull(tokenStr)\n      : Token.parseCompact(tokenStr);\n  }\n\n  // parseCompact parses a message in compact format.\n  private static async parseCompact(tokenStr: string): Promise<Token> {\n    const parts = tokenStr.split('.');\n    if (parts.length != 3) {\n      throw new Error(\n        'iden3/js-jwz: compact JWZ format must have three segments',\n      );\n    }\n    const rawProtected = base64.parse(parts[0], { loose: true });\n\n    const rawPayload = base64.parse(parts[1], { loose: true });\n\n    const proof = base64.parse(parts[2], { loose: true });\n\n    const raw: IRawJSONWebZeroknowledge = new RawJSONWebZeroknowledge(\n      rawPayload,\n      rawProtected,\n      {},\n      proof,\n    );\n\n    return await raw.sanitized();\n  }\n\n  // parseFull parses a message in full format.\n  private static async parseFull(tokenStr: string): Promise<Token> {\n    const raw: IRawJSONWebZeroknowledge = JSON.parse(tokenStr);\n    return await raw.sanitized();\n  }\n\n  // Prove creates and returns a complete, proved JWZ.\n  // The token is proven using the Proving Method specified in the token.\n  async prove(provingKey: Uint8Array, wasm: Uint8Array): Promise<string> {\n    // all headers must be protected\n    const headers = this.serializeHeaders();\n\n    this.raw.protectedHeaders = new TextEncoder().encode(headers);\n\n    const msgHash: Uint8Array = await this.getMessageHash();\n\n    if (!this.inputsPreparer) {\n      throw new Error('iden3/jwz: prepare func must be defined');\n    }\n    const inputs: Uint8Array = await prepare(\n      this.inputsPreparer,\n      msgHash,\n      this.circuitId,\n    );\n\n    const proof: ZKProof = await this.method.prove(inputs, provingKey, wasm);\n\n    const marshaledProof = JSON.stringify(proof);\n\n    this.zkProof = proof;\n    this.raw.zkp = new TextEncoder().encode(marshaledProof);\n\n    return this.compactSerialize();\n  }\n\n  // CompactSerialize returns token serialized in three parts: base64 encoded headers, payload and proof.\n  compactSerialize(): string {\n    if (!this.raw.header || !this.raw.protectedHeaders || !this.zkProof) {\n      throw new Error(\"iden3/jwz:can't serialize without one of components\");\n    }\n\n    const serializedProtected = base64.stringify(this.raw.protectedHeaders, {\n      pad: false,\n    });\n    const serializedProof = base64.stringify(this.raw.zkp, { pad: false });\n    const serializedPayload = base64.stringify(this.raw.payload, {\n      pad: false,\n    });\n    return `${serializedProtected}.${serializedPayload}.${serializedProof}`;\n  }\n\n  // fullSerialize returns marshaled presentation of raw token as json string.\n  fullSerialize(): string {\n    return JSON.stringify(this.raw);\n  }\n\n  async getMessageHash(): Promise<Uint8Array> {\n    const serializedHeadersJSON = this.serializeHeaders();\n\n    const serializedHeaders = new TextEncoder().encode(serializedHeadersJSON);\n    const protectedHeaders = base64.stringify(serializedHeaders, {\n      pad: false,\n    });\n\n    const payload = base64.stringify(this.raw.payload, { pad: false });\n\n    // JWZ ZkProof input value is ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload)).\n    const messageToProof = new TextEncoder().encode(\n      `${protectedHeaders}.${payload}`,\n    );\n\n    const hashInt: bigint = await hash(messageToProof);\n\n    return toBigEndian(hashInt, 32);\n  }\n\n  // Verify  perform zero knowledge verification.\n  async verify(verificationKey: Uint8Array): Promise<boolean> {\n    // 1. prepare hash o payload message that had to be proven\n    const msgHash = await this.getMessageHash();\n\n    // 2. verify that zkp is valid\n\n    return this.method.verify(msgHash, this.zkProof, verificationKey);\n  }\n\n  serializeHeaders() {\n    return JSON.stringify(this.raw.header, Object.keys(this.raw.header).sort());\n  }\n}\n", "export interface ZKProof {\n  proof: ProofData;\n  pub_signals: string[];\n}\nexport interface ProofData {\n  pi_a: string[];\n  pi_b: string[][];\n  pi_c: string[];\n  protocol: string;\n}\n\nexport class ProvingMethodAlg {\n  constructor(public readonly alg: string, public readonly circuitId: string) {}\n\n  toString(): string {\n    return `${this.alg}:${this.circuitId}`;\n  }\n}\n\nconst provingMethods = new Map<string, () => ProvingMethod>(); // map[string]func() ProvingMethod{}\n\n// ProvingMethod can be used add new methods for signing or verifying tokens.\nexport interface ProvingMethod {\n  // Returns true if proof is valid\n  verify(\n    messageHash: Uint8Array,\n    proof: ZKProof,\n    verificationKey: Uint8Array,\n  ): Promise<boolean>;\n  // Returns proof or error\n  prove(\n    inputs: Uint8Array,\n    provingKey: Uint8Array,\n    wasm: Uint8Array,\n  ): Promise<ZKProof>;\n\n  readonly methodAlg: ProvingMethodAlg;\n\n  readonly alg: string;\n  // Returns the alg identifier for this method (example: 'AUTH-GROTH-16')\n  readonly circuitId: string;\n}\n\n// RegisterProvingMethod registers the \"alg\" name and a factory function for proving method.\n// This is typically done during init() in the method's implementation\nexport function registerProvingMethod(\n  alg: ProvingMethodAlg,\n  f: () => ProvingMethod,\n): Promise<void> {\n  return new Promise((res) => {\n    provingMethods.set(alg.toString(), f);\n    res();\n  });\n}\n\n// GetProvingMethod retrieves a proving method from an \"alg\" string\nexport function getProvingMethod(\n  alg: ProvingMethodAlg,\n): Promise<ProvingMethod> {\n  return new Promise((res, rej) => {\n    const func = provingMethods.get(alg.toString());\n    if (func) {\n      const method: ProvingMethod = func();\n      res(method);\n    } else {\n      rej('unknown alg');\n    }\n  });\n}\n\nexport function getAlgorithms(): Promise<string[]> {\n  return Promise.resolve(\n    Array.from(provingMethods.keys()).map((k) => k.split(':')[0]),\n  );\n}\n\n// ProofInputsPreparerHandlerFunc prepares inputs using hash message and circuit id\nexport type ProofInputsPreparerHandlerFunc = (\n  hash: Uint8Array,\n  circuitId: string,\n) => Promise<Uint8Array>;\n\n// Prepare function is responsible to call provided handler for inputs preparation\nexport function prepare(\n  f: ProofInputsPreparerHandlerFunc,\n  hash: Uint8Array,\n  circuitId: string,\n): Promise<Uint8Array> {\n  return f(hash, circuitId);\n}\n", "// Generated by rollup-plugin-mjs-entry\n\nimport cjs from './index.js';\n\nexport const base16 = cjs.base16;\nexport const base32 = cjs.base32;\nexport const base32hex = cjs.base32hex;\nexport const base64 = cjs.base64;\nexport const base64url = cjs.base64url;\nexport const codec = cjs.codec;\nexport default cjs;\n", "import { ProvingMethod, ProvingMethodAlg, ZKProof } from './proving';\nimport { Id } from '@iden3/js-iden3-core';\nimport { AuthCircuit, Groth16, prove, verify } from './common';\n\n// AuthPubSignals auth.circom public signals\ninterface AuthPubSignals {\n  challenge: bigint;\n  userState: bigint;\n  userId: Id;\n}\n\n// ProvingMethodGroth16Auth defines proofs family and specific circuit\nclass ProvingMethodGroth16Auth implements ProvingMethod {\n  constructor(public readonly methodAlg: ProvingMethodAlg) {}\n\n  get alg(): string {\n    return this.methodAlg.alg;\n  }\n\n  get circuitId(): string {\n    return this.methodAlg.circuitId;\n  }\n\n  unmarshall(pubsignals: string[]): AuthPubSignals {\n    const outputs: AuthPubSignals = {} as AuthPubSignals;\n    if (pubsignals.length != 3) {\n      throw new Error(\n        `invalid number of Output values expected ${3} got ${\n          pubsignals.length\n        }`,\n      );\n    }\n    outputs.challenge = BigInt(pubsignals[0]);\n    outputs.userState = BigInt(pubsignals[1]);\n    outputs.userId = Id.fromBigInt(BigInt(pubsignals[2]));\n\n    return outputs;\n  }\n\n  async verify(\n    messageHash: Uint8Array,\n    proof: ZKProof,\n    verificationKey: Uint8Array,\n  ): Promise<boolean> {\n    return verify<AuthPubSignals>(\n      messageHash,\n      proof,\n      verificationKey,\n      this.unmarshall,\n    );\n  }\n\n  prove(\n    inputs: Uint8Array,\n    provingKey: Uint8Array,\n    wasm: Uint8Array,\n  ): Promise<ZKProof> {\n    return prove(inputs, provingKey, wasm);\n  }\n}\n\nexport const provingMethodGroth16AuthInstance: ProvingMethod =\n  new ProvingMethodGroth16Auth(new ProvingMethodAlg(Groth16, AuthCircuit));\n", "import { ZKProof } from './proving';\nimport { witnessBuilder } from './witness_calculator';\nimport * as snarkjs from 'snarkjs';\nimport { fromBigEndian } from '@iden3/js-iden3-core';\n\nexport const Groth16 = 'groth16';\nexport const AuthCircuit = 'auth';\nexport const AuthV2Circuit = 'authV2';\n\nexport async function prove(\n  inputs: Uint8Array,\n  provingKey: Uint8Array,\n  wasm: Uint8Array,\n): Promise<ZKProof> {\n  const witnessCalculator = await witnessBuilder(wasm);\n\n  const jsonString = new TextDecoder().decode(inputs);\n\n  const parsedData = JSON.parse(jsonString);\n  const wtnsBytes: Uint8Array = await witnessCalculator.calculateWTNSBin(\n    parsedData,\n    0,\n  );\n\n  const { proof, publicSignals } = await snarkjs.groth16.prove(\n    provingKey,\n    wtnsBytes,\n  );\n\n  return {\n    proof: proof,\n    pub_signals: publicSignals,\n  };\n}\n\nexport async function verify<T extends { challenge: bigint }>(\n  messageHash: Uint8Array,\n  proof: ZKProof,\n  verificationKey: Uint8Array,\n  unmarshall: (pubSignals: string[]) => T,\n): Promise<boolean> {\n  const outputs: T = unmarshall(proof.pub_signals);\n  if (outputs.challenge !== fromBigEndian(messageHash)) {\n    throw new Error('challenge is not equal to message hash');\n  }\n\n  return await snarkjs.groth16.verify(\n    JSON.parse(Buffer.from(verificationKey).toString()),\n    proof.pub_signals,\n    proof.proof,\n  );\n}\n", "/* eslint-disable require-await */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport async function witnessBuilder(code, options?) {\n  options = options || {};\n\n  let wasmModule;\n  try {\n    wasmModule = await WebAssembly.compile(code);\n  } catch (err) {\n    console.log(err);\n    console.log(\n      '\\nTry to run circom --c in order to generate c++ code instead\\n',\n    );\n    throw new Error(err);\n  }\n\n  let wc;\n\n  let errStr = '';\n  let msgStr = '';\n\n  const instance = await WebAssembly.instantiate(wasmModule, {\n    runtime: {\n      exceptionHandler: function (code) {\n        let err;\n        if (code == 1) {\n          err = 'Signal not found.\\n';\n        } else if (code == 2) {\n          err = 'Too many signals set.\\n';\n        } else if (code == 3) {\n          err = 'Signal already set.\\n';\n        } else if (code == 4) {\n          err = 'Assert Failed.\\n';\n        } else if (code == 5) {\n          err = 'Not enough memory.\\n';\n        } else if (code == 6) {\n          err = 'Input signal array access exceeds the size.\\n';\n        } else {\n          err = 'Unknown error.\\n';\n        }\n        throw new Error(err + errStr);\n      },\n      printErrorMessage: function () {\n        errStr += getMessage() + '\\n';\n        // console.error(getMessage());\n      },\n      writeBufferMessage: function () {\n        const msg = getMessage();\n        // Any calls to `log()` will always end with a `\\n`, so that's when we print and reset\n        if (msg === '\\n') {\n          console.log(msgStr);\n          msgStr = '';\n        } else {\n          // If we've buffered other content, put a space in between the items\n          if (msgStr !== '') {\n            msgStr += ' ';\n          }\n          // Then append the message to the message we are creating\n          msgStr += msg;\n        }\n      },\n      showSharedRWMemory: function () {\n        printSharedRWMemory();\n      },\n    },\n  });\n\n  const sanityCheck = options;\n  //        options &&\n  //        (\n  //            options.sanityCheck ||\n  //            options.logGetSignal ||\n  //            options.logSetSignal ||\n  //            options.logStartComponent ||\n  //            options.logFinishComponent\n  //        );\n\n  wc = new WitnessCalculator(instance, sanityCheck);\n  return wc;\n\n  function getMessage() {\n    let message = '';\n    let c = (instance as any).exports.getMessageChar();\n    while (c != 0) {\n      message += String.fromCharCode(c);\n      c = (instance as any).exports.getMessageChar();\n    }\n    return message;\n  }\n\n  function printSharedRWMemory() {\n    const shared_rw_memory_size = (instance as any).exports.getFieldNumLen32();\n    const arr = new Uint32Array(shared_rw_memory_size);\n    for (let j = 0; j < shared_rw_memory_size; j++) {\n      arr[shared_rw_memory_size - 1 - j] = (\n        instance as any\n      ).exports.readSharedRWMemory(j);\n    }\n\n    // If we've buffered other content, put a space in between the items\n    if (msgStr !== '') {\n      msgStr += ' ';\n    }\n    // Then append the value to the message we are creating\n    msgStr += fromArray32(arr).toString();\n  }\n}\n\nclass WitnessCalculator {\n  version: any;\n  n32: any;\n  prime: any;\n  witnessSize: any;\n  sanityCheck: any;\n  constructor(private instance, sanityCheck) {\n    this.instance = instance;\n    this.version = (this.instance.exports as any).getVersion();\n    this.n32 = (this.instance.exports as any).getFieldNumLen32();\n\n    (this.instance.exports as any).getRawPrime();\n    const arr = new Uint32Array(this.n32);\n    for (let i = 0; i < this.n32; i++) {\n      arr[this.n32 - 1 - i] = (this.instance.exports as any).readSharedRWMemory(\n        i,\n      );\n    }\n    this.prime = fromArray32(arr);\n\n    this.witnessSize = (this.instance.exports as any).getWitnessSize();\n\n    this.sanityCheck = sanityCheck;\n  }\n\n  circom_version() {\n    return (this.instance.exports as any).getVersion();\n  }\n\n  async _doCalculateWitness(input, sanityCheck) {\n    //input is assumed to be a map from signals to arrays of bigints\n    (this.instance.exports as any).init(\n      this.sanityCheck || sanityCheck ? 1 : 0,\n    );\n    const keys = Object.keys(input);\n    let input_counter = 0;\n    keys.forEach((k) => {\n      const h = fnvHash(k);\n      const hMSB = parseInt(h.slice(0, 8), 16);\n      const hLSB = parseInt(h.slice(8, 16), 16);\n      const fArr = flatArray(input[k]);\n      let signalSize = (this.instance.exports as any).getInputSignalSize(\n        hMSB,\n        hLSB,\n      );\n      if (signalSize < 0) {\n        throw new Error(`Signal ${k} not found\\n`);\n      }\n      if (fArr.length < signalSize) {\n        throw new Error(`Not enough values for input signal ${k}\\n`);\n      }\n      if (fArr.length > signalSize) {\n        throw new Error(`Too many values for input signal ${k}\\n`);\n      }\n      for (let i = 0; i < fArr.length; i++) {\n        const arrFr = toArray32(BigInt(fArr[i]) % this.prime, this.n32);\n        for (let j = 0; j < this.n32; j++) {\n          (this.instance.exports as any).writeSharedRWMemory(\n            j,\n            arrFr[this.n32 - 1 - j],\n          );\n        }\n        try {\n          (this.instance.exports as any).setInputSignal(hMSB, hLSB, i);\n          input_counter++;\n        } catch (err) {\n          // console.log(`After adding signal ${i} of ${k}`)\n          throw new Error(err);\n        }\n      }\n    });\n    if (input_counter < (this.instance.exports as any).getInputSize()) {\n      throw new Error(\n        `Not all inputs have been set. Only ${input_counter} out of ${(\n          this.instance.exports as any\n        ).getInputSize()}`,\n      );\n    }\n  }\n\n  async calculateWitness(input, sanityCheck) {\n    const w: bigint[] = [];\n\n    await this._doCalculateWitness(input, sanityCheck);\n\n    for (let i = 0; i < this.witnessSize; i++) {\n      (this.instance.exports as any).getWitness(i);\n      const arr = new Uint32Array(this.n32);\n      for (let j = 0; j < this.n32; j++) {\n        arr[this.n32 - 1 - j] = (\n          this.instance.exports as any\n        ).readSharedRWMemory(j);\n      }\n      w.push(fromArray32(arr));\n    }\n\n    return w;\n  }\n\n  async calculateBinWitness(input, sanityCheck) {\n    const buff32 = new Uint32Array(this.witnessSize * this.n32);\n    const buff = new Uint8Array(buff32.buffer);\n    await this._doCalculateWitness(input, sanityCheck);\n\n    for (let i = 0; i < this.witnessSize; i++) {\n      (this.instance.exports as any).getWitness(i);\n      const pos = i * this.n32;\n      for (let j = 0; j < this.n32; j++) {\n        buff32[pos + j] = (this.instance.exports as any).readSharedRWMemory(j);\n      }\n    }\n\n    return buff;\n  }\n\n  async calculateWTNSBin(input, sanityCheck) {\n    const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);\n    const buff = new Uint8Array(buff32.buffer);\n    await this._doCalculateWitness(input, sanityCheck);\n\n    //\"wtns\"\n    buff[0] = 'w'.charCodeAt(0);\n    buff[1] = 't'.charCodeAt(0);\n    buff[2] = 'n'.charCodeAt(0);\n    buff[3] = 's'.charCodeAt(0);\n\n    //version 2\n    buff32[1] = 2;\n\n    //number of sections: 2\n    buff32[2] = 2;\n\n    //id section 1\n    buff32[3] = 1;\n\n    const n8 = this.n32 * 4;\n    //id section 1 length in 64bytes\n    const idSection1length = 8 + n8;\n    const idSection1lengthHex = idSection1length.toString(16);\n    buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);\n    buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);\n\n    //this.n32\n    buff32[6] = n8;\n\n    //prime number\n    this.instance.exports.getRawPrime();\n\n    let pos = 7;\n    for (let j = 0; j < this.n32; j++) {\n      buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n    }\n    pos += this.n32;\n\n    // witness size\n    buff32[pos] = this.witnessSize;\n    pos++;\n\n    //id section 2\n    buff32[pos] = 2;\n    pos++;\n\n    // section 2 length\n    const idSection2length = n8 * this.witnessSize;\n    const idSection2lengthHex = idSection2length.toString(16);\n    buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);\n    buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);\n\n    pos += 2;\n    for (let i = 0; i < this.witnessSize; i++) {\n      this.instance.exports.getWitness(i);\n      for (let j = 0; j < this.n32; j++) {\n        buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n      }\n      pos += this.n32;\n    }\n\n    return buff;\n  }\n}\n\nfunction toArray32(rem, size) {\n  const res: number[] = []; //new Uint32Array(size); //has no unshift\n  const radix = BigInt(0x100000000);\n  while (rem) {\n    res.unshift(Number(rem % radix));\n    rem = rem / radix;\n  }\n  if (size) {\n    let i = size - res.length;\n    while (i > 0) {\n      res.unshift(0);\n      i--;\n    }\n  }\n  return res;\n}\n\nfunction fromArray32(arr) {\n  //returns a BigInt\n  let res = BigInt(0);\n  const radix = BigInt(0x100000000);\n  for (let i = 0; i < arr.length; i++) {\n    res = res * radix + BigInt(arr[i]);\n  }\n  return res;\n}\n\nfunction flatArray(a) {\n  let res = [];\n  fillArray(res, a);\n  return res;\n\n  function fillArray(res, a) {\n    if (Array.isArray(a)) {\n      for (let i = 0; i < a.length; i++) {\n        fillArray(res, a[i]);\n      }\n    } else {\n      res.push(a);\n    }\n  }\n}\n\nfunction fnvHash(str) {\n  const uint64_max = BigInt(2) ** BigInt(64);\n  let hash = BigInt('0xCBF29CE484222325');\n  for (let i = 0; i < str.length; i++) {\n    hash ^= BigInt(str[i].charCodeAt());\n    hash *= BigInt(0x100000001b3);\n    hash %= uint64_max;\n  }\n  let shash = hash.toString(16);\n  let n = 16 - shash.length;\n  shash = '0'.repeat(n).concat(shash);\n  return shash;\n}\n", "\n\nexport * as groth16 from \"./src/groth16.js\";\nexport * as powersOfTau from \"./src/powersoftau.js\";\nexport * as r1cs from \"./src/r1cs.js\";\nexport * as wtns from \"./src/wtns.js\";\nexport * as zKey from \"./src/zkey.js\";\nexport * as plonk from \"./src/plonk.js\";\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport {default as fullProve} from \"./groth16_fullprove.js\";\nexport {default as prove} from \"./groth16_prove.js\";\nexport {default as verify} from \"./groth16_verify.js\";\nexport {default as exportSolidityCallData} from \"./groth16_exportsoliditycalldata.js\";\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport groth16_prove from \"./groth16_prove.js\";\nimport wtns_calculate from \"./wtns_calculate.js\";\nimport {utils} from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\nexport default async function groth16FullProve(_input, wasmFile, zkeyFileName, logger) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await wtns_calculate(input, wasmFile, wtns);\n    return await groth16_prove(zkeyFileName, wtns, logger);\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport { log2 } from \"./misc.js\";\nimport { Scalar, utils, BigBuffer } from \"ffjavascript\";\nconst {stringifyBigInts} = utils;\n\nexport default async function groth16Prove(zkeyFileName, witnessFileName, logger) {\n    const {fd: fdWtns, sections: sectionsWtns} = await binFileUtils.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    const wtns = await wtnsUtils.readHeader(fdWtns, sectionsWtns);\n\n    const {fd: fdZKey, sections: sectionsZKey} = await binFileUtils.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await zkeyUtils.readHeader(fdZKey, sectionsZKey);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    if (!Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);\n    }\n\n    const curve = zkey.curve;\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    const power = log2(zkey.domainSize);\n\n    if (logger) logger.debug(\"Reading Wtns\");\n    const buffWitness = await binFileUtils.readSection(fdWtns, sectionsWtns, 2);\n    if (logger) logger.debug(\"Reading Coeffs\");\n    const buffCoeffs = await binFileUtils.readSection(fdZKey, sectionsZKey, 4);\n\n    if (logger) logger.debug(\"Building ABC\");\n    const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve, zkey, buffWitness, buffCoeffs, logger);\n\n    const inc = power == Fr.s ? curve.Fr.shift : curve.Fr.w[power+1];\n\n    const buffA = await Fr.ifft(buffA_T, \"\", \"\", logger, \"IFFT_A\");\n    const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);\n    const buffAodd_T = await Fr.fft(buffAodd, \"\", \"\", logger, \"FFT_A\");\n\n    const buffB = await Fr.ifft(buffB_T, \"\", \"\", logger, \"IFFT_B\");\n    const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);\n    const buffBodd_T = await Fr.fft(buffBodd, \"\", \"\", logger, \"FFT_B\");\n\n    const buffC = await Fr.ifft(buffC_T, \"\", \"\", logger, \"IFFT_C\");\n    const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);\n    const buffCodd_T = await Fr.fft(buffCodd, \"\", \"\", logger, \"FFT_C\");\n\n    if (logger) logger.debug(\"Join ABC\");\n    const buffPodd_T = await joinABC(curve, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);\n\n    let proof = {};\n\n    if (logger) logger.debug(\"Reading A Points\");\n    const buffBasesA = await binFileUtils.readSection(fdZKey, sectionsZKey, 5);\n    proof.pi_a = await curve.G1.multiExpAffine(buffBasesA, buffWitness, logger, \"multiexp A\");\n\n    if (logger) logger.debug(\"Reading B1 Points\");\n    const buffBasesB1 = await binFileUtils.readSection(fdZKey, sectionsZKey, 6);\n    let pib1 = await curve.G1.multiExpAffine(buffBasesB1, buffWitness, logger, \"multiexp B1\");\n\n    if (logger) logger.debug(\"Reading B2 Points\");\n    const buffBasesB2 = await binFileUtils.readSection(fdZKey, sectionsZKey, 7);\n    proof.pi_b = await curve.G2.multiExpAffine(buffBasesB2, buffWitness, logger, \"multiexp B2\");\n\n    if (logger) logger.debug(\"Reading C Points\");\n    const buffBasesC = await binFileUtils.readSection(fdZKey, sectionsZKey, 8);\n    proof.pi_c = await curve.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic+1)*curve.Fr.n8), logger, \"multiexp C\");\n\n    if (logger) logger.debug(\"Reading H Points\");\n    const buffBasesH = await binFileUtils.readSection(fdZKey, sectionsZKey, 9);\n    const resH = await curve.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, \"multiexp H\");\n\n    const r = curve.Fr.random();\n    const s = curve.Fr.random();\n\n    proof.pi_a  = G1.add( proof.pi_a, zkey.vk_alpha_1 );\n    proof.pi_a  = G1.add( proof.pi_a, G1.timesFr( zkey.vk_delta_1, r ));\n\n    proof.pi_b  = G2.add( proof.pi_b, zkey.vk_beta_2 );\n    proof.pi_b  = G2.add( proof.pi_b, G2.timesFr( zkey.vk_delta_2, s ));\n\n    pib1 = G1.add( pib1, zkey.vk_beta_1 );\n    pib1 = G1.add( pib1, G1.timesFr( zkey.vk_delta_1, s ));\n\n    proof.pi_c = G1.add(proof.pi_c, resH);\n\n\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( proof.pi_a, s ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( pib1, r ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( zkey.vk_delta_1, Fr.neg(Fr.mul(r,s) )));\n\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const b = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(Scalar.fromRprLE(b));\n    }\n\n    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));\n    proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));\n    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));\n\n    proof.protocol = \"groth16\";\n    proof.curve = curve.name;\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    proof = stringifyBigInts(proof);\n    publicSignals = stringifyBigInts(publicSignals);\n\n    return {proof, publicSignals};\n}\n\n\nasync function buildABC1(curve, zkey, witness, coeffs, logger) {\n    const n8 = curve.Fr.n8;\n    const sCoef = 4*3 + zkey.n8r;\n    const nCoef = (coeffs.byteLength-4) / sCoef;\n\n    const outBuffA = new BigBuffer(zkey.domainSize * n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * n8);\n\n    const outBuf = [ outBuffA, outBuffB ];\n    for (let i=0; i<nCoef; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP AB: ${i}/${nCoef}`);\n        const buffCoef = coeffs.slice(4+i*sCoef, 4+i*sCoef+sCoef);\n        const buffCoefV = new DataView(buffCoef.buffer);\n        const m= buffCoefV.getUint32(0, true);\n        const c= buffCoefV.getUint32(4, true);\n        const s= buffCoefV.getUint32(8, true);\n        const coef = buffCoef.slice(12, 12+n8);\n        outBuf[m].set(\n            curve.Fr.add(\n                outBuf[m].slice(c*n8, c*n8+n8),\n                curve.Fr.mul(coef, witness.slice(s*n8, s*n8+n8))\n            ),\n            c*n8\n        );\n    }\n\n    for (let i=0; i<zkey.domainSize; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP C: ${i}/${zkey.domainSize}`);\n        outBuffC.set(\n            curve.Fr.mul(\n                outBuffA.slice(i*n8, i*n8+n8),\n                outBuffB.slice(i*n8, i*n8+n8),\n            ),\n            i*n8\n        );\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n}\n\n/*\nasync function buldABC(curve, zkey, witness, coeffs, logger) {\n    const concurrency = curve.tm.concurrency;\n    const sCoef = 4*3 + zkey.n8r;\n\n    let getUint32;\n\n    if (coeffs instanceof BigBuffer) {\n        const coeffsDV = [];\n        const PAGE_LEN = coeffs.buffers[0].length;\n        for (let i=0; i< coeffs.buffers.length; i++) {\n            coeffsDV.push(new DataView(coeffs.buffers[i].buffer));\n        }\n        getUint32 = function (pos) {\n            return coeffsDV[Math.floor(pos/PAGE_LEN)].getUint32(pos % PAGE_LEN, true);\n        };\n    } else {\n        const coeffsDV = new DataView(coeffs.buffer, coeffs.byteOffset, coeffs.byteLength);\n        getUint32 = function (pos) {\n            return coeffsDV.getUint32(pos, true);\n        };\n    }\n\n    const elementsPerChunk = Math.floor(zkey.domainSize/concurrency);\n    const promises = [];\n\n    const cutPoints = [];\n    for (let i=0; i<concurrency; i++) {\n        cutPoints.push( getCutPoint( Math.floor(i*elementsPerChunk) ));\n    }\n    cutPoints.push(coeffs.byteLength);\n\n    const chunkSize = 2**26;\n    for (let s=0 ; s<zkey.nVars ; s+= chunkSize) {\n        if (logger) logger.debug(`QAP ${s}: ${s}/${zkey.nVars}`);\n        const ns= Math.min(zkey.nVars-s, chunkSize );\n\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = elementsPerChunk;\n            } else {\n                n = zkey.domainSize - i*elementsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: coeffs.slice(cutPoints[i], cutPoints[i+1])});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: witness.slice(s*curve.Fr.n8, (s+ns)*curve.Fr.n8)});\n            task.push({cmd: \"ALLOC\", var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 4, len: n*curve.Fr.n8});\n            task.push({cmd: \"CALL\", fnName: \"qap_buildABC\", params:[\n                {var: 0},\n                {val: (cutPoints[i+1] - cutPoints[i])/sCoef},\n                {var: 1},\n                {var: 2},\n                {var: 3},\n                {var: 4},\n                {val: i*elementsPerChunk},\n                {val: n},\n                {val: s},\n                {val: ns}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 1, var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 2, var: 4, len: n*curve.Fr.n8});\n            promises.push(curve.tm.queueAction(task));\n        }\n    }\n\n    let result = await Promise.all(promises);\n\n    const nGroups = result.length / concurrency;\n    if (nGroups>1) {\n        const promises2 = [];\n        for (let i=0; i<concurrency; i++) {\n            const task=[];\n            task.push({cmd: \"ALLOC\", var: 0, len: result[i][0].byteLength});\n            task.push({cmd: \"ALLOC\", var: 1, len: result[i][0].byteLength});\n            for (let m=0; m<3; m++) {\n                task.push({cmd: \"SET\", var: 0, buff: result[i][m]});\n                for (let s=1; s<nGroups; s++) {\n                    task.push({cmd: \"SET\", var: 1, buff: result[s*concurrency + i][m]});\n                    task.push({cmd: \"CALL\", fnName: \"qap_batchAdd\", params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: result[i][m].length/curve.Fr.n8},\n                        {var: 0}\n                    ]});\n                }\n                task.push({cmd: \"GET\", out: m, var: 0, len: result[i][m].length});\n            }\n            promises2.push(curve.tm.queueAction(task));\n        }\n        result = await Promise.all(promises2);\n    }\n\n    const outBuffA = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuffA.set(result[i][0], p);\n        outBuffB.set(result[i][1], p);\n        outBuffC.set(result[i][2], p);\n        p += result[i][0].byteLength;\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n    function getCutPoint(v) {\n        let m = 0;\n        let n = getUint32(0);\n        while (m < n) {\n            var k = Math.floor((n + m) / 2);\n            const va = getUint32(4 + k*sCoef + 4);\n            if (va > v) {\n                n = k - 1;\n            } else if (va < v) {\n                m = k + 1;\n            } else {\n                n = k;\n            }\n        }\n        return 4 + m*sCoef;\n    }\n}\n*/\n\nasync function joinABC(curve, zkey, a, b, c, logger) {\n    const MAX_CHUNK_SIZE = 1 << 22;\n\n    const n8 = curve.Fr.n8;\n    const nElements = Math.floor(a.byteLength / curve.Fr.n8);\n\n    const promises = [];\n\n    for (let i=0; i<nElements; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`JoinABC: ${i}/${nElements}`);\n        const n= Math.min(nElements - i, MAX_CHUNK_SIZE);\n\n        const task = [];\n\n        const aChunk = a.slice(i*n8, (i + n)*n8 );\n        const bChunk = b.slice(i*n8, (i + n)*n8 );\n        const cChunk = c.slice(i*n8, (i + n)*n8 );\n\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: aChunk});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: bChunk});\n        task.push({cmd: \"ALLOCSET\", var: 2, buff: cChunk});\n        task.push({cmd: \"ALLOC\", var: 3, len: n*n8});\n        task.push({cmd: \"CALL\", fnName: \"qap_joinABC\", params:[\n            {var: 0},\n            {var: 1},\n            {var: 2},\n            {val: n},\n            {var: 3},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"frm_batchFromMontgomery\", params:[\n            {var: 3},\n            {val: n},\n            {var: 3}\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 3, len: n*n8});\n        promises.push(curve.tm.queueAction(task));\n    }\n\n    const result = await Promise.all(promises);\n\n    let outBuff;\n    if (a instanceof BigBuffer) {\n        outBuff = new BigBuffer(a.byteLength);\n    } else {\n        outBuff = new Uint8Array(a.byteLength);\n    }\n\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuff.set(result[i][0], p);\n        p += result[i][0].byteLength;\n    }\n\n    return outBuff;\n}\n\n", "\nimport  { Scalar, BigBuffer } from \"ffjavascript\";\nimport * as fastFile from \"fastfile\";\n\nexport async function readBinFile(fileName, type, maxVersion, cacheSize, pageSize) {\n\n    const fd = await fastFile.readExisting(fileName, cacheSize, pageSize);\n\n    const b = await fd.read(4);\n    let readedType = \"\";\n    for (let i=0; i<4; i++) readedType += String.fromCharCode(b[i]);\n\n    if (readedType != type) throw new Error(fileName + \": Invalid File format\");\n\n    let v = await fd.readULE32();\n\n    if (v>maxVersion) throw new Error(\"Version not supported\");\n\n    const nSections = await fd.readULE32();\n\n    // Scan sections\n    let sections = [];\n    for (let i=0; i<nSections; i++) {\n        let ht = await fd.readULE32();\n        let hl = await fd.readULE64();\n        if (typeof sections[ht] == \"undefined\") sections[ht] = [];\n        sections[ht].push({\n            p: fd.pos,\n            size: hl\n        });\n        fd.pos += hl;\n    }\n\n    return {fd, sections};\n}\n\nexport async function createBinFile(fileName, type, version, nSections, cacheSize, pageSize) {\n\n    const fd = await fastFile.createOverride(fileName, cacheSize, pageSize);\n\n    const buff = new Uint8Array(4);\n    for (let i=0; i<4; i++) buff[i] = type.charCodeAt(i);\n    await fd.write(buff, 0); // Magic \"r1cs\"\n\n    await fd.writeULE32(version); // Version\n    await fd.writeULE32(nSections); // Number of Sections\n\n    return fd;\n}\n\nexport async function startWriteSection(fd, idSection) {\n    if (typeof fd.writingSection !== \"undefined\") throw new Error(\"Already writing a section\");\n    await fd.writeULE32(idSection); // Header type\n    fd.writingSection = {\n        pSectionSize: fd.pos\n    };\n    await fd.writeULE64(0); // Temporally set to 0 length\n}\n\nexport async function endWriteSection(fd) {\n    if (typeof fd.writingSection === \"undefined\") throw new Error(\"Not writing a section\");\n\n    const sectionSize = fd.pos - fd.writingSection.pSectionSize - 8;\n    const oldPos = fd.pos;\n    fd.pos = fd.writingSection.pSectionSize;\n    await fd.writeULE64(sectionSize);\n    fd.pos = oldPos;\n    delete fd.writingSection;\n}\n\nexport async function startReadUniqueSection(fd, sections, idSection) {\n    if (typeof fd.readingSection !== \"undefined\") throw new Error(\"Already reading a section\");\n    if (!sections[idSection])  throw new Error(fd.fileName + \": Missing section \"+ idSection );\n    if (sections[idSection].length>1) throw new Error(fd.fileName +\": Section Duplicated \" +idSection);\n\n    fd.pos = sections[idSection][0].p;\n\n    fd.readingSection = sections[idSection][0];\n}\n\nexport async function endReadSection(fd, noCheck) {\n    if (typeof fd.readingSection === \"undefined\") throw new Error(\"Not reading a section\");\n    if (!noCheck) {\n        if (fd.pos-fd.readingSection.p !=  fd.readingSection.size) throw new Error(\"Invalid section size reading\");\n    }\n    delete fd.readingSection;\n}\n\nexport async function writeBigInt(fd, n, n8, pos) {\n    const buff = new Uint8Array(n8);\n    Scalar.toRprLE(buff, 0, n, n8);\n    await fd.write(buff, pos);\n}\n\nexport async function readBigInt(fd, n8, pos) {\n    const buff = await fd.read(n8, pos);\n    return Scalar.fromRprLE(buff, 0, n8);\n}\n\nexport async function copySection(fdFrom, sections, fdTo, sectionId, size) {\n    if (typeof size === \"undefined\") {\n        size = sections[sectionId][0].size;\n    }\n    const chunkSize = fdFrom.pageSize;\n    await startReadUniqueSection(fdFrom, sections, sectionId);\n    await startWriteSection(fdTo, sectionId);\n    for (let p=0; p<size; p+=chunkSize) {\n        const l = Math.min(size -p, chunkSize);\n        const buff = await fdFrom.read(l);\n        await fdTo.write(buff);\n    }\n    await endWriteSection(fdTo);\n    await endReadSection(fdFrom, size != sections[sectionId][0].size);\n\n}\n\nexport async function readSection(fd, sections, idSection, offset, length) {\n\n    offset = (typeof offset === \"undefined\") ? 0 : offset;\n    length = (typeof length === \"undefined\") ? sections[idSection][0].size - offset : length;\n\n    if (offset + length > sections[idSection][0].size) {\n        throw new Error(\"Reading out of the range of the section\");\n    }\n\n    let buff;\n    if (length < (1 << 30) ) {\n        buff = new Uint8Array(length);\n    } else {\n        buff = new BigBuffer(length);\n    }\n\n    await fd.readToBuffer(buff, 0, length, sections[idSection][0].p + offset);\n    return buff;\n}\n\nexport async function sectionIsEqual(fd1, sections1, fd2, sections2, idSection) {\n    const MAX_BUFF_SIZE = fd1.pageSize * 16;\n    await startReadUniqueSection(fd1, sections1, idSection);\n    await startReadUniqueSection(fd2, sections2, idSection);\n    if (sections1[idSection][0].size != sections2[idSection][0].size) return false;\n    const totalBytes=sections1[idSection][0].size;\n    for (let i=0; i<totalBytes; i+= MAX_BUFF_SIZE) {\n        const n = Math.min(totalBytes-i, MAX_BUFF_SIZE);\n        const buff1 = await fd1.read(n);\n        const buff2 = await fd2.read(n);\n        for (let j=0; j<n; j++) if (buff1[j] != buff2[j]) return false;\n    }\n    await endReadSection(fd1);\n    await endReadSection(fd2);\n    return true;\n}\n", "/* global fetch */\nimport { open } from \"./osfile.js\";\nimport * as memFile from \"./memfile.js\";\nimport * as bigMemFile from \"./bigmemfile.js\";\nimport { O_TRUNC, O_CREAT, O_RDWR, O_EXCL, O_RDONLY } from \"constants\";\n\nconst DEFAULT_CACHE_SIZE = (1 << 16);\nconst DEFAULT_PAGE_SIZE = (1 << 13);\n\n\nexport async function createOverride(o, b, c) {\n    if (typeof o === \"string\") {\n        o = {\n            type: \"file\",\n            fileName: o,\n            cacheSize: b || DEFAULT_CACHE_SIZE,\n            pageSize: c || DEFAULT_PAGE_SIZE\n        };\n    }\n    if (o.type == \"file\") {\n        return await open(o.fileName, O_TRUNC | O_CREAT | O_RDWR, o.cacheSize, o.pageSize);\n    } else if (o.type == \"mem\") {\n        return memFile.createNew(o);\n    } else if (o.type == \"bigMem\") {\n        return bigMemFile.createNew(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n\nexport function createNoOverride(o, b, c) {\n    if (typeof o === \"string\") {\n        o = {\n            type: \"file\",\n            fileName: o,\n            cacheSize: b || DEFAULT_CACHE_SIZE,\n            pageSize: c || DEFAULT_PAGE_SIZE\n        };\n    }\n    if (o.type == \"file\") {\n        return open(o.fileName, O_TRUNC | O_CREAT | O_RDWR | O_EXCL, o.cacheSize, o.pageSize);\n    } else if (o.type == \"mem\") {\n        return memFile.createNew(o);\n    } else if (o.type == \"bigMem\") {\n        return bigMemFile.createNew(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n\nexport async function readExisting(o, b, c) {\n    if (o instanceof Uint8Array) {\n        o = {\n            type: \"mem\",\n            data: o\n        };\n    }\n    if (process.browser) {\n        if (typeof o === \"string\") {\n            const buff = await fetch(o).then( function(res) {\n                return res.arrayBuffer();\n            }).then(function (ab) {\n                return new Uint8Array(ab);\n            });\n            o = {\n                type: \"mem\",\n                data: buff\n            };\n        }\n    } else {\n        if (typeof o === \"string\") {\n            o = {\n                type: \"file\",\n                fileName: o,\n                cacheSize: b || DEFAULT_CACHE_SIZE,\n                pageSize: c || DEFAULT_PAGE_SIZE\n            };\n        }\n    }\n    if (o.type == \"file\") {\n        return await open(o.fileName, O_RDONLY, o.cacheSize, o.pageSize);\n    } else if (o.type == \"mem\") {\n        return await memFile.readExisting(o);\n    } else if (o.type == \"bigMem\") {\n        return await bigMemFile.readExisting(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n\nexport function readWriteExisting(o, b, c) {\n    if (typeof o === \"string\") {\n        o = {\n            type: \"file\",\n            fileName: o,\n            cacheSize: b || DEFAULT_CACHE_SIZE,\n            pageSize: c || DEFAULT_PAGE_SIZE\n        };\n    }\n    if (o.type == \"file\") {\n        return open(o.fileName, O_CREAT | O_RDWR, o.cacheSize, o.pageSize);\n    } else if (o.type == \"mem\") {\n        return memFile.readWriteExisting(o);\n    } else if (o.type == \"bigMem\") {\n        return bigMemFile.readWriteExisting(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n\nexport function readWriteExistingOrCreate(o, b, c) {\n    if (typeof o === \"string\") {\n        o = {\n            type: \"file\",\n            fileName: o,\n            cacheSize: b || DEFAULT_CACHE_SIZE,\n            pageSize: c || DEFAULT_PAGE_SIZE\n        };\n    }\n    if (o.type == \"file\") {\n        return open(o.fileName, O_CREAT | O_RDWR | O_EXCL, o.cacheSize);\n    } else if (o.type == \"mem\") {\n        return memFile.readWriteExisting(o);\n    } else if (o.type == \"bigMem\") {\n        return bigMemFile.readWriteExisting(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n", "\nimport fs from\"fs\";\n\nexport async function open(fileName, openFlags, cacheSize, pageSize) {\n    cacheSize = cacheSize || 4096*64;\n    if (typeof openFlags !== \"number\" && [\"w+\", \"wx+\", \"r\", \"ax+\", \"a+\"].indexOf(openFlags) <0)\n        throw new Error(\"Invalid open option\");\n    const fd =await fs.promises.open(fileName, openFlags);\n\n    const stats = await fd.stat();\n\n    return  new FastFile(fd, stats, cacheSize, pageSize, fileName);\n}\n\n\nclass FastFile {\n\n    constructor(fd, stats, cacheSize, pageSize, fileName) {\n        this.fileName = fileName;\n        this.fd = fd;\n        this.pos = 0;\n        this.pageSize = pageSize || (1 << 8);\n        while (this.pageSize < stats.blksize) {\n            this.pageSize *= 2;\n        }\n        this.totalSize = stats.size;\n        this.totalPages = Math.floor((stats.size -1) / this.pageSize)+1;\n        this.maxPagesLoaded = Math.floor( cacheSize / this.pageSize)+1;\n        this.pages = {};\n        this.pendingLoads = [];\n        this.writing = false;\n        this.reading = false;\n        this.avBuffs = [];\n        this.history = {};\n    }\n\n    _loadPage(p) {\n        const self = this;\n        const P = new Promise((resolve, reject)=> {\n            self.pendingLoads.push({\n                page: p,\n                resolve: resolve,\n                reject: reject\n            });\n        });\n        self.__statusPage(\"After Load request: \", p);\n        return P;\n    }\n\n    __statusPage(s, p) {\n        const logEntry = [];\n        const self=this;\n        if (!self.logHistory) return;\n        logEntry.push(\"==\" + s+ \" \" +p);\n        let S = \"\";\n        for (let i=0; i<self.pendingLoads.length; i++) {\n            if (self.pendingLoads[i].page == p) S = S + \" \" + i;\n        }\n        if (S) logEntry.push(\"Pending loads:\"+S);\n        if (typeof self.pages[p] != \"undefined\") {\n            const page = self.pages[p];\n            logEntry.push(\"Loaded\");\n            logEntry.push(\"pendingOps: \"+page.pendingOps);\n            if (page.loading) logEntry.push(\"loading: \"+page.loading);\n            if (page.writing) logEntry.push(\"writing\");\n            if (page.dirty) logEntry.push(\"dirty\");\n        }\n        logEntry.push(\"==\");\n\n        if (!self.history[p]) self.history[p] = [];\n        self.history[p].push(logEntry);\n    }\n\n    __printHistory(p) {\n        const self = this;\n        if (!self.history[p]) console.log(\"Empty History \", p);\n        console.log(\"History \"+p);\n        for (let i=0; i<self.history[p].length; i++) {\n            for (let j=0; j<self.history[p][i].length; j++) {\n                console.log(\"-> \" + self.history[p][i][j]);\n            }\n        }\n    }\n\n\n\n    _triggerLoad() {\n        const self = this;\n\n        if (self.reading) return;\n        if (self.pendingLoads.length==0) return;\n\n        const pageIdxs = Object.keys(self.pages);\n\n        const deletablePages = [];\n        for (let i=0; i<pageIdxs.length; i++) {\n            const page = self.pages[parseInt(pageIdxs[i])];\n            if ((page.dirty == false)&&(page.pendingOps==0)&&(!page.writing)&&(!page.loading)) deletablePages.push(parseInt(pageIdxs[i]));\n        }\n\n        let freePages = self.maxPagesLoaded - pageIdxs.length;\n\n        const ops = [];\n\n        // while pending loads and\n        //     the page is loaded or I can recover one.\n        while (\n            (self.pendingLoads.length>0) &&\n            (   (typeof self.pages[self.pendingLoads[0].page] != \"undefined\" )\n              ||(  (freePages>0)\n                 ||(deletablePages.length>0)))) {\n            const load = self.pendingLoads.shift();\n            if (typeof self.pages[load.page] != \"undefined\") {\n                self.pages[load.page].pendingOps ++;\n                const idx = deletablePages.indexOf(load.page);\n                if (idx>=0) deletablePages.splice(idx, 1);\n                if (self.pages[load.page].loading) {\n                    self.pages[load.page].loading.push(load);\n                } else {\n                    load.resolve();\n                }\n                self.__statusPage(\"After Load (cached): \", load.page);\n\n            } else {\n                if (freePages) {\n                    freePages--;\n                } else {\n                    const fp = deletablePages.shift();\n                    self.__statusPage(\"Before Unload: \", fp);\n                    self.avBuffs.unshift(self.pages[fp]);\n                    delete self.pages[fp];\n                    self.__statusPage(\"After Unload: \", fp);\n                }\n\n                if (load.page>=self.totalPages) {\n                    self.pages[load.page] = getNewPage();\n                    load.resolve();\n                    self.__statusPage(\"After Load (new): \", load.page);\n                } else {\n                    self.reading = true;\n                    self.pages[load.page] = getNewPage();\n                    self.pages[load.page].loading = [load];\n                    ops.push(self.fd.read(self.pages[load.page].buff, 0, self.pageSize, load.page*self.pageSize).then((res)=> {\n                        self.pages[load.page].size = res.bytesRead;\n                        const loading = self.pages[load.page].loading;\n                        delete self.pages[load.page].loading;\n                        for (let i=0; i<loading.length; i++) {\n                            loading[i].resolve();\n                        }\n                        self.__statusPage(\"After Load (loaded): \", load.page);\n                        return res;\n                    }, (err) => {\n                        load.reject(err);\n                    }));\n                    self.__statusPage(\"After Load (loading): \", load.page);\n                }\n            }\n        }\n        // if (ops.length>1) console.log(ops.length);\n\n        Promise.all(ops).then( () => {\n            self.reading = false;\n            if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));\n            self._tryClose();\n        });\n\n        function getNewPage() {\n            if (self.avBuffs.length>0) {\n                const p = self.avBuffs.shift();\n                p.dirty = false;\n                p.pendingOps = 1;\n                p.size =0;\n                return p;\n            } else {\n                return {\n                    dirty: false,\n                    buff: new Uint8Array(self.pageSize),\n                    pendingOps: 1,\n                    size: 0\n                };\n            }\n        }\n\n    }\n\n\n    _triggerWrite() {\n        const self = this;\n        if (self.writing) return;\n\n        const pageIdxs = Object.keys(self.pages);\n\n        const ops = [];\n\n        for (let i=0; i<pageIdxs.length; i++) {\n            const page = self.pages[parseInt(pageIdxs[i])];\n            if (page.dirty) {\n                page.dirty = false;\n                page.writing = true;\n                self.writing = true;\n                ops.push( self.fd.write(page.buff, 0, page.size, parseInt(pageIdxs[i])*self.pageSize).then(() => {\n                    page.writing = false;\n                    return;\n                }, (err) => {\n                    console.log(\"ERROR Writing: \"+err);\n                    self.error = err;\n                    self._tryClose();\n                }));\n            }\n        }\n\n        if (self.writing) {\n            Promise.all(ops).then( () => {\n                self.writing = false;\n                setImmediate(self._triggerWrite.bind(self));\n                self._tryClose();\n                if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));\n            });\n        }\n    }\n\n    _getDirtyPage() {\n        for (let p in this.pages) {\n            if (this.pages[p].dirty) return p;\n        }\n        return -1;\n    }\n\n    async write(buff, pos) {\n        if (buff.byteLength == 0) return;\n        const self = this;\n/*\n        if (buff.byteLength > self.pageSize*self.maxPagesLoaded*0.8) {\n            const cacheSize = Math.floor(buff.byteLength * 1.1);\n            this.maxPagesLoaded = Math.floor( cacheSize / self.pageSize)+1;\n        }\n*/\n        if (typeof pos == \"undefined\") pos = self.pos;\n        self.pos = pos+buff.byteLength;\n        if (self.totalSize < pos + buff.byteLength) self.totalSize = pos + buff.byteLength;\n        if (self.pendingClose)\n            throw new Error(\"Writing a closing file\");\n        const firstPage = Math.floor(pos / self.pageSize);\n        const lastPage = Math.floor((pos + buff.byteLength -1) / self.pageSize);\n\n        const pagePromises = [];\n        for (let i=firstPage; i<=lastPage; i++) pagePromises.push(self._loadPage(i));\n        self._triggerLoad();\n\n        let p = firstPage;\n        let o = pos % self.pageSize;\n        let r = buff.byteLength;\n        while (r>0) {\n            await pagePromises[p-firstPage];\n            const l = (o+r > self.pageSize) ? (self.pageSize -o) : r;\n            const srcView = buff.slice( buff.byteLength - r, buff.byteLength - r + l);\n            const dstView = new Uint8Array(self.pages[p].buff.buffer, o, l);\n            dstView.set(srcView);\n            self.pages[p].dirty = true;\n            self.pages[p].pendingOps --;\n            self.pages[p].size = Math.max(o+l, self.pages[p].size);\n            if (p>=self.totalPages) {\n                self.totalPages = p+1;\n            }\n            r = r-l;\n            p ++;\n            o = 0;\n            if (!self.writing) setImmediate(self._triggerWrite.bind(self));\n        }\n    }\n\n    async read(len, pos) {\n        const self = this;\n        let buff = new Uint8Array(len);\n        await self.readToBuffer(buff, 0, len, pos);\n\n        return buff;\n    }\n\n    async readToBuffer(buffDst, offset, len, pos) {\n        if (len == 0) {\n            return;\n        }\n        const self = this;\n        if (len > self.pageSize*self.maxPagesLoaded*0.8) {\n            const cacheSize = Math.floor(len * 1.1);\n            this.maxPagesLoaded = Math.floor( cacheSize / self.pageSize)+1;\n        }\n        if (typeof pos == \"undefined\") pos = self.pos;\n        self.pos = pos+len;\n        if (self.pendingClose)\n            throw new Error(\"Reading a closing file\");\n        const firstPage = Math.floor(pos / self.pageSize);\n        const lastPage = Math.floor((pos + len -1) / self.pageSize);\n\n        const pagePromises = [];\n        for (let i=firstPage; i<=lastPage; i++) pagePromises.push(self._loadPage(i));\n\n        self._triggerLoad();\n\n        let p = firstPage;\n        let o = pos % self.pageSize;\n        // Remaining bytes to read\n        let r = pos + len > self.totalSize ? len - (pos + len - self.totalSize): len;\n        while (r>0) {\n            await pagePromises[p - firstPage];\n            self.__statusPage(\"After Await (read): \", p);\n\n            // bytes to copy from this page\n            const l = (o+r > self.pageSize) ? (self.pageSize -o) : r;\n            const srcView = new Uint8Array(self.pages[p].buff.buffer, self.pages[p].buff.byteOffset + o, l);\n            buffDst.set(srcView, offset+len-r);\n            self.pages[p].pendingOps --;\n\n            self.__statusPage(\"After Op done: \", p);\n\n            r = r-l;\n            p ++;\n            o = 0;\n            if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));\n        }\n\n        this.pos = pos + len;\n\n    }\n\n\n    _tryClose() {\n        const self = this;\n        if (!self.pendingClose) return;\n        if (self.error) {\n            self.pendingCloseReject(self.error);\n        }\n        const p = self._getDirtyPage();\n        if ((p>=0) || (self.writing) || (self.reading) || (self.pendingLoads.length>0)) return;\n        self.pendingClose();\n    }\n\n    close() {\n        const self = this;\n        if (self.pendingClose)\n            throw new Error(\"Closing the file twice\");\n        return new Promise((resolve, reject) => {\n            self.pendingClose = resolve;\n            self.pendingCloseReject = reject;\n            self._tryClose();\n        }).then(()=> {\n            self.fd.close();\n        }, (err) => {\n            self.fd.close();\n            throw (err);\n        });\n    }\n\n    async discard() {\n        const self = this;\n        await self.close();\n        await fs.promises.unlink(this.fileName);\n    }\n\n    async writeULE32(v, pos) {\n        const self = this;\n        const tmpBuff32 = new Uint8Array(4);\n        const tmpBuff32v = new DataView(tmpBuff32.buffer);\n\n        tmpBuff32v.setUint32(0, v, true);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n    async writeUBE32(v, pos) {\n        const self = this;\n\n        const tmpBuff32 = new Uint8Array(4);\n        const tmpBuff32v = new DataView(tmpBuff32.buffer);\n\n        tmpBuff32v.setUint32(0, v, false);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n\n    async writeULE64(v, pos) {\n        const self = this;\n\n        const tmpBuff64 = new Uint8Array(8);\n        const tmpBuff64v = new DataView(tmpBuff64.buffer);\n\n        tmpBuff64v.setUint32(0, v & 0xFFFFFFFF, true);\n        tmpBuff64v.setUint32(4, Math.floor(v / 0x100000000) , true);\n\n        await self.write(tmpBuff64, pos);\n    }\n\n    async readULE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[0];\n    }\n\n    async readUBE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new DataView(b.buffer);\n\n        return view.getUint32(0, false);\n    }\n\n    async readULE64(pos) {\n        const self = this;\n        const b = await self.read(8, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[1] * 0x100000000 + view[0];\n    }\n\n    async readString(pos) {\n        const self = this;\n\n        if (self.pendingClose) {\n            throw new Error(\"Reading a closing file\");\n        }\n\n        let currentPosition = typeof pos == \"undefined\" ? self.pos : pos;\n        let currentPage = Math.floor(currentPosition / self.pageSize);\n\n        let endOfStringFound = false;\n        let str = \"\";\n\n        while (!endOfStringFound) {\n            //Read page\n            let pagePromise = self._loadPage(currentPage);\n            self._triggerLoad();\n            await pagePromise;\n            self.__statusPage(\"After Await (read): \", currentPage);\n\n            let offsetOnPage = currentPosition % self.pageSize;\n\n            const dataArray = new Uint8Array(\n                self.pages[currentPage].buff.buffer,\n                self.pages[currentPage].buff.byteOffset + offsetOnPage,\n                self.pageSize - offsetOnPage\n            );\n\n            let indexEndOfString = dataArray.findIndex(element => element === 0);\n            endOfStringFound = indexEndOfString !== -1;\n\n            if (endOfStringFound) {\n                str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));\n                self.pos = currentPage * this.pageSize + offsetOnPage + indexEndOfString + 1;\n            } else {\n                str += new TextDecoder().decode(dataArray);\n                self.pos = currentPage * this.pageSize + offsetOnPage + dataArray.length;\n            }\n\n            self.pages[currentPage].pendingOps--;\n            self.__statusPage(\"After Op done: \", currentPage);\n\n            currentPosition = self.pos;\n            currentPage++;\n\n            if (self.pendingLoads.length > 0) setImmediate(self._triggerLoad.bind(self));\n        }\n\n        return str;\n    }\n}\n", "export function createNew(o) {\n    const initialSize = o.initialSize || 1<<20;\n    const fd = new MemFile();\n    fd.o = o;\n    fd.o.data = new Uint8Array(initialSize);\n    fd.allocSize = initialSize;\n    fd.totalSize = 0;\n    fd.readOnly = false;\n    fd.pos = 0;\n    return fd;\n}\n\nexport function readExisting(o) {\n    const fd = new MemFile();\n    fd.o = o;\n    fd.allocSize = o.data.byteLength;\n    fd.totalSize = o.data.byteLength;\n    fd.readOnly = true;\n    fd.pos = 0;\n    return fd;\n}\n\nexport function readWriteExisting(o) {\n    const fd = new MemFile();\n    fd.o = o;\n    fd.allocSize = o.data.byteLength;\n    fd.totalSize = o.data.byteLength;\n    fd.readOnly = false;\n    fd.pos = 0;\n    return fd;\n}\n\nconst tmpBuff32 = new Uint8Array(4);\nconst tmpBuff32v = new DataView(tmpBuff32.buffer);\nconst tmpBuff64 = new Uint8Array(8);\nconst tmpBuff64v = new DataView(tmpBuff64.buffer);\n\nclass MemFile {\n\n    constructor() {\n        this.pageSize = 1 << 14;  // for compatibility\n    }\n\n    _resizeIfNeeded(newLen) {\n        if (newLen > this.allocSize) {\n            const newAllocSize = Math.max(\n                this.allocSize + (1 << 20),\n                Math.floor(this.allocSize * 1.1),\n                newLen\n            );\n            const newData = new Uint8Array(newAllocSize);\n            newData.set(this.o.data);\n            this.o.data = newData;\n            this.allocSize = newAllocSize;\n        }\n    }\n\n    async write(buff, pos) {\n        const self =this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) throw new Error(\"Writing a read only file\");\n\n        this._resizeIfNeeded(pos + buff.byteLength);\n\n        this.o.data.set(buff.slice(), pos);\n\n        if (pos + buff.byteLength > this.totalSize) this.totalSize = pos + buff.byteLength;\n\n        this.pos = pos + buff.byteLength;\n    }\n\n    async readToBuffer(buffDest, offset, len, pos) {\n        const self = this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) {\n            if (pos + len > this.totalSize) throw new Error(\"Reading out of bounds\");\n        }\n        this._resizeIfNeeded(pos + len);\n\n        const buffSrc = new Uint8Array(this.o.data.buffer, this.o.data.byteOffset + pos, len);\n\n        buffDest.set(buffSrc, offset);\n\n        this.pos = pos + len;\n    }\n\n    async read(len, pos) {\n        const self = this;\n\n        const buff = new Uint8Array(len);\n        await self.readToBuffer(buff, 0, len, pos);\n\n        return buff;\n    }\n\n    close() {\n        if (this.o.data.byteLength != this.totalSize) {\n            this.o.data = this.o.data.slice(0, this.totalSize);\n        }\n    }\n\n    async discard() {\n    }\n\n\n    async writeULE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v.setUint32(0, v, true);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n    async writeUBE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v.setUint32(0, v, false);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n\n    async writeULE64(v, pos) {\n        const self = this;\n\n        tmpBuff64v.setUint32(0, v & 0xFFFFFFFF, true);\n        tmpBuff64v.setUint32(4, Math.floor(v / 0x100000000) , true);\n\n        await self.write(tmpBuff64, pos);\n    }\n\n\n    async readULE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[0];\n    }\n\n    async readUBE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new DataView(b.buffer);\n\n        return view.getUint32(0, false);\n    }\n\n    async readULE64(pos) {\n        const self = this;\n        const b = await self.read(8, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[1] * 0x100000000 + view[0];\n    }\n\n    async readString(pos) {\n        const self = this;\n\n        let currentPosition = typeof pos == \"undefined\" ? self.pos : pos;\n\n        if (currentPosition > this.totalSize) {\n            if (this.readOnly) {\n                throw new Error(\"Reading out of bounds\");\n            }\n            this._resizeIfNeeded(pos);\n        }\n        const dataArray = new Uint8Array(\n            self.o.data.buffer,\n            currentPosition,\n            this.totalSize - currentPosition\n        );\n\n        let indexEndOfString = dataArray.findIndex(element => element === 0);\n        let endOfStringFound = indexEndOfString !== -1;\n\n        let str = \"\";\n        if (endOfStringFound) {\n            str = new TextDecoder().decode(dataArray.slice(0, indexEndOfString));\n            self.pos = currentPosition + indexEndOfString + 1;\n        } else {\n            self.pos = currentPosition;\n        }\n        return str;\n    }\n}\n", "const PAGE_SIZE = 1<<22;\n\nexport function createNew(o) {\n    const initialSize = o.initialSize || 0;\n    const fd = new BigMemFile();\n    fd.o = o;\n    const nPages = initialSize ? Math.floor((initialSize - 1) / PAGE_SIZE)+1 : 0;\n    fd.o.data = [];\n    for (let i=0; i<nPages-1; i++) {\n        fd.o.data.push( new Uint8Array(PAGE_SIZE));\n    }\n    if (nPages) fd.o.data.push( new Uint8Array(initialSize - PAGE_SIZE*(nPages-1)));\n    fd.totalSize = 0;\n    fd.readOnly = false;\n    fd.pos = 0;\n    return fd;\n}\n\nexport function readExisting(o) {\n    const fd = new BigMemFile();\n    fd.o = o;\n    fd.totalSize = (o.data.length-1)* PAGE_SIZE + o.data[o.data.length-1].byteLength;\n    fd.readOnly = true;\n    fd.pos = 0;\n    return fd;\n}\n\nexport function readWriteExisting(o) {\n    const fd = new BigMemFile();\n    fd.o = o;\n    fd.totalSize = (o.data.length-1)* PAGE_SIZE + o.data[o.data.length-1].byteLength;\n    fd.readOnly = false;\n    fd.pos = 0;\n    return fd;\n}\n\nconst tmpBuff32 = new Uint8Array(4);\nconst tmpBuff32v = new DataView(tmpBuff32.buffer);\nconst tmpBuff64 = new Uint8Array(8);\nconst tmpBuff64v = new DataView(tmpBuff64.buffer);\n\nclass BigMemFile {\n\n    constructor() {\n        this.pageSize = 1 << 14;  // for compatibility\n    }\n\n    _resizeIfNeeded(newLen) {\n\n        if (newLen <= this.totalSize) return;\n\n        if (this.readOnly) throw new Error(\"Reading out of file bounds\");\n\n        const nPages = Math.floor((newLen - 1) / PAGE_SIZE)+1;\n        for (let i= Math.max(this.o.data.length-1, 0); i<nPages; i++) {\n            const newSize = i<nPages-1 ? PAGE_SIZE : newLen - (nPages-1)*PAGE_SIZE;\n            const p = new Uint8Array(newSize);\n            if (i == this.o.data.length-1) p.set(this.o.data[i]);\n            this.o.data[i] = p;\n        }\n        this.totalSize = newLen;\n    }\n\n    async write(buff, pos) {\n        const self =this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) throw new Error(\"Writing a read only file\");\n\n        this._resizeIfNeeded(pos + buff.byteLength);\n\n        const firstPage = Math.floor(pos / PAGE_SIZE);\n\n        let p = firstPage;\n        let o = pos % PAGE_SIZE;\n        let r = buff.byteLength;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice(buff.byteLength - r, buff.byteLength - r + l);\n            const dstView = new Uint8Array(self.o.data[p].buffer, o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        this.pos = pos + buff.byteLength;\n    }\n\n    async readToBuffer(buffDst, offset, len, pos) {\n        const self = this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) {\n            if (pos + len > this.totalSize) throw new Error(\"Reading out of bounds\");\n        }\n        this._resizeIfNeeded(pos + len);\n\n        const firstPage = Math.floor(pos / PAGE_SIZE);\n\n        let p = firstPage;\n        let o = pos % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(self.o.data[p].buffer, o, l);\n            buffDst.set(srcView, offset+len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        this.pos = pos + len;\n    }\n\n    async read(len, pos) {\n        const self = this;\n        const buff = new Uint8Array(len);\n\n        await self.readToBuffer(buff, 0, len, pos);\n\n        return buff;\n    }\n\n    close() {\n    }\n\n    async discard() {\n    }\n\n\n    async writeULE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v.setUint32(0, v, true);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n    async writeUBE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v.setUint32(0, v, false);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n\n    async writeULE64(v, pos) {\n        const self = this;\n\n        tmpBuff64v.setUint32(0, v & 0xFFFFFFFF, true);\n        tmpBuff64v.setUint32(4, Math.floor(v / 0x100000000) , true);\n\n        await self.write(tmpBuff64, pos);\n    }\n\n\n    async readULE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[0];\n    }\n\n    async readUBE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new DataView(b.buffer);\n\n        return view.getUint32(0, false);\n    }\n\n    async readULE64(pos) {\n        const self = this;\n        const b = await self.read(8, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[1] * 0x100000000 + view[0];\n    }\n\n    async readString(pos) {\n        const self = this;\n        const fixedSize = 2048;\n\n        let currentPosition = typeof pos == \"undefined\" ? self.pos : pos;\n\n        if (currentPosition > this.totalSize) {\n            if (this.readOnly) {\n                throw new Error(\"Reading out of bounds\");\n            }\n            this._resizeIfNeeded(pos);\n        }\n\n        let endOfStringFound = false;\n        let str = \"\";\n\n        while (!endOfStringFound) {\n            let currentPage = Math.floor(currentPosition / PAGE_SIZE);\n            let offsetOnPage = currentPosition % PAGE_SIZE;\n\n            if (self.o.data[currentPage] === undefined) {\n                throw new Error(\"ERROR\");\n            }\n\n            let readLength = Math.min(fixedSize, self.o.data[currentPage].length - offsetOnPage);\n            const dataArray = new Uint8Array(self.o.data[currentPage].buffer, offsetOnPage, readLength);\n\n            let indexEndOfString = dataArray.findIndex(element => element === 0);\n            endOfStringFound = indexEndOfString !== -1;\n\n            if (endOfStringFound) {\n                str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));\n                self.pos = currentPage * PAGE_SIZE + offsetOnPage + indexEndOfString + 1;\n            } else {\n                str += new TextDecoder().decode(dataArray);\n                self.pos = currentPage * PAGE_SIZE + offsetOnPage + dataArray.length;\n            }\n\n            currentPosition = self.pos;\n        }\n        return str;\n    }\n}\n", "export var RTLD_LAZY = 1;\nexport var RTLD_NOW = 2;\nexport var RTLD_GLOBAL = 8;\nexport var RTLD_LOCAL = 4;\nexport var E2BIG = 7;\nexport var EACCES = 13;\nexport var EADDRINUSE = 48;\nexport var EADDRNOTAVAIL = 49;\nexport var EAFNOSUPPORT = 47;\nexport var EAGAIN = 35;\nexport var EALREADY = 37;\nexport var EBADF = 9;\nexport var EBADMSG = 94;\nexport var EBUSY = 16;\nexport var ECANCELED = 89;\nexport var ECHILD = 10;\nexport var ECONNABORTED = 53;\nexport var ECONNREFUSED = 61;\nexport var ECONNRESET = 54;\nexport var EDEADLK = 11;\nexport var EDESTADDRREQ = 39;\nexport var EDOM = 33;\nexport var EDQUOT = 69;\nexport var EEXIST = 17;\nexport var EFAULT = 14;\nexport var EFBIG = 27;\nexport var EHOSTUNREACH = 65;\nexport var EIDRM = 90;\nexport var EILSEQ = 92;\nexport var EINPROGRESS = 36;\nexport var EINTR = 4;\nexport var EINVAL = 22;\nexport var EIO = 5;\nexport var EISCONN = 56;\nexport var EISDIR = 21;\nexport var ELOOP = 62;\nexport var EMFILE = 24;\nexport var EMLINK = 31;\nexport var EMSGSIZE = 40;\nexport var EMULTIHOP = 95;\nexport var ENAMETOOLONG = 63;\nexport var ENETDOWN = 50;\nexport var ENETRESET = 52;\nexport var ENETUNREACH = 51;\nexport var ENFILE = 23;\nexport var ENOBUFS = 55;\nexport var ENODATA = 96;\nexport var ENODEV = 19;\nexport var ENOENT = 2;\nexport var ENOEXEC = 8;\nexport var ENOLCK = 77;\nexport var ENOLINK = 97;\nexport var ENOMEM = 12;\nexport var ENOMSG = 91;\nexport var ENOPROTOOPT = 42;\nexport var ENOSPC = 28;\nexport var ENOSR = 98;\nexport var ENOSTR = 99;\nexport var ENOSYS = 78;\nexport var ENOTCONN = 57;\nexport var ENOTDIR = 20;\nexport var ENOTEMPTY = 66;\nexport var ENOTSOCK = 38;\nexport var ENOTSUP = 45;\nexport var ENOTTY = 25;\nexport var ENXIO = 6;\nexport var EOPNOTSUPP = 102;\nexport var EOVERFLOW = 84;\nexport var EPERM = 1;\nexport var EPIPE = 32;\nexport var EPROTO = 100;\nexport var EPROTONOSUPPORT = 43;\nexport var EPROTOTYPE = 41;\nexport var ERANGE = 34;\nexport var EROFS = 30;\nexport var ESPIPE = 29;\nexport var ESRCH = 3;\nexport var ESTALE = 70;\nexport var ETIME = 101;\nexport var ETIMEDOUT = 60;\nexport var ETXTBSY = 26;\nexport var EWOULDBLOCK = 35;\nexport var EXDEV = 18;\nexport var PRIORITY_LOW = 19;\nexport var PRIORITY_BELOW_NORMAL = 10;\nexport var PRIORITY_NORMAL = 0;\nexport var PRIORITY_ABOVE_NORMAL = -7;\nexport var PRIORITY_HIGH = -14;\nexport var PRIORITY_HIGHEST = -20;\nexport var SIGHUP = 1;\nexport var SIGINT = 2;\nexport var SIGQUIT = 3;\nexport var SIGILL = 4;\nexport var SIGTRAP = 5;\nexport var SIGABRT = 6;\nexport var SIGIOT = 6;\nexport var SIGBUS = 10;\nexport var SIGFPE = 8;\nexport var SIGKILL = 9;\nexport var SIGUSR1 = 30;\nexport var SIGSEGV = 11;\nexport var SIGUSR2 = 31;\nexport var SIGPIPE = 13;\nexport var SIGALRM = 14;\nexport var SIGTERM = 15;\nexport var SIGCHLD = 20;\nexport var SIGCONT = 19;\nexport var SIGSTOP = 17;\nexport var SIGTSTP = 18;\nexport var SIGTTIN = 21;\nexport var SIGTTOU = 22;\nexport var SIGURG = 16;\nexport var SIGXCPU = 24;\nexport var SIGXFSZ = 25;\nexport var SIGVTALRM = 26;\nexport var SIGPROF = 27;\nexport var SIGWINCH = 28;\nexport var SIGIO = 23;\nexport var SIGINFO = 29;\nexport var SIGSYS = 12;\nexport var UV_FS_SYMLINK_DIR = 1;\nexport var UV_FS_SYMLINK_JUNCTION = 2;\nexport var O_RDONLY = 0;\nexport var O_WRONLY = 1;\nexport var O_RDWR = 2;\nexport var UV_DIRENT_UNKNOWN = 0;\nexport var UV_DIRENT_FILE = 1;\nexport var UV_DIRENT_DIR = 2;\nexport var UV_DIRENT_LINK = 3;\nexport var UV_DIRENT_FIFO = 4;\nexport var UV_DIRENT_SOCKET = 5;\nexport var UV_DIRENT_CHAR = 6;\nexport var UV_DIRENT_BLOCK = 7;\nexport var S_IFMT = 61440;\nexport var S_IFREG = 32768;\nexport var S_IFDIR = 16384;\nexport var S_IFCHR = 8192;\nexport var S_IFBLK = 24576;\nexport var S_IFIFO = 4096;\nexport var S_IFLNK = 40960;\nexport var S_IFSOCK = 49152;\nexport var O_CREAT = 512;\nexport var O_EXCL = 2048;\nexport var O_NOCTTY = 131072;\nexport var O_TRUNC = 1024;\nexport var O_APPEND = 8;\nexport var O_DIRECTORY = 1048576;\nexport var O_NOFOLLOW = 256;\nexport var O_SYNC = 128;\nexport var O_DSYNC = 4194304;\nexport var O_SYMLINK = 2097152;\nexport var O_NONBLOCK = 4;\nexport var S_IRWXU = 448;\nexport var S_IRUSR = 256;\nexport var S_IWUSR = 128;\nexport var S_IXUSR = 64;\nexport var S_IRWXG = 56;\nexport var S_IRGRP = 32;\nexport var S_IWGRP = 16;\nexport var S_IXGRP = 8;\nexport var S_IRWXO = 7;\nexport var S_IROTH = 4;\nexport var S_IWOTH = 2;\nexport var S_IXOTH = 1;\nexport var F_OK = 0;\nexport var R_OK = 4;\nexport var W_OK = 2;\nexport var X_OK = 1;\nexport var UV_FS_COPYFILE_EXCL = 1;\nexport var COPYFILE_EXCL = 1;\nexport var UV_FS_COPYFILE_FICLONE = 2;\nexport var COPYFILE_FICLONE = 2;\nexport var UV_FS_COPYFILE_FICLONE_FORCE = 4;\nexport var COPYFILE_FICLONE_FORCE = 4;\nexport var OPENSSL_VERSION_NUMBER = 269488175;\nexport var SSL_OP_ALL = 2147485780;\nexport var SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = 262144;\nexport var SSL_OP_CIPHER_SERVER_PREFERENCE = 4194304;\nexport var SSL_OP_CISCO_ANYCONNECT = 32768;\nexport var SSL_OP_COOKIE_EXCHANGE = 8192;\nexport var SSL_OP_CRYPTOPRO_TLSEXT_BUG = 2147483648;\nexport var SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = 2048;\nexport var SSL_OP_EPHEMERAL_RSA = 0;\nexport var SSL_OP_LEGACY_SERVER_CONNECT = 4;\nexport var SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = 0;\nexport var SSL_OP_MICROSOFT_SESS_ID_BUG = 0;\nexport var SSL_OP_MSIE_SSLV2_RSA_PADDING = 0;\nexport var SSL_OP_NETSCAPE_CA_DN_BUG = 0;\nexport var SSL_OP_NETSCAPE_CHALLENGE_BUG = 0;\nexport var SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = 0;\nexport var SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = 0;\nexport var SSL_OP_NO_COMPRESSION = 131072;\nexport var SSL_OP_NO_QUERY_MTU = 4096;\nexport var SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = 65536;\nexport var SSL_OP_NO_SSLv2 = 0;\nexport var SSL_OP_NO_SSLv3 = 33554432;\nexport var SSL_OP_NO_TICKET = 16384;\nexport var SSL_OP_NO_TLSv1 = 67108864;\nexport var SSL_OP_NO_TLSv1_1 = 268435456;\nexport var SSL_OP_NO_TLSv1_2 = 134217728;\nexport var SSL_OP_PKCS1_CHECK_1 = 0;\nexport var SSL_OP_PKCS1_CHECK_2 = 0;\nexport var SSL_OP_SINGLE_DH_USE = 0;\nexport var SSL_OP_SINGLE_ECDH_USE = 0;\nexport var SSL_OP_SSLEAY_080_CLIENT_DH_BUG = 0;\nexport var SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = 0;\nexport var SSL_OP_TLS_BLOCK_PADDING_BUG = 0;\nexport var SSL_OP_TLS_D5_BUG = 0;\nexport var SSL_OP_TLS_ROLLBACK_BUG = 8388608;\nexport var ENGINE_METHOD_RSA = 1;\nexport var ENGINE_METHOD_DSA = 2;\nexport var ENGINE_METHOD_DH = 4;\nexport var ENGINE_METHOD_RAND = 8;\nexport var ENGINE_METHOD_EC = 2048;\nexport var ENGINE_METHOD_CIPHERS = 64;\nexport var ENGINE_METHOD_DIGESTS = 128;\nexport var ENGINE_METHOD_PKEY_METHS = 512;\nexport var ENGINE_METHOD_PKEY_ASN1_METHS = 1024;\nexport var ENGINE_METHOD_ALL = 65535;\nexport var ENGINE_METHOD_NONE = 0;\nexport var DH_CHECK_P_NOT_SAFE_PRIME = 2;\nexport var DH_CHECK_P_NOT_PRIME = 1;\nexport var DH_UNABLE_TO_CHECK_GENERATOR = 4;\nexport var DH_NOT_SUITABLE_GENERATOR = 8;\nexport var ALPN_ENABLED = 1;\nexport var RSA_PKCS1_PADDING = 1;\nexport var RSA_SSLV23_PADDING = 2;\nexport var RSA_NO_PADDING = 3;\nexport var RSA_PKCS1_OAEP_PADDING = 4;\nexport var RSA_X931_PADDING = 5;\nexport var RSA_PKCS1_PSS_PADDING = 6;\nexport var RSA_PSS_SALTLEN_DIGEST = -1;\nexport var RSA_PSS_SALTLEN_MAX_SIGN = -2;\nexport var RSA_PSS_SALTLEN_AUTO = -2;\nexport var defaultCoreCipherList = \"TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA\";\nexport var TLS1_VERSION = 769;\nexport var TLS1_1_VERSION = 770;\nexport var TLS1_2_VERSION = 771;\nexport var TLS1_3_VERSION = 772;\nexport var POINT_CONVERSION_COMPRESSED = 2;\nexport var POINT_CONVERSION_UNCOMPRESSED = 4;\nexport var POINT_CONVERSION_HYBRID = 6;\nexport var defaultCipherList = \"TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA\";\nexport default {\n  RTLD_LAZY: RTLD_LAZY,\n  RTLD_NOW: RTLD_NOW,\n  RTLD_GLOBAL: RTLD_GLOBAL,\n  RTLD_LOCAL: RTLD_LOCAL,\n  E2BIG: E2BIG,\n  EACCES: EACCES,\n  EADDRINUSE: EADDRINUSE,\n  EADDRNOTAVAIL: EADDRNOTAVAIL,\n  EAFNOSUPPORT: EAFNOSUPPORT,\n  EAGAIN: EAGAIN,\n  EALREADY: EALREADY,\n  EBADF: EBADF,\n  EBADMSG: EBADMSG,\n  EBUSY: EBUSY,\n  ECANCELED: ECANCELED,\n  ECHILD: ECHILD,\n  ECONNABORTED: ECONNABORTED,\n  ECONNREFUSED: ECONNREFUSED,\n  ECONNRESET: ECONNRESET,\n  EDEADLK: EDEADLK,\n  EDESTADDRREQ: EDESTADDRREQ,\n  EDOM: EDOM,\n  EDQUOT: EDQUOT,\n  EEXIST: EEXIST,\n  EFAULT: EFAULT,\n  EFBIG: EFBIG,\n  EHOSTUNREACH: EHOSTUNREACH,\n  EIDRM: EIDRM,\n  EILSEQ: EILSEQ,\n  EINPROGRESS: EINPROGRESS,\n  EINTR: EINTR,\n  EINVAL: EINVAL,\n  EIO: EIO,\n  EISCONN: EISCONN,\n  EISDIR: EISDIR,\n  ELOOP: ELOOP,\n  EMFILE: EMFILE,\n  EMLINK: EMLINK,\n  EMSGSIZE: EMSGSIZE,\n  EMULTIHOP: EMULTIHOP,\n  ENAMETOOLONG: ENAMETOOLONG,\n  ENETDOWN: ENETDOWN,\n  ENETRESET: ENETRESET,\n  ENETUNREACH: ENETUNREACH,\n  ENFILE: ENFILE,\n  ENOBUFS: ENOBUFS,\n  ENODATA: ENODATA,\n  ENODEV: ENODEV,\n  ENOENT: ENOENT,\n  ENOEXEC: ENOEXEC,\n  ENOLCK: ENOLCK,\n  ENOLINK: ENOLINK,\n  ENOMEM: ENOMEM,\n  ENOMSG: ENOMSG,\n  ENOPROTOOPT: ENOPROTOOPT,\n  ENOSPC: ENOSPC,\n  ENOSR: ENOSR,\n  ENOSTR: ENOSTR,\n  ENOSYS: ENOSYS,\n  ENOTCONN: ENOTCONN,\n  ENOTDIR: ENOTDIR,\n  ENOTEMPTY: ENOTEMPTY,\n  ENOTSOCK: ENOTSOCK,\n  ENOTSUP: ENOTSUP,\n  ENOTTY: ENOTTY,\n  ENXIO: ENXIO,\n  EOPNOTSUPP: EOPNOTSUPP,\n  EOVERFLOW: EOVERFLOW,\n  EPERM: EPERM,\n  EPIPE: EPIPE,\n  EPROTO: EPROTO,\n  EPROTONOSUPPORT: EPROTONOSUPPORT,\n  EPROTOTYPE: EPROTOTYPE,\n  ERANGE: ERANGE,\n  EROFS: EROFS,\n  ESPIPE: ESPIPE,\n  ESRCH: ESRCH,\n  ESTALE: ESTALE,\n  ETIME: ETIME,\n  ETIMEDOUT: ETIMEDOUT,\n  ETXTBSY: ETXTBSY,\n  EWOULDBLOCK: EWOULDBLOCK,\n  EXDEV: EXDEV,\n  PRIORITY_LOW: PRIORITY_LOW,\n  PRIORITY_BELOW_NORMAL: PRIORITY_BELOW_NORMAL,\n  PRIORITY_NORMAL: PRIORITY_NORMAL,\n  PRIORITY_ABOVE_NORMAL: PRIORITY_ABOVE_NORMAL,\n  PRIORITY_HIGH: PRIORITY_HIGH,\n  PRIORITY_HIGHEST: PRIORITY_HIGHEST,\n  SIGHUP: SIGHUP,\n  SIGINT: SIGINT,\n  SIGQUIT: SIGQUIT,\n  SIGILL: SIGILL,\n  SIGTRAP: SIGTRAP,\n  SIGABRT: SIGABRT,\n  SIGIOT: SIGIOT,\n  SIGBUS: SIGBUS,\n  SIGFPE: SIGFPE,\n  SIGKILL: SIGKILL,\n  SIGUSR1: SIGUSR1,\n  SIGSEGV: SIGSEGV,\n  SIGUSR2: SIGUSR2,\n  SIGPIPE: SIGPIPE,\n  SIGALRM: SIGALRM,\n  SIGTERM: SIGTERM,\n  SIGCHLD: SIGCHLD,\n  SIGCONT: SIGCONT,\n  SIGSTOP: SIGSTOP,\n  SIGTSTP: SIGTSTP,\n  SIGTTIN: SIGTTIN,\n  SIGTTOU: SIGTTOU,\n  SIGURG: SIGURG,\n  SIGXCPU: SIGXCPU,\n  SIGXFSZ: SIGXFSZ,\n  SIGVTALRM: SIGVTALRM,\n  SIGPROF: SIGPROF,\n  SIGWINCH: SIGWINCH,\n  SIGIO: SIGIO,\n  SIGINFO: SIGINFO,\n  SIGSYS: SIGSYS,\n  UV_FS_SYMLINK_DIR: UV_FS_SYMLINK_DIR,\n  UV_FS_SYMLINK_JUNCTION: UV_FS_SYMLINK_JUNCTION,\n  O_RDONLY: O_RDONLY,\n  O_WRONLY: O_WRONLY,\n  O_RDWR: O_RDWR,\n  UV_DIRENT_UNKNOWN: UV_DIRENT_UNKNOWN,\n  UV_DIRENT_FILE: UV_DIRENT_FILE,\n  UV_DIRENT_DIR: UV_DIRENT_DIR,\n  UV_DIRENT_LINK: UV_DIRENT_LINK,\n  UV_DIRENT_FIFO: UV_DIRENT_FIFO,\n  UV_DIRENT_SOCKET: UV_DIRENT_SOCKET,\n  UV_DIRENT_CHAR: UV_DIRENT_CHAR,\n  UV_DIRENT_BLOCK: UV_DIRENT_BLOCK,\n  S_IFMT: S_IFMT,\n  S_IFREG: S_IFREG,\n  S_IFDIR: S_IFDIR,\n  S_IFCHR: S_IFCHR,\n  S_IFBLK: S_IFBLK,\n  S_IFIFO: S_IFIFO,\n  S_IFLNK: S_IFLNK,\n  S_IFSOCK: S_IFSOCK,\n  O_CREAT: O_CREAT,\n  O_EXCL: O_EXCL,\n  O_NOCTTY: O_NOCTTY,\n  O_TRUNC: O_TRUNC,\n  O_APPEND: O_APPEND,\n  O_DIRECTORY: O_DIRECTORY,\n  O_NOFOLLOW: O_NOFOLLOW,\n  O_SYNC: O_SYNC,\n  O_DSYNC: O_DSYNC,\n  O_SYMLINK: O_SYMLINK,\n  O_NONBLOCK: O_NONBLOCK,\n  S_IRWXU: S_IRWXU,\n  S_IRUSR: S_IRUSR,\n  S_IWUSR: S_IWUSR,\n  S_IXUSR: S_IXUSR,\n  S_IRWXG: S_IRWXG,\n  S_IRGRP: S_IRGRP,\n  S_IWGRP: S_IWGRP,\n  S_IXGRP: S_IXGRP,\n  S_IRWXO: S_IRWXO,\n  S_IROTH: S_IROTH,\n  S_IWOTH: S_IWOTH,\n  S_IXOTH: S_IXOTH,\n  F_OK: F_OK,\n  R_OK: R_OK,\n  W_OK: W_OK,\n  X_OK: X_OK,\n  UV_FS_COPYFILE_EXCL: UV_FS_COPYFILE_EXCL,\n  COPYFILE_EXCL: COPYFILE_EXCL,\n  UV_FS_COPYFILE_FICLONE: UV_FS_COPYFILE_FICLONE,\n  COPYFILE_FICLONE: COPYFILE_FICLONE,\n  UV_FS_COPYFILE_FICLONE_FORCE: UV_FS_COPYFILE_FICLONE_FORCE,\n  COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE,\n  OPENSSL_VERSION_NUMBER: OPENSSL_VERSION_NUMBER,\n  SSL_OP_ALL: SSL_OP_ALL,\n  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION,\n  SSL_OP_CIPHER_SERVER_PREFERENCE: SSL_OP_CIPHER_SERVER_PREFERENCE,\n  SSL_OP_CISCO_ANYCONNECT: SSL_OP_CISCO_ANYCONNECT,\n  SSL_OP_COOKIE_EXCHANGE: SSL_OP_COOKIE_EXCHANGE,\n  SSL_OP_CRYPTOPRO_TLSEXT_BUG: SSL_OP_CRYPTOPRO_TLSEXT_BUG,\n  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS,\n  SSL_OP_EPHEMERAL_RSA: SSL_OP_EPHEMERAL_RSA,\n  SSL_OP_LEGACY_SERVER_CONNECT: SSL_OP_LEGACY_SERVER_CONNECT,\n  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER,\n  SSL_OP_MICROSOFT_SESS_ID_BUG: SSL_OP_MICROSOFT_SESS_ID_BUG,\n  SSL_OP_MSIE_SSLV2_RSA_PADDING: SSL_OP_MSIE_SSLV2_RSA_PADDING,\n  SSL_OP_NETSCAPE_CA_DN_BUG: SSL_OP_NETSCAPE_CA_DN_BUG,\n  SSL_OP_NETSCAPE_CHALLENGE_BUG: SSL_OP_NETSCAPE_CHALLENGE_BUG,\n  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG,\n  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG,\n  SSL_OP_NO_COMPRESSION: SSL_OP_NO_COMPRESSION,\n  SSL_OP_NO_QUERY_MTU: SSL_OP_NO_QUERY_MTU,\n  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION,\n  SSL_OP_NO_SSLv2: SSL_OP_NO_SSLv2,\n  SSL_OP_NO_SSLv3: SSL_OP_NO_SSLv3,\n  SSL_OP_NO_TICKET: SSL_OP_NO_TICKET,\n  SSL_OP_NO_TLSv1: SSL_OP_NO_TLSv1,\n  SSL_OP_NO_TLSv1_1: SSL_OP_NO_TLSv1_1,\n  SSL_OP_NO_TLSv1_2: SSL_OP_NO_TLSv1_2,\n  SSL_OP_PKCS1_CHECK_1: SSL_OP_PKCS1_CHECK_1,\n  SSL_OP_PKCS1_CHECK_2: SSL_OP_PKCS1_CHECK_2,\n  SSL_OP_SINGLE_DH_USE: SSL_OP_SINGLE_DH_USE,\n  SSL_OP_SINGLE_ECDH_USE: SSL_OP_SINGLE_ECDH_USE,\n  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: SSL_OP_SSLEAY_080_CLIENT_DH_BUG,\n  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG,\n  SSL_OP_TLS_BLOCK_PADDING_BUG: SSL_OP_TLS_BLOCK_PADDING_BUG,\n  SSL_OP_TLS_D5_BUG: SSL_OP_TLS_D5_BUG,\n  SSL_OP_TLS_ROLLBACK_BUG: SSL_OP_TLS_ROLLBACK_BUG,\n  ENGINE_METHOD_RSA: ENGINE_METHOD_RSA,\n  ENGINE_METHOD_DSA: ENGINE_METHOD_DSA,\n  ENGINE_METHOD_DH: ENGINE_METHOD_DH,\n  ENGINE_METHOD_RAND: ENGINE_METHOD_RAND,\n  ENGINE_METHOD_EC: ENGINE_METHOD_EC,\n  ENGINE_METHOD_CIPHERS: ENGINE_METHOD_CIPHERS,\n  ENGINE_METHOD_DIGESTS: ENGINE_METHOD_DIGESTS,\n  ENGINE_METHOD_PKEY_METHS: ENGINE_METHOD_PKEY_METHS,\n  ENGINE_METHOD_PKEY_ASN1_METHS: ENGINE_METHOD_PKEY_ASN1_METHS,\n  ENGINE_METHOD_ALL: ENGINE_METHOD_ALL,\n  ENGINE_METHOD_NONE: ENGINE_METHOD_NONE,\n  DH_CHECK_P_NOT_SAFE_PRIME: DH_CHECK_P_NOT_SAFE_PRIME,\n  DH_CHECK_P_NOT_PRIME: DH_CHECK_P_NOT_PRIME,\n  DH_UNABLE_TO_CHECK_GENERATOR: DH_UNABLE_TO_CHECK_GENERATOR,\n  DH_NOT_SUITABLE_GENERATOR: DH_NOT_SUITABLE_GENERATOR,\n  ALPN_ENABLED: ALPN_ENABLED,\n  RSA_PKCS1_PADDING: RSA_PKCS1_PADDING,\n  RSA_SSLV23_PADDING: RSA_SSLV23_PADDING,\n  RSA_NO_PADDING: RSA_NO_PADDING,\n  RSA_PKCS1_OAEP_PADDING: RSA_PKCS1_OAEP_PADDING,\n  RSA_X931_PADDING: RSA_X931_PADDING,\n  RSA_PKCS1_PSS_PADDING: RSA_PKCS1_PSS_PADDING,\n  RSA_PSS_SALTLEN_DIGEST: RSA_PSS_SALTLEN_DIGEST,\n  RSA_PSS_SALTLEN_MAX_SIGN: RSA_PSS_SALTLEN_MAX_SIGN,\n  RSA_PSS_SALTLEN_AUTO: RSA_PSS_SALTLEN_AUTO,\n  defaultCoreCipherList: defaultCoreCipherList,\n  TLS1_VERSION: TLS1_VERSION,\n  TLS1_1_VERSION: TLS1_1_VERSION,\n  TLS1_2_VERSION: TLS1_2_VERSION,\n  TLS1_3_VERSION: TLS1_3_VERSION,\n  POINT_CONVERSION_COMPRESSED: POINT_CONVERSION_COMPRESSED,\n  POINT_CONVERSION_UNCOMPRESSED: POINT_CONVERSION_UNCOMPRESSED,\n  POINT_CONVERSION_HYBRID: POINT_CONVERSION_HYBRID,\n  defaultCipherList: defaultCipherList\n};\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format\n// ======\n// Header(1)\n//      Prover Type 1 Groth\n// HeaderGroth(2)\n//      n8q\n//      q\n//      n8r\n//      r\n//      NVars\n//      NPub\n//      DomainSize  (multiple of 2\n//      alpha1\n//      beta1\n//      delta1\n//      beta2\n//      gamma2\n//      delta2\n// IC(3)\n// Coefs(4)\n// PointsA(5)\n// PointsB1(6)\n// PointsB2(7)\n// PointsC(8)\n// PointsH(9)\n// Contributions(10)\n\nimport { Scalar, F1Field } from \"ffjavascript\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport { log2 } from \"./misc.js\";\n\nexport async function writeHeader(fd, zkey) {\n\n    // Write the header\n    ///////////\n    await binFileUtils.startWriteSection(fd, 1);\n    await fd.writeULE32(1); // Groth\n    await binFileUtils.endWriteSection(fd);\n\n    // Write the Groth header section\n    ///////////\n\n    const curve = await getCurve(zkey.q);\n\n    await binFileUtils.startWriteSection(fd, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n    await fd.writeULE32(n8q);\n    await binFileUtils.writeBigInt(fd, primeQ, n8q);\n    await fd.writeULE32(n8r);\n    await binFileUtils.writeBigInt(fd, primeR, n8r);\n    await fd.writeULE32(zkey.nVars);                         // Total number of bars\n    await fd.writeULE32(zkey.nPublic);                       // Total number of public vars (not including ONE)\n    await fd.writeULE32(zkey.domainSize);                  // domainSize\n    await writeG1(fd, curve, zkey.vk_alpha_1);\n    await writeG1(fd, curve, zkey.vk_beta_1);\n    await writeG2(fd, curve, zkey.vk_beta_2);\n    await writeG2(fd, curve, zkey.vk_gamma_2);\n    await writeG1(fd, curve, zkey.vk_delta_1);\n    await writeG2(fd, curve, zkey.vk_delta_2);\n\n    await binFileUtils.endWriteSection(fd);\n\n\n}\n\nexport async function writeZKey(fileName, zkey) {\n\n    let curve = getCurve(zkey.q);\n\n    const fd = await binFileUtils.createBinFile(fileName,\"zkey\", 1, 9);\n\n    await writeHeader(fd, zkey);\n    const n8r = (Math.floor( (Scalar.bitLength(zkey.r) - 1) / 64) +1)*8;\n    const Rr = Scalar.mod(Scalar.shl(1, n8r*8), zkey.r);\n    const R2r = Scalar.mod(Scalar.mul(Rr,Rr), zkey.r);\n\n    // Write Pols (A and B (C can be ommited))\n    ///////////\n\n    zkey.ccoefs = zkey.ccoefs.filter(c => c.matrix<2);\n    zkey.ccoefs.sort( (a,b) => a.constraint - b.constraint );\n    await binFileUtils.startWriteSection(fd, 4);\n    await fd.writeULE32(zkey.ccoefs.length);\n    for (let i=0; i<zkey.ccoefs.length; i++) {\n        const coef = zkey.ccoefs[i];\n        await fd.writeULE32(coef.matrix);\n        await fd.writeULE32(coef.constraint);\n        await fd.writeULE32(coef.signal);\n        await writeFr2(coef.value);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n\n    // Write IC Section\n    ///////////\n    await binFileUtils.startWriteSection(fd, 3);\n    for (let i=0; i<= zkey.nPublic; i++) {\n        await writeG1(fd, curve, zkey.IC[i] );\n    }\n    await binFileUtils.endWriteSection(fd);\n\n\n    // Write A\n    ///////////\n    await binFileUtils.startWriteSection(fd, 5);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.A[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write B1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 6);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.B1[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write B2\n    ///////////\n    await binFileUtils.startWriteSection(fd, 7);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG2(fd, curve, zkey.B2[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write C\n    ///////////\n    await binFileUtils.startWriteSection(fd, 8);\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.C[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n\n    // Write H points\n    ///////////\n    await binFileUtils.startWriteSection(fd, 9);\n    for (let i=0; i<zkey.domainSize; i++) {\n        await writeG1(fd, curve, zkey.hExps[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    await fd.close();\n\n    async function writeFr2(n) {\n        // Convert to montgomery\n        n = Scalar.mod( Scalar.mul(n, R2r), zkey.r);\n\n        await binFileUtils.writeBigInt(fd, n, n8r);\n    }\n\n}\n\nasync function writeG1(fd, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function writeG2(fd, curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function readG1(fd, curve, toObject) {\n    const buff = await fd.read(curve.G1.F.n8*2);\n    const res = curve.G1.fromRprLEM(buff, 0);\n    return toObject ? curve.G1.toObject(res) : res;\n}\n\nasync function readG2(fd, curve, toObject) {\n    const buff = await fd.read(curve.G2.F.n8*2);\n    const res = curve.G2.fromRprLEM(buff, 0);\n    return toObject ? curve.G2.toObject(res) : res;\n}\n\n\nexport async function readHeader(fd, sections, toObject) {\n    // Read Header\n    /////////////////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 1);\n    const protocolId = await fd.readULE32();\n    await binFileUtils.endReadSection(fd);\n\n    if (protocolId == 1) {\n        return await readHeaderGroth16(fd, sections, toObject);\n    } else if (protocolId == 2) {\n        return await readHeaderPlonk(fd, sections, toObject);\n    } else {\n        throw new Error(\"Protocol not supported: \");\n    }        \n}\n\n\n\n\nasync function readHeaderGroth16(fd, sections, toObject) {\n    const zkey = {};\n\n    zkey.protocol = \"groth16\";\n\n    // Read Groth Header\n    /////////////////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await binFileUtils.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await binFileUtils.readBigInt(fd, n8r);\n    zkey.curve = await getCurve(zkey.q);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.vk_alpha_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_gamma_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_delta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_delta_2 = await readG2(fd, zkey.curve, toObject);\n    await binFileUtils.endReadSection(fd);\n\n    return zkey;\n\n}\n\n\n\n\nasync function readHeaderPlonk(fd, sections, toObject) {\n    const zkey = {};\n\n    zkey.protocol = \"plonk\";\n\n    // Read Plonk Header\n    /////////////////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await binFileUtils.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await binFileUtils.readBigInt(fd, n8r);\n    zkey.curve = await getCurve(zkey.q);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstrains = await fd.readULE32();\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.Qm = await readG1(fd, zkey.curve, toObject);\n    zkey.Ql = await readG1(fd, zkey.curve, toObject);\n    zkey.Qr = await readG1(fd, zkey.curve, toObject);\n    zkey.Qo = await readG1(fd, zkey.curve, toObject);\n    zkey.Qc = await readG1(fd, zkey.curve, toObject);\n    zkey.S1 = await readG1(fd, zkey.curve, toObject);\n    zkey.S2 = await readG1(fd, zkey.curve, toObject);\n    zkey.S3 = await readG1(fd, zkey.curve, toObject);\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    await binFileUtils.endReadSection(fd);\n\n    return zkey;\n}\n\nexport async function readZKey(fileName, toObject) {\n    const {fd, sections} = await binFileUtils.readBinFile(fileName, \"zkey\", 1);\n\n    const zkey = await readHeader(fd, sections, toObject);\n\n    const Fr = new F1Field(zkey.r);\n    const Rr = Scalar.mod(Scalar.shl(1, zkey.n8r*8), zkey.r);\n    const Rri = Fr.inv(Rr);\n    const Rri2 = Fr.mul(Rri, Rri);\n\n    let curve = await getCurve(zkey.q);\n\n    // Read IC Section\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 3);\n    zkey.IC = [];\n    for (let i=0; i<= zkey.nPublic; i++) {\n        const P = await readG1(fd, curve, toObject);\n        zkey.IC.push(P);\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read Coefs\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 4);\n    const nCCoefs = await fd.readULE32();\n    zkey.ccoefs = [];\n    for (let i=0; i<nCCoefs; i++) {\n        const m = await fd.readULE32();\n        const c = await fd.readULE32();\n        const s = await fd.readULE32();\n        const v = await readFr2(toObject);\n        zkey.ccoefs.push({\n            matrix: m,\n            constraint: c,\n            signal: s,\n            value: v\n        });\n    }\n    await binFileUtils.endReadSection(fd);\n\n    // Read A points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 5);\n    zkey.A = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const A = await readG1(fd, curve, toObject);\n        zkey.A[i] = A;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read B1\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 6);\n    zkey.B1 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B1 = await readG1(fd, curve, toObject);\n\n        zkey.B1[i] = B1;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read B2 points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 7);\n    zkey.B2 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B2 = await readG2(fd, curve, toObject);\n        zkey.B2[i] = B2;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read C points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 8);\n    zkey.C = [];\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        const C = await readG1(fd, curve, toObject);\n\n        zkey.C[i] = C;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read H points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 9);\n    zkey.hExps = [];\n    for (let i=0; i<zkey.domainSize; i++) {\n        const H = await readG1(fd, curve, toObject);\n        zkey.hExps.push(H);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    await fd.close();\n\n    return zkey;\n\n    async function readFr2(/* toObject */) {\n        const n = await binFileUtils.readBigInt(fd, zkey.n8r);\n        return Fr.mul(n, Rri2);\n    }\n\n}\n\n\nasync function readContribution(fd, curve, toObject) {\n    const c = {delta:{}};\n    c.deltaAfter = await readG1(fd, curve, toObject);\n    c.delta.g1_s = await readG1(fd, curve, toObject);\n    c.delta.g1_sx = await readG1(fd, curve, toObject);\n    c.delta.g2_spx = await readG2(fd, curve, toObject);\n    c.transcript = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await fd.read(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await fd.read(1);\n            const buffStr = await fd.read(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await fd.read(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await fd.read(1);\n            c.beaconHash = await fd.read(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parametes do not match\");\n    }\n\n    return c;\n}\n\n\nexport async function readMPCParams(fd, curve, sections) {\n    await binFileUtils.startReadUniqueSection(fd, sections, 10);\n    const res = { contributions: []};\n    res.csHash = await fd.read(64);\n    const n = await fd.readULE32();\n    for (let i=0; i<n; i++) {\n        const c = await readContribution(fd, curve);\n        res.contributions.push(c);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    return res;\n}\n\nasync function writeContribution(fd, curve, c) {\n    await writeG1(fd, curve, c.deltaAfter);\n    await writeG1(fd, curve, c.delta.g1_s);\n    await writeG1(fd, curve, c.delta.g1_sx);\n    await writeG2(fd, curve, c.delta.g2_spx);\n    await fd.write(c.transcript);\n    await fd.writeULE32(c.type || 0);\n\n    const params = [];\n    if (c.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(c.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (c.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(c.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(c.beaconHash.byteLength);\n        for (let i=0; i<c.beaconHash.byteLength; i++) params.push(c.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n}\n\nexport async function writeMPCParams(fd, curve, mpcParams) {\n    await binFileUtils.startWriteSection(fd, 10);\n    await fd.write(mpcParams.csHash);\n    await fd.writeULE32(mpcParams.contributions.length);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        await writeContribution(fd, curve,mpcParams.contributions[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n}\n\nexport function hashG1(hasher, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nexport function hashG2(hasher,curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nexport function hashPubKey(hasher, curve, c) {\n    hashG1(hasher, curve, c.deltaAfter);\n    hashG1(hasher, curve, c.delta.g1_s);\n    hashG1(hasher, curve, c.delta.g1_sx);\n    hashG2(hasher, curve, c.delta.g2_spx);\n    hasher.update(c.transcript);\n}\n\n", "\nimport * as _Scalar  from \"./src/scalar.js\";\nexport const Scalar=_Scalar;\n\nexport {default as PolField} from \"./src/polfield.js\";\nexport {default as F1Field} from \"./src/f1field.js\";\nexport {default as F2Field} from \"./src/f2field.js\";\nexport {default as F3Field} from \"./src/f3field.js\";\n\nexport {default as ZqField} from \"./src/f1field.js\";\n\nexport {default as EC} from \"./src/ec.js\";\n\nexport {default as buildBn128} from \"./src/bn128.js\";\nexport {default as buildBls12381} from \"./src/bls12381.js\";\n\nimport * as _utils from \"./src/utils.js\";\nexport const utils = _utils;\nexport {default as ChaCha} from \"./src/chacha.js\";\n\nexport {default as BigBuffer} from \"./src/bigbuffer.js\";\n\nexport {getCurveFromR, getCurveFromQ, getCurveFromName} from \"./src/curves.js\";\n\n", "\n/* global BigInt */\nconst hexLen = [ 0, 1, 2, 2, 3, 3, 3, 3, 4 ,4 ,4 ,4 ,4 ,4 ,4 ,4];\n\nexport function fromString(s, radix) {\n    if ((!radix)||(radix==10)) {\n        return BigInt(s);\n    } else if (radix==16) {\n        if (s.slice(0,2) == \"0x\") {\n            return BigInt(s);\n        } else {\n            return BigInt(\"0x\"+s);\n        }\n    }\n}\n\nexport const e = fromString;\n\nexport function fromArray(a, radix) {\n    let acc =BigInt(0);\n    radix = BigInt(radix);\n    for (let i=0; i<a.length; i++) {\n        acc = acc*radix + BigInt(a[i]);\n    }\n    return acc;\n}\n\nexport function bitLength(a) {\n    const aS =a.toString(16);\n    return (aS.length-1)*4 +hexLen[parseInt(aS[0], 16)];\n}\n\nexport function isNegative(a) {\n    return BigInt(a) < BigInt(0);\n}\n\nexport function isZero(a) {\n    return !a;\n}\n\nexport function shiftLeft(a, n) {\n    return BigInt(a) << BigInt(n);\n}\n\nexport function shiftRight(a, n) {\n    return BigInt(a) >> BigInt(n);\n}\n\nexport const shl = shiftLeft;\nexport const shr = shiftRight;\n\nexport function isOdd(a) {\n    return (BigInt(a) & BigInt(1)) == BigInt(1);\n}\n\n\nexport function naf(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            const z = 2 - Number(E % BigInt(4));\n            res.push( z );\n            E = E - BigInt(z);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\n\nexport function bits(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\nexport function toNumber(s) {\n    if (s>BigInt(Number.MAX_SAFE_INTEGER )) {\n        throw new Error(\"Number too big\");\n    }\n    return Number(s);\n}\n\nexport function toArray(s, radix) {\n    const res = [];\n    let rem = BigInt(s);\n    radix = BigInt(radix);\n    while (rem) {\n        res.unshift( Number(rem % radix));\n        rem = rem / radix;\n    }\n    return res;\n}\n\n\nexport function add(a, b) {\n    return BigInt(a) + BigInt(b);\n}\n\nexport function sub(a, b) {\n    return BigInt(a) - BigInt(b);\n}\n\nexport function neg(a) {\n    return -BigInt(a);\n}\n\nexport function mul(a, b) {\n    return BigInt(a) * BigInt(b);\n}\n\nexport function square(a) {\n    return BigInt(a) * BigInt(a);\n}\n\nexport function pow(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function exp(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function abs(a) {\n    return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);\n}\n\nexport function div(a, b) {\n    return BigInt(a) / BigInt(b);\n}\n\nexport function mod(a, b) {\n    return BigInt(a) % BigInt(b);\n}\n\nexport function eq(a, b) {\n    return BigInt(a) == BigInt(b);\n}\n\nexport function neq(a, b) {\n    return BigInt(a) != BigInt(b);\n}\n\nexport function lt(a, b) {\n    return BigInt(a) < BigInt(b);\n}\n\nexport function gt(a, b) {\n    return BigInt(a) > BigInt(b);\n}\n\nexport function leq(a, b) {\n    return BigInt(a) <= BigInt(b);\n}\n\nexport function geq(a, b) {\n    return BigInt(a) >= BigInt(b);\n}\n\nexport function band(a, b) {\n    return BigInt(a) & BigInt(b);\n}\n\nexport function bor(a, b) {\n    return BigInt(a) | BigInt(b);\n}\n\nexport function bxor(a, b) {\n    return BigInt(a) ^ BigInt(b);\n}\n\nexport function land(a, b) {\n    return BigInt(a) && BigInt(b);\n}\n\nexport function lor(a, b) {\n    return BigInt(a) || BigInt(b);\n}\n\nexport function lnot(a) {\n    return !BigInt(a);\n}\n\n// Returns a buffer with Little Endian Representation\nexport function toRprLE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new Uint32Array(buff.buffer, o, n8/4);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v[i] = parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16);\n    for (let i=l; i<v.length; i++) v[i] = 0;\n    for (let i=v.length*4; i<n8; i++) buff[i] = toNumber(band(shiftRight(e, i*8), 0xFF));\n}\n\n// Returns a buffer with Big Endian Representation\nexport function toRprBE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v.setUint32(n8-i*4 -4, parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16), false);\n    for (let i=0; i<n8/4-l; i++) v[i] = 0;\n}\n\n// Pases a buffer with Little Endian Representation\nexport function fromRprLE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new Uint32Array(buff.buffer, o, n8/4);\n    const a = new Array(n8/4);\n    v.forEach( (ch,i) => a[a.length-i-1] = ch.toString(16).padStart(8,\"0\") );\n    return fromString(a.join(\"\"), 16);\n}\n\n// Pases a buffer with Big Endian Representation\nexport function fromRprBE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const a = new Array(n8/4);\n    for (let i=0; i<n8/4; i++) {\n        a[i] = v.getUint32(i*4, false).toString(16).padStart(8, \"0\");\n    }\n    return fromString(a.join(\"\"), 16);\n}\n\nexport function toString(a, radix) {\n    return a.toString(radix);\n}\n\nexport function toLEBuff(a) {\n    const buff = new Uint8Array(Math.floor((bitLength(a) - 1) / 8) +1);\n    toRprLE(buff, 0, a, buff.byteLength);\n    return buff;\n}\n\nexport const zero = e(0);\nexport const one = e(1);\n\n\n\n\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class PolField {\n    constructor (F) {\n        this.F = F;\n\n        let rem = F.sqrt_t;\n        let s = F.sqrt_s;\n\n        const five = this.F.add(this.F.add(this.F.two, this.F.two), this.F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(five, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n/*        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n    */\n        this._setRoots(15);\n    }\n\n    _setRoots(n) {\n        if (n > this.F.sqrt_s) n = this.s;\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n            this.roots[i] = rootsi;\n        }\n    }\n\n    add(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.add(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.sub(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    mulScalar(p, b) {\n        if (this.F.eq(b, this.F.zero)) return [];\n        if (this.F.eq(b, this.F.one)) return p;\n        const res = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.mul(p[i], b);\n        }\n        return res;\n    }\n\n\n\n    mul(a, b) {\n        if (a.length == 0) return [];\n        if (b.length == 0) return [];\n        if (a.length == 1) return this.mulScalar(b, a[0]);\n        if (b.length == 1) return this.mulScalar(a, b[0]);\n\n        if (b.length > a.length) {\n            [b, a] = [a, b];\n        }\n\n        if ((b.length <= 2) || (b.length < log2(a.length))) {\n            return this.mulNormal(a,b);\n        } else {\n            return this.mulFFT(a,b);\n        }\n    }\n\n    mulNormal(a, b) {\n        let res = [];\n        for (let i=0; i<b.length; i++) {\n            res = this.add(res, this.scaleX(this.mulScalar(a, b[i]), i) );\n        }\n        return res;\n    }\n\n    mulFFT(a,b) {\n        const longestN = Math.max(a.length, b.length);\n        const bitsResult = log2(longestN-1)+2;\n        this._setRoots(bitsResult);\n\n        const m = 1 << bitsResult;\n        const ea = this.extend(a,m);\n        const eb = this.extend(b,m);\n\n        const ta = __fft(this, ea, bitsResult, 0, 1, false);\n        const tb = __fft(this, eb, bitsResult, 0, 1, false);\n\n        const tres = new Array(m);\n\n        for (let i=0; i<m; i++) {\n            tres[i] = this.F.mul(ta[i], tb[i]);\n        }\n\n        const res = __fft(this, tres, bitsResult, 0, 1, true);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return this.reduce(resn);\n    }\n\n\n\n    square(a) {\n        return this.mul(a,a);\n    }\n\n    scaleX(p, n) {\n        if (n==0) {\n            return p;\n        } else if (n>0) {\n            const z = new Array(n).fill(this.F.zero);\n            return z.concat(p);\n        } else {\n            if (-n >= p.length) return [];\n            return p.slice(-n);\n        }\n    }\n\n    eval2(p, x) {\n        let v = this.F.zero;\n        let ix = this.F.one;\n        for (let i=0; i<p.length; i++) {\n            v = this.F.add(v, this.F.mul(p[i], ix));\n            ix = this.F.mul(ix, x);\n        }\n        return v;\n    }\n\n    eval(p,x) {\n        const F = this.F;\n        if (p.length == 0) return F.zero;\n        const m = this._next2Power(p.length);\n        const ep = this.extend(p, m);\n\n        return _eval(ep, x, 0, 1, m);\n\n        function _eval(p, x, offset, step, n) {\n            if (n==1) return p[offset];\n            const newX = F.square(x);\n            const res= F.add(\n                _eval(p, newX, offset, step << 1, n >> 1),\n                F.mul(\n                    x,\n                    _eval(p, newX, offset+step , step << 1, n >> 1)));\n            return res;\n        }\n    }\n\n    lagrange(points) {\n        let roots = [this.F.one];\n        for (let i=0; i<points.length; i++) {\n            roots = this.mul(roots, [this.F.neg(points[i][0]), this.F.one]);\n        }\n\n        let sum = [];\n        for (let i=0; i<points.length; i++) {\n            let mpol = this.ruffini(roots, points[i][0]);\n            const factor =\n                this.F.mul(\n                    this.F.inv(this.eval(mpol, points[i][0])),\n                    points[i][1]);\n            mpol = this.mulScalar(mpol, factor);\n            sum = this.add(sum, mpol);\n        }\n        return sum;\n    }\n\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res = __fft(this, ep, bits, 0, 1);\n        return res;\n    }\n\n    fft2(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res = __fft2(this, ep, bits);\n        return res;\n    }\n\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res =  __fft(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n\n    ifft2(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res =  __fft2(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n    _fft(pall, bits, offset, step) {\n\n        const n = 1 << bits;\n        if (n==1) {\n            return [ pall[offset] ];\n        }\n\n        const ndiv2 = n >> 1;\n        const p1 = this._fft(pall, bits-1, offset, step*2);\n        const p2 = this._fft(pall, bits-1, offset+step, step*2);\n\n        const out = new Array(n);\n\n        let m= this.F.one;\n        for (let i=0; i<ndiv2; i++) {\n            out[i] = this.F.add(p1[i], this.F.mul(m, p2[i]));\n            out[i+ndiv2] = this.F.sub(p1[i], this.F.mul(m, p2[i]));\n            m = this.F.mul(m, this.w[bits]);\n        }\n\n        return out;\n    }\n\n    extend(p, e) {\n        if (e == p.length) return p;\n        const z = new Array(e-p.length).fill(this.F.zero);\n\n        return p.concat(z);\n    }\n\n    reduce(p) {\n        if (p.length == 0) return p;\n        if (! this.F.eq(p[p.length-1], this.F.zero) ) return p;\n        let i=p.length-1;\n        while( i>0 && this.F.eq(p[i], this.F.zero) ) i--;\n        return p.slice(0, i+1);\n    }\n\n    eq(a, b) {\n        const pa = this.reduce(a);\n        const pb = this.reduce(b);\n\n        if (pa.length != pb.length) return false;\n        for (let i=0; i<pb.length; i++) {\n            if (!this.F.eq(pa[i], pb[i])) return false;\n        }\n\n        return true;\n    }\n\n    ruffini(p, r) {\n        const res = new Array(p.length-1);\n        res[res.length-1] = p[p.length-1];\n        for (let i = res.length-2; i>=0; i--) {\n            res[i] = this.F.add(this.F.mul(res[i+1], r), p[i+1]);\n        }\n        return res;\n    }\n\n    _next2Power(v) {\n        v--;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v++;\n        return v;\n    }\n\n    toString(p) {\n        const ap = this.normalize(p);\n        let S = \"\";\n        for (let i=ap.length-1; i>=0; i--) {\n            if (!this.F.eq(p[i], this.F.zero)) {\n                if (S!=\"\") S += \" + \";\n                S = S + p[i].toString(10);\n                if (i>0) {\n                    S = S + \"x\";\n                    if (i>1) {\n                        S = S + \"^\" +i;\n                    }\n                }\n            }\n        }\n        return S;\n    }\n\n    normalize(p) {\n        const res  = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.normalize(p[i]);\n        }\n        return res;\n    }\n\n\n    _reciprocal(p, bits) {\n        const k = 1 << bits;\n        if (k==1) {\n            return [ this.F.inv(p[0]) ];\n        }\n        const np = this.scaleX(p, -k/2);\n        const q = this._reciprocal(np, bits-1);\n        const a = this.scaleX(this.double(q), 3*k/2-2);\n        const b = this.mul( this.square(q), p);\n\n        return this.scaleX(this.sub(a,b),   -(k-2));\n    }\n\n    // divides x^m / v\n    _div2(m, v) {\n        const kbits = log2(v.length-1)+1;\n        const k = 1 << kbits;\n\n        const scaleV = k - v.length;\n\n        // rec = x^(k - 2) / v* x^scaleV =>\n        // rec = x^(k-2-scaleV)/ v\n        //\n        // res = x^m/v = x^(m + (2*k-2 - scaleV) - (2*k-2 - scaleV)) /v =>\n        // res = rec * x^(m - (2*k-2 - scaleV)) =>\n        // res = rec * x^(m - 2*k + 2 + scaleV)\n\n        const rec = this._reciprocal(this.scaleX(v, scaleV), kbits);\n        const res = this.scaleX(rec, m - 2*k + 2 + scaleV);\n\n        return res;\n    }\n\n    div(_u, _v) {\n        if (_u.length < _v.length) return [];\n        const kbits = log2(_v.length-1)+1;\n        const k = 1 << kbits;\n\n        const u = this.scaleX(_u, k-_v.length);\n        const v = this.scaleX(_v, k-_v.length);\n\n        const n = v.length-1;\n        let m = u.length-1;\n\n        const s = this._reciprocal(v, kbits);\n        let t;\n        if (m>2*n) {\n            t = this.sub(this.scaleX([this.F.one], 2*n), this.mul(s, v));\n        }\n\n        let q = [];\n        let rem = u;\n        let us, ut;\n        let finish = false;\n\n        while (!finish) {\n            us = this.mul(rem, s);\n            q = this.add(q, this.scaleX(us, -2*n));\n\n            if ( m > 2*n ) {\n                ut = this.mul(rem, t);\n                rem = this.scaleX(ut, -2*n);\n                m = rem.length-1;\n            } else {\n                finish = true;\n            }\n        }\n\n        return q;\n    }\n\n\n    // returns the ith nth-root of one\n    oneRoot(n, i) {\n        let nbits = log2(n-1)+1;\n        let res = this.F.one;\n        let r = i;\n\n        if(i>=n) {\n            throw new Error(\"Given 'i' should be lower than 'n'\");\n        }\n        else if (1<<nbits !== n) {\n            throw new Error(`Internal errlr: ${n} should equal ${1<<nbits}`);\n        }\n\n        while (r>0) {\n            if (r & 1 == 1) {\n                res = this.F.mul(res, this.w[nbits]);\n            }\n            r = r >> 1;\n            nbits --;\n        }\n        return res;\n    }\n\n    computeVanishingPolinomial(bits, t) {\n        const m = 1 << bits;\n        return this.F.sub(this.F.pow(t, m), this.F.one);\n    }\n\n    evaluateLagrangePolynomials(bits, t) {\n        const m= 1 << bits;\n        const tm = this.F.pow(t, m);\n        const u= new Array(m).fill(this.F.zero);\n        this._setRoots(bits);\n        const omega = this.w[bits];\n\n        if (this.F.eq(tm, this.F.one)) {\n            for (let i = 0; i < m; i++) {\n                if (this.F.eq(this.roots[bits][0],t)) { // i.e., t equals omega^i\n                    u[i] = this.F.one;\n                    return u;\n                }\n            }\n        }\n\n        const z = this.F.sub(tm, this.F.one);\n        //        let l = this.F.mul(z,  this.F.pow(this.F.twoinv, m));\n        let l = this.F.mul(z,  this.F.inv(this.F.e(m)));\n        for (let i = 0; i < m; i++) {\n            u[i] = this.F.mul(l, this.F.inv(this.F.sub(t,this.roots[bits][i])));\n            l = this.F.mul(l, omega);\n        }\n\n        return u;\n    }\n\n    log2(V) {\n        return log2(V);\n    }\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.F.add(pall[offset], pall[offset + step]),\n            PF.F.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\n\nfunction __fft2(PF, pall, bits) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[0] ];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft2(PF, pall.slice(0, ndiv2), bits-1);\n    const p2 = __fft2(PF, pall.slice(ndiv2), bits-1);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction rev(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\nfunction __bitReverse(p, bits) {\n    for (let k=0; k<p.length; k++) {\n        const r = rev(k, bits);\n        if (r>k) {\n            const tmp= p[k];\n            p[k] = p[r];\n            p[r] = tmp;\n        }\n    }\n\n}\n\n\n", "/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\nimport * as futils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\nimport {getRandomBytes} from \"./random.js\";\nimport FFFT from \"./fft.js\";\n\nexport default class ZqField {\n    constructor(p) {\n        this.type=\"F1\";\n        this.one = BigInt(1);\n        this.zero = BigInt(0);\n        this.p = BigInt(p);\n        this.m = 1;\n        this.negone = this.p-this.one;\n        this.two = BigInt(2);\n        this.half = this.p >> this.one;\n        this.bitLength = Scalar.bitLength(this.p);\n        this.mask = (this.one << BigInt(this.bitLength)) - this.one;\n\n        this.n64 = Math.floor((this.bitLength - 1) / 64)+1;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n        this.R = this.e(this.one << BigInt(this.n64*64));\n        this.Ri = this.inv(this.R);\n\n        const e = this.negone >> this.one;\n        this.nqr = this.two;\n        let r = this.pow(this.nqr, e);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.nqr + this.one;\n            r = this.pow(this.nqr, e);\n        }\n\n\n        this.s = 0;\n        this.t = this.negone;\n\n        while ((this.t & this.one) == this.zero) {\n            this.s = this.s + 1;\n            this.t = this.t >> this.one;\n        }\n\n        this.nqr_to_t = this.pow(this.nqr, this.t);\n\n        buildSqrt(this);\n\n        this.FFT = new FFFT(this, this, this.mul.bind(this));\n\n        this.fft = this.FFT.fft.bind(this.FFT);\n        this.ifft = this.FFT.ifft.bind(this.FFT);\n        this.w = this.FFT.w;\n        this.wi = this.FFT.wi; \n    \n        this.shift = this.square(this.nqr);\n        this.k = this.exp(this.nqr, 2**this.s);\n    }\n\n    e(a,b) {\n        let res;\n        if (!b) {\n            res = BigInt(a);\n        } else if (b==16) {\n            res = BigInt(\"0x\"+a);\n        }\n        if (res < 0) {\n            let nres = -res;\n            if (nres >= this.p) nres = nres % this.p;\n            return this.p - nres;\n        } else {\n            return (res>= this.p) ? res%this.p : res;\n        }\n\n    }\n\n    add(a, b) {\n        const res = a + b;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    sub(a, b) {\n        return (a >= b) ? a-b : this.p-b+a;\n    }\n\n    neg(a) {\n        return a ? this.p-a : a;\n    }\n\n    mul(a, b) {\n        return (a*b)%this.p;\n    }\n\n    mulScalar(base, s) {\n        return (base * this.e(s)) % this.p;\n    }\n\n    square(a) {\n        return (a*a) % this.p;\n    }\n\n    eq(a, b) {\n        return a==b;\n    }\n\n    neq(a, b) {\n        return a!=b;\n    }\n\n    lt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa < bb;\n    }\n\n    gt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa > bb;\n    }\n\n    leq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa <= bb;\n    }\n\n    geq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa >= bb;\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    idiv(a, b) {\n        if (!b) throw new Error(\"Division by zero\");\n        return a / b;\n    }\n\n    inv(a) {\n        if (!a) throw new Error(\"Division by zero\");\n\n        let t = this.zero;\n        let r = this.p;\n        let newt = this.one;\n        let newr = a % this.p;\n        while (newr) {\n            let q = r/newr;\n            [t, newt] = [newt, t-q*newt];\n            [r, newr] = [newr, r-q*newr];\n        }\n        if (t<this.zero) t += this.p;\n        return t;\n    }\n\n    mod(a, b) {\n        return a % b;\n    }\n\n    pow(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    exp(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    band(a, b) {\n        const res =  ((a & b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bor(a, b) {\n        const res =  ((a | b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bxor(a, b) {\n        const res =  ((a ^ b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bnot(a) {\n        const res = a ^ this.mask;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    shl(a, b) {\n        if (Number(b) < this.bitLength) {\n            const res = (a << b) & this.mask;\n            return res >= this.p ? res-this.p : res;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                return a >> nb;\n            } else {\n                return this.zero;\n            }\n        }\n    }\n\n    shr(a, b) {\n        if (Number(b) < this.bitLength) {\n            return a >> b;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                const res = (a << nb) & this.mask;\n                return res >= this.p ? res-this.p : res;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    land(a, b) {\n        return (a && b) ? this.one : this.zero;\n    }\n\n    lor(a, b) {\n        return (a || b) ? this.one : this.zero;\n    }\n\n    lnot(a) {\n        return (a) ? this.zero : this.one;\n    }\n\n    sqrt_old(n) {\n\n        if (n == this.zero) return this.zero;\n\n        // Test that have solution\n        const res = this.pow(n, this.negone >> this.one);\n        if ( res != this.one ) return null;\n\n        let m = this.s;\n        let c = this.nqr_to_t;\n        let t = this.pow(n, this.t);\n        let r = this.pow(n, this.add(this.t, this.one) >> this.one );\n\n        while ( t != this.one ) {\n            let sq = this.square(t);\n            let i = 1;\n            while (sq != this.one ) {\n                i++;\n                sq = this.square(sq);\n            }\n\n            // b = c ^ m-i-1\n            let b = c;\n            for (let j=0; j< m-i-1; j ++) b = this.square(b);\n\n            m = i;\n            c = this.square(b);\n            t = this.mul(t, c);\n            r = this.mul(r, b);\n        }\n\n        if (r > (this.p >> this.one)) {\n            r = this.neg(r);\n        }\n\n        return r;\n    }\n\n    normalize(a, b) {\n        a = BigInt(a,b);\n        if (a < 0) {\n            let na = -a;\n            if (na >= this.p) na = na % this.p;\n            return this.p - na;\n        } else {\n            return (a>= this.p) ? a%this.p : a;\n        }\n    }\n\n    random() {\n        const nBytes = (this.bitLength*2 / 8);\n        let res =this.zero;\n        for (let i=0; i<nBytes; i++) {\n            res = (res << BigInt(8)) + BigInt(getRandomBytes(1)[0]);\n        }\n        return res % this.p;\n    }\n\n    toString(a, base) {\n        base = base || 10;\n        let vs;\n        if ((a > this.half)&&(base == 10)) {\n            const v = this.p-a;\n            vs = \"-\"+v.toString(base);\n        } else {\n            vs = a.toString(base);\n        }\n        return vs;\n    }\n\n    isZero(a) {\n        return a == this.zero;\n    }\n\n    fromRng(rng) {\n        let v;\n        do {\n            v=this.zero;\n            for (let i=0; i<this.n64; i++) {\n                v += rng.nextU64() << BigInt(64 *i);\n            }\n            v &= this.mask;\n        } while (v >= this.p);\n        v = (v * this.Ri) % this.p;   // Convert from montgomery\n        return v;\n    }\n\n    fft(a) {\n        return this.FFT.fft(a);\n    }\n\n    ifft(a) {\n        return this.FFT.ifft(a);\n    }\n\n    // Returns a buffer with Little Endian Representation\n    toRprLE(buff, o, e) {\n        Scalar.toRprLE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Representation\n    toRprBE(buff, o, e) {\n        Scalar.toRprBE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Montgomery Representation\n    toRprBEM(buff, o, e) {\n        return this.toRprBE(buff, o, this.mul(this.R, e));\n    }\n\n    toRprLEM(buff, o, e) {\n        return this.toRprLE(buff, o, this.mul(this.R, e));\n    }\n\n\n    // Pases a buffer with Little Endian Representation\n    fromRprLE(buff, o) {\n        return Scalar.fromRprLE(buff, o, this.n8);\n    }\n\n    // Pases a buffer with Big Endian Representation\n    fromRprBE(buff, o) {\n        return Scalar.fromRprBE(buff, o, this.n8);\n    }\n\n    fromRprLEM(buff, o) {\n        return this.mul(this.fromRprLE(buff, o), this.Ri);\n    }\n\n    fromRprBEM(buff, o) {\n        return this.mul(this.fromRprBE(buff, o), this.Ri);\n    }\n\n    toObject(a) {\n        return a;\n    }\n}", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as Scalar from \"./scalar.js\";\n\n\nexport function mulScalar(F, base, e) {\n    let res;\n\n    if (Scalar.isZero(e)) return F.zero;\n\n    const n = Scalar.naf(e);\n\n    if (n[n.length-1] == 1) {\n        res = base;\n    } else if (n[n.length-1] == -1) {\n        res = F.neg(base);\n    } else {\n        throw new Error(\"invlaud NAF\");\n    }\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.double(res);\n\n        if (n[i] == 1) {\n            res = F.add(res, base);\n        } else if (n[i] == -1) {\n            res = F.sub(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n/*\nexports.mulScalar = (F, base, e) =>{\n    let res = F.zero;\n    let rem = bigInt(e);\n    let exp = base;\n\n    while (! rem.eq(bigInt.zero)) {\n        if (rem.and(bigInt.one).eq(bigInt.one)) {\n            res = F.add(res, exp);\n        }\n        exp = F.double(exp);\n        rem = rem.shiftRight(1);\n    }\n\n    return res;\n};\n*/\n\n\nexport function exp(F, base, e) {\n\n    if (Scalar.isZero(e)) return F.one;\n\n    const n = Scalar.bits(e);\n\n    if (n.length==0) return F.one;\n\n    let res = base;\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.square(res);\n\n        if (n[i]) {\n            res = F.mul(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n", "import * as Scalar from \"./scalar.js\";\n// Check here: https://eprint.iacr.org/2012/685.pdf\n\nexport default function buildSqrt (F) {\n    if ((F.m % 2) == 1) {\n        if (Scalar.eq(Scalar.mod(F.p, 4), 1 )) {\n            if (Scalar.eq(Scalar.mod(F.p, 8), 1 )) {\n                if (Scalar.eq(Scalar.mod(F.p, 16), 1 )) {\n                    // alg7_muller(F);\n                    alg5_tonelliShanks(F);\n                } else if (Scalar.eq(Scalar.mod(F.p, 16), 9 )) {\n                    alg4_kong(F);\n                } else {\n                    throw new Error(\"Field withot sqrt\");\n                }\n            } else if (Scalar.eq(Scalar.mod(F.p, 8), 5 )) {\n                alg3_atkin(F);\n            } else {\n                throw new Error(\"Field withot sqrt\");\n            }\n        } else if (Scalar.eq(Scalar.mod(F.p, 4), 3 )) {\n            alg2_shanks(F);\n        }\n    } else {\n        const pm2mod4 = Scalar.mod(Scalar.pow(F.p, F.m/2), 4);\n        if (pm2mod4 == 1) {\n            alg10_adj(F);\n        } else if (pm2mod4 == 3) {\n            alg9_adj(F);\n        } else {\n            alg8_complex(F);\n        }\n\n    }\n}\n\n\nfunction alg5_tonelliShanks(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n\n    F.sqrt_s = 0;\n    F.sqrt_t = Scalar.sub(F.sqrt_q, 1);\n\n    while (!Scalar.isOdd(F.sqrt_t)) {\n        F.sqrt_s = F.sqrt_s + 1;\n        F.sqrt_t = Scalar.div(F.sqrt_t, 2);\n    }\n\n    let c0 = F.one;\n\n    while (F.eq(c0, F.one)) {\n        const c = F.random();\n        F.sqrt_z = F.pow(c, F.sqrt_t);\n        c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s-1) );\n    }\n\n    F.sqrt_tm1d2 = Scalar.div(Scalar.sub(F.sqrt_t, 1),2);\n\n    F.sqrt = function(a) {\n        const F=this;\n        if (F.isZero(a)) return F.zero;\n        let w = F.pow(a, F.sqrt_tm1d2);\n        const a0 = F.pow( F.mul(F.square(w), a), 2 ** (F.sqrt_s-1) );\n        if (F.eq(a0, F.negone)) return null;\n\n        let v = F.sqrt_s;\n        let x = F.mul(a, w);\n        let b = F.mul(x, w);\n        let z = F.sqrt_z;\n        while (!F.eq(b, F.one)) {\n            let b2k = F.square(b);\n            let k=1;\n            while (!F.eq(b2k, F.one)) {\n                b2k = F.square(b2k);\n                k++;\n            }\n\n            w = z;\n            for (let i=0; i<v-k-1; i++) {\n                w = F.square(w);\n            }\n            z = F.square(w);\n            b = F.mul(b, z);\n            x = F.mul(x, w);\n            v = k;\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg4_kong(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 4 not implemented\");\n    };\n}\n\nfunction alg3_atkin(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 3 not implemented\");\n    };\n}\n\nfunction alg2_shanks(F) {\n\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n    F.sqrt_e1 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n\n    F.sqrt = function(a) {\n        if (this.isZero(a)) return this.zero;\n\n        // Test that have solution\n        const a1 = this.pow(a, this.sqrt_e1);\n\n        const a0 = this.mul(this.square(a1), a);\n\n        if ( this.eq(a0, this.negone) ) return null;\n\n        const x = this.mul(a1, a);\n\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg10_adj(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 10 not implemented\");\n    };\n}\n\nfunction alg9_adj(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m/2);\n    F.sqrt_e34 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n    F.sqrt_e12 = Scalar.div( Scalar.sub(F.sqrt_q, 1) , 2);\n\n    F.frobenius = function(n, x) {\n        if ((n%2) == 1) {\n            return F.conjugate(x);\n        } else {\n            return x;\n        }\n    };\n\n    F.sqrt = function(a) {\n        const F = this;\n        const a1 = F.pow(a, F.sqrt_e34);\n        const alfa = F.mul(F.square(a1), a);\n        const a0 = F.mul(F.frobenius(1, alfa), alfa);\n        if (F.eq(a0, F.negone)) return null;\n        const x0 = F.mul(a1, a);\n        let x;\n        if (F.eq(alfa, F.negone)) {\n            x = F.mul(x0, [F.F.zero, F.F.one]);\n        } else {\n            const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n            x = F.mul(b, x0);\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\n\nfunction alg8_complex(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 8 not implemented\");\n    };\n}\n", "import ChaCha from \"./chacha.js\";\nimport crypto from \"crypto\";\n\nexport function getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (process.browser) { // Browser\n        if (typeof globalThis.crypto !== \"undefined\") { // Supported\n            globalThis.crypto.getRandomValues(array);\n        } else { // fallback\n            for (let i=0; i<n; i++) {\n                array[i] = (Math.random()*4294967296)>>>0;\n            }\n        }\n    }\n    else { // NodeJS\n        crypto.randomFillSync(array);\n    }\n    return array;\n}\n\nexport function getRandomSeed() {\n    const arr = getRandomBytes(32);\n    const arrV = new Uint32Array(arr.buffer);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed.push(arrV[i]);\n    }\n    return seed;\n}\n\nlet threadRng = null;\n\nexport function getThreadRng() {\n    if (threadRng) return threadRng;\n    threadRng = new ChaCha(getRandomSeed());\n    return threadRng;\n}\n", "\n\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction quarterRound(st, a, b, c, d) {\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 16) | ((st[d]>>>16) & 0xFFFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 12) | ((st[b]>>>20) & 0xFFF)) >>> 0;\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 8) | ((st[d]>>>24) & 0xFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 7) | ((st[b]>>>25) & 0x7F)) >>> 0;\n}\n\nfunction doubleRound(st) {\n    quarterRound(st, 0, 4, 8,12);\n    quarterRound(st, 1, 5, 9,13);\n    quarterRound(st, 2, 6,10,14);\n    quarterRound(st, 3, 7,11,15);\n\n    quarterRound(st, 0, 5,10,15);\n    quarterRound(st, 1, 6,11,12);\n    quarterRound(st, 2, 7, 8,13);\n    quarterRound(st, 3, 4, 9,14);\n}\n\nexport default class ChaCha {\n\n    constructor(seed) {\n        seed = seed || [0,0,0,0,0,0,0,0];\n        this.state = [\n            0x61707865,\n            0x3320646E,\n            0x79622D32,\n            0x6B206574,\n            seed[0],\n            seed[1],\n            seed[2],\n            seed[3],\n            seed[4],\n            seed[5],\n            seed[6],\n            seed[7],\n            0,\n            0,\n            0,\n            0\n        ];\n        this.idx = 16;\n        this.buff = new Array(16);\n    }\n\n    nextU32() {\n        if (this.idx == 16) this.update();\n        return this.buff[this.idx++];\n    }\n\n    nextU64() {\n        return Scalar.add(Scalar.mul(this.nextU32(), 0x100000000), this.nextU32());\n    }\n\n    nextBool() {\n        return (this.nextU32() & 1) == 1;\n    }\n\n    update() {\n        // Copy the state\n        for (let i=0; i<16; i++) this.buff[i] = this.state[i];\n\n        // Apply the rounds\n        for (let i=0; i<10; i++) doubleRound(this.buff);\n\n        // Add to the initial\n        for (let i=0; i<16; i++) this.buff[i] = (this.buff[i] + this.state[i]) >>> 0;\n\n        this.idx = 0;\n\n        this.state[12] = (this.state[12] + 1) >>> 0;\n        if (this.state[12] != 0) return;\n        this.state[13] = (this.state[13] + 1) >>> 0;\n        if (this.state[13] != 0) return;\n        this.state[14] = (this.state[14] + 1) >>> 0;\n        if (this.state[14] != 0) return;\n        this.state[15] = (this.state[15] + 1) >>> 0;\n    }\n}\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class FFT {\n    constructor (G, F, opMulGF) {\n        this.F = F;\n        this.G = G;\n        this.opMulGF = opMulGF;\n\n        let rem = F.sqrt_t || F.t;\n        let s = F.sqrt_s || F.s;\n\n        let nqr = F.one;\n        while (F.eq(F.pow(nqr, F.half), F.one)) nqr = F.add(nqr, F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(nqr, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n        /*\n        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n        */\n        this._setRoots(Math.min(s, 15));\n    }\n\n    _setRoots(n) {\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots[i] = rootsi;\n        }\n    }\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res = __fft(this, p, bits, 0, 1);\n        return res;\n    }\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res =  __fft(this, p, bits, 0, 1);\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.opMulGF(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n    }\n\n\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.G.add(pall[offset], pall[offset + step]),\n            PF.G.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n        out[i+ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n    }\n\n    return out;\n}\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\n\nexport default class F2Field {\n    constructor(F, nonResidue) {\n        this.type=\"F2\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*2;\n        this.p = F.p;\n        this.n64 = F.n64*2;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n\n        buildSqrt(this);\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    conjugate(a) {\n        return [\n            a[0],\n            this.F.neg(a[1])\n        ];\n    }\n\n    mul(a, b) {\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n\n        return [\n            this.F.add( aA , this._mulByNonResidue(bB)),\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]),\n                    this.F.add(b[0], b[1])),\n                this.F.add(aA, bB))];\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);\n        const t1 = this.F.square(a[1]);\n        const t2 = this.F.sub(t0, this._mulByNonResidue(t1));\n        const t3 = this.F.inv(t2);\n        return [\n            this.F.mul(a[0], t3),\n            this.F.neg(this.F.mul( a[1], t3)) ];\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const ab = this.F.mul(a[0] , a[1]);\n\n        /*\n        [\n            (a + b) * (a + non_residue * b) - ab - non_residue * ab,\n            ab + ab\n        ];\n        */\n\n        return [\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]) ,\n                    this.F.add(\n                        a[0] ,\n                        this._mulByNonResidue(a[1]))),\n                this.F.add(\n                    ab,\n                    this._mulByNonResidue(ab))),\n            this.F.add(ab, ab)\n        ];\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        return [c0, c1];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        return false;\n    }\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBE(buff, o);\n        const c0 = this.F.fromRprBE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBEM(buff, o);\n        const c0 = this.F.fromRprBEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    toObject(a) {\n        return a;\n    }\n\n}\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\n\nexport default class F3Field {\n    constructor(F, nonResidue) {\n        this.type=\"F3\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*3;\n        this.p = F.p;\n        this.n64 = F.n64*3;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1]), this.F.copy(a[2])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1]),\n            this.F.add(a[2], b[2])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1]),\n            this.F.sub(a[2], b[2])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    mul(a, b) {\n\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n        const cC = this.F.mul(a[2] , b[2]);\n\n        return [\n            this.F.add(\n                aA,\n                this._mulByNonResidue(\n                    this.F.sub(\n                        this.F.mul(\n                            this.F.add(a[1], a[2]),\n                            this.F.add(b[1], b[2])),\n                        this.F.add(bB, cC)))),    // aA + non_residue*((b+c)*(B+C)-bB-cC),\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[1]),\n                        this.F.add(b[0], b[1])),\n                    this.F.add(aA, bB)),\n                this._mulByNonResidue( cC)),   // (a+b)*(A+B)-aA-bB+non_residue*cC\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[2]),\n                        this.F.add(b[0], b[2])),\n                    this.F.add(aA, cC)),\n                bB)];                           // (a+c)*(A+C)-aA+bB-cC)\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);             // t0 = a^2 ;\n        const t1 = this.F.square(a[1]);             // t1 = b^2 ;\n        const t2 = this.F.square(a[2]);             // t2 = c^2;\n        const t3 = this.F.mul(a[0],a[1]);           // t3 = ab\n        const t4 = this.F.mul(a[0],a[2]);           // t4 = ac\n        const t5 = this.F.mul(a[1],a[2]);           // t5 = bc;\n        // c0 = t0 - non_residue * t5;\n        const c0 = this.F.sub(t0, this._mulByNonResidue(t5));\n        // c1 = non_residue * t2 - t3;\n        const c1 = this.F.sub(this._mulByNonResidue(t2), t3);\n        const c2 = this.F.sub(t1, t4);              // c2 = t1-t4\n\n        // t6 = (a * c0 + non_residue * (c * c1 + b * c2)).inv();\n        const t6 =\n            this.F.inv(\n                this.F.add(\n                    this.F.mul(a[0], c0),\n                    this._mulByNonResidue(\n                        this.F.add(\n                            this.F.mul(a[2], c1),\n                            this.F.mul(a[1], c2)))));\n\n        return [\n            this.F.mul(t6, c0),         // t6*c0\n            this.F.mul(t6, c1),         // t6*c1\n            this.F.mul(t6, c2)];        // t6*c2\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const s0 = this.F.square(a[0]);                   // s0 = a^2\n        const ab = this.F.mul(a[0], a[1]);                // ab = a*b\n        const s1 = this.F.add(ab, ab);                    // s1 = 2ab;\n        const s2 = this.F.square(\n            this.F.add(this.F.sub(a[0],a[1]), a[2]));     // s2 = (a - b + c)^2;\n        const bc = this.F.mul(a[1],a[2]);                 // bc = b*c\n        const s3 = this.F.add(bc, bc);                    // s3 = 2*bc\n        const s4 = this.F.square(a[2]);                   // s4 = c^2\n\n\n        return [\n            this.F.add(\n                s0,\n                this._mulByNonResidue(s3)),           // s0 + non_residue * s3,\n            this.F.add(\n                s1,\n                this._mulByNonResidue(s4)),           // s1 + non_residue * s4,\n            this.F.sub(\n                this.F.add( this.F.add(s1, s2) , s3 ),\n                this.F.add(s0, s4))];                      // s1 + s2 + s3 - s0 - s4\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]) && this.F.isZero(a[2]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]) && this.F.eq(a[2], b[2]);\n    }\n\n    affine(a) {\n        return [this.F.affine(a[0]), this.F.affine(a[1]), this.F.affine(a[2])];\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])}, ${this.F.toString(a[2])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        return [c0, c1, c2];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        if (this.F.gt(b[1], a[1])) return false;\n        if (this.F.gt(a[2], b[2])) return true;\n        return false;\n    }\n\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n        this.F.toRprLE(buff, o+this.F.n8*2, e[2]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[2]);\n        this.F.toRprBE(buff, o+this.F.n8, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8*2, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprLEM(buff, o+this.F.n8*2, e[2]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[2]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8*2, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.n8);\n        const c2 = this.F.fromRprLE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBE(buff, o);\n        const c1 = this.F.fromRprBE(buff, o+this.n8);\n        const c0 = this.F.fromRprBE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.n8);\n        const c2 = this.F.fromRprLEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBEM(buff, o);\n        const c1 = this.F.fromRprBEM(buff, o+this.n8);\n        const c0 = this.F.fromRprBEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nimport * as fUtils from \"./futils.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction isGreatest(F, a) {\n    if (Array.isArray(a)) {\n        for (let i=a.length-1; i>=0; i--) {\n            if (!F.F.isZero(a[i])) {\n                return isGreatest(F.F, a[i]);\n            }\n        }\n        return 0;\n    } else {\n        const na = F.neg(a);\n        return Scalar.gt(a, na);\n    }\n}\n\n\nexport default class EC {\n\n    constructor(F, g) {\n        this.F = F;\n        this.g = g;\n        if (this.g.length == 2) this.g[2] = this.F.one;\n        this.zero = [this.F.zero, this.F.one, this.F.zero];\n    }\n\n    add(p1, p2) {\n\n        const F = this.F;\n\n        if (this.eq(p1, this.zero)) return p2;\n        if (this.eq(p2, this.zero)) return p1;\n\n        const res = new Array(3);\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );     // U1 = X1  * Z2Z2\n        const U2 = F.mul( p2[0] , Z1Z1 );     // U2 = X2  * Z1Z1\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);  // S1 = Y1 * Z2 * Z2Z2\n        const S2 = F.mul( p2[1] , Z1_cubed);  // S2 = Y2 * Z1 * Z1Z1\n\n        if (F.eq(U1,U2) && F.eq(S1,S2)) {\n            return this.double(p1);\n        }\n\n        const H = F.sub( U2 , U1 );                    // H = U2-U1\n\n        const S2_minus_S1 = F.sub( S2 , S1 );\n\n        const I = F.square( F.add(H,H) );         // I = (2 * H)^2\n        const J = F.mul( H , I );                      // J = H * I\n\n        const r = F.add( S2_minus_S1 , S2_minus_S1 );  // r = 2 * (S2-S1)\n        const V = F.mul( U1 , I );                     // V = U1 * I\n\n        res[0] =\n            F.sub(\n                F.sub( F.square(r) , J ),\n                F.add( V , V ));                       // X3 = r^2 - J - 2 * V\n\n        const S1_J = F.mul( S1 , J );\n\n        res[1] =\n            F.sub(\n                F.mul( r , F.sub(V,res[0])),\n                F.add( S1_J,S1_J ));                   // Y3 = r * (V-X3)-2 S1 J\n\n        res[2] =\n            F.mul(\n                H,\n                F.sub(\n                    F.square( F.add(p1[2],p2[2]) ),\n                    F.add( Z1Z1 , Z2Z2 )));            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2) * H\n\n        return res;\n    }\n\n    neg(p) {\n        return [p[0], this.F.neg(p[1]), p[2]];\n    }\n\n    sub(a, b) {\n        return this.add(a, this.neg(b));\n    }\n\n    double(p) {\n        const F = this.F;\n\n        const res = new Array(3);\n\n        if (this.eq(p, this.zero)) return p;\n\n        const A = F.square( p[0] );                    // A = X1^2\n        const B = F.square( p[1] );                    // B = Y1^2\n        const C = F.square( B );                       // C = B^2\n\n        let D =\n            F.sub(\n                F.square( F.add(p[0] , B )),\n                F.add( A , C));\n        D = F.add(D,D);                    // D = 2 * ((X1 + B)^2 - A - C)\n\n        const E = F.add( F.add(A,A), A);          // E = 3 * A\n        const FF =F.square( E );                       // F = E^2\n\n        res[0] = F.sub( FF , F.add(D,D) );         // X3 = F - 2 D\n\n        let eightC = F.add( C , C );\n        eightC = F.add( eightC , eightC );\n        eightC = F.add( eightC , eightC );\n\n        res[1] =\n            F.sub(\n                F.mul(\n                    E,\n                    F.sub( D, res[0] )),\n                eightC);                                    // Y3 = E * (D - X3) - 8 * C\n\n        const Y1Z1 = F.mul( p[1] , p[2] );\n        res[2] = F.add( Y1Z1 , Y1Z1 );                 // Z3 = 2 * Y1 * Z1\n\n        return res;\n    }\n\n    timesScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    affine(p) {\n        const F = this.F;\n        if (this.isZero(p)) {\n            return this.zero;\n        } else if (F.eq(p[2], F.one)) {\n            return p;\n        } else {\n            const Z_inv = F.inv(p[2]);\n            const Z2_inv = F.square(Z_inv);\n            const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n            const res = new Array(3);\n            res[0] = F.mul(p[0],Z2_inv);\n            res[1] = F.mul(p[1],Z3_inv);\n            res[2] = F.one;\n\n            return res;\n        }\n    }\n\n    multiAffine(arr) {\n        const keys = Object.keys(arr);\n        const F = this.F;\n        const accMul = new Array(keys.length+1);\n        accMul[0] = F.one;\n        for (let i = 0; i< keys.length; i++) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i+1] = accMul[i];\n            } else {\n                accMul[i+1] = F.mul(accMul[i], arr[keys[i]][2]);\n            }\n        }\n\n        accMul[keys.length] = F.inv(accMul[keys.length]);\n\n        for (let i = keys.length-1; i>=0; i--) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i] = accMul[i+1];\n                arr[keys[i]] = this.zero;\n            } else {\n                const Z_inv = F.mul(accMul[i], accMul[i+1]);\n                accMul[i] = F.mul(arr[keys[i]][2], accMul[i+1]);\n\n                const Z2_inv = F.square(Z_inv);\n                const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n                arr[keys[i]][0] = F.mul(arr[keys[i]][0],Z2_inv);\n                arr[keys[i]][1] = F.mul(arr[keys[i]][1],Z3_inv);\n                arr[keys[i]][2] = F.one;\n            }\n        }\n\n    }\n\n    eq(p1, p2) {\n        const F = this.F;\n\n        if (this.F.eq(p1[2], this.F.zero)) return this.F.eq(p2[2], this.F.zero);\n        if (this.F.eq(p2[2], this.F.zero)) return false;\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );\n        const U2 = F.mul( p2[0] , Z1Z1 );\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);\n        const S2 = F.mul( p2[1] , Z1_cubed);\n\n        return (F.eq(U1,U2) && F.eq(S1,S2));\n    }\n\n    isZero(p) {\n        return this.F.isZero(p[2]);\n    }\n\n    toString(p) {\n        const cp = this.affine(p);\n        return `[ ${this.F.toString(cp[0])} , ${this.F.toString(cp[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n            P[1] = F.sqrt(x3b);\n        } while ((P[1] == null)||(F.isZero[P]));\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        if (this.cofactor) {\n            P = this.mulScalar(P, this.cofactor);\n        }\n\n        P = this.affine(P);\n\n        return P;\n\n    }\n\n    toRprLE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLE(buff, o, p[0]);\n        this.F.toRprLE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprBE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n        this.F.toRprBE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEJM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n        this.F.toRprLEM(buff, o+2*this.F.n8, p[2]);\n    }\n\n\n    toRprBEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBEM(buff, o, p[0]);\n        this.F.toRprBEM(buff, o+this.F.n8, p[1]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLE(buff, o);\n        const y = this.F.fromRprLE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBE(buff, o);\n        const y = this.F.fromRprBE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEJM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        const z = this.F.fromRprLEM(buff, o+this.F.n8*2);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, z];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBEM(buff, o);\n        const y = this.F.fromRprBEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprCompressed(buff, o) {\n        const F = this.F;\n        const v = new Uint8Array(buff.buffer, o, F.n8);\n        if (v[0] & 0x40) return this.zero;\n        const P = new Array(3);\n\n        const greatest = ((v[0] & 0x80) != 0);\n        v[0] = v[0] & 0x7F;\n        P[0] = F.fromRprBE(buff, o);\n        if (greatest) v[0] = v[0] | 0x80;  // set back again the old value\n\n        const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        P[1] = F.sqrt(x3b);\n\n        if (P[1] === null) {\n            throw new Error(\"Invalid Point!\");\n        }\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        return P;\n    }\n\n    toRprCompressed(buff, o, p) {\n        p = this.affine(p);\n        const v = new Uint8Array(buff.buffer, o, this.F.n8);\n        if (this.isZero(p)) {\n            v.fill(0);\n            v[0] = 0x40;\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n\n        if (isGreatest(this.F, p[1])) {\n            v[0] = v[0] | 0x80;\n        }\n    }\n\n\n    fromRprUncompressed(buff, o) {\n        if (buff[0] & 0x40) return this.zero;\n\n        return this.fromRprBE(buff, o);\n    }\n\n    toRprUncompressed(buff, o, p) {\n        this.toRprBE(buff, o, p);\n\n        if (this.isZero(p)) {\n            buff[o] = buff[o] | 0x40;\n        }\n    }\n\n\n}\n\n\n", "import { buildBn128 as buildBn128wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bn128 = null;\n\nexport default async function buildBn128(singleThread, plugins) {\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBn128wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bn128wasm = {};\n\n    bn128wasm.code = moduleBuilder.build();\n    bn128wasm.pq = moduleBuilder.modules.f1m.pq;\n    bn128wasm.pr = moduleBuilder.modules.frm.pq;\n    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;\n    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;\n    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;\n    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;\n    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;\n    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;\n    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;\n    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;\n    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;\n    bn128wasm.n8q = 32;\n    bn128wasm.n8r = 32;\n    bn128wasm.q = moduleBuilder.modules.bn128.q;\n    bn128wasm.r = moduleBuilder.modules.bn128.r;\n\n    if ((!singleThread) && (globalThis.curve_bn128)) return globalThis.curve_bn128;\n    const params = {\n        name: \"bn128\",\n        wasm: bn128wasm,\n        q: Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\"),\n        r: Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\"),\n        n8q: 32,\n        n8r: 32,\n        cofactorG2: Scalar.e(\"30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bn128 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bn128 = curve;\n    }\n\n    return curve;\n}\n\n", "import WasmField1 from \"./wasm_field1.js\";\nimport WasmField2 from \"./wasm_field2.js\";\nimport WasmField3 from \"./wasm_field3.js\";\nimport WasmCurve from \"./wasm_curve.js\";\nimport buildThreadManager from \"./threadman.js\";\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchApplyKey from \"./engine_applykey.js\";\nimport buildPairing from \"./engine_pairing.js\";\nimport buildMultiExp from \"./engine_multiexp.js\";\nimport buildFFT from \"./engine_fft.js\";\n\nexport default async function buildEngine(params) {\n\n    const tm = await buildThreadManager(params.wasm, params.singleThread);\n\n\n    const curve = {};\n\n    curve.q = Scalar.e(params.wasm.q.toString());\n    curve.r = Scalar.e(params.wasm.r.toString());\n    curve.name = params.name;\n    curve.tm = tm;\n    curve.prePSize = params.wasm.prePSize;\n    curve.preQSize = params.wasm.preQSize;\n    curve.Fr = new WasmField1(tm, \"frm\", params.n8r, params.r);\n    curve.F1 = new WasmField1(tm, \"f1m\", params.n8q, params.q);\n    curve.F2 = new WasmField2(tm, \"f2m\", curve.F1);\n    curve.G1 = new WasmCurve(tm, \"g1m\", curve.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);\n    curve.G2 = new WasmCurve(tm, \"g2m\", curve.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);\n    curve.F6 = new WasmField3(tm, \"f6m\", curve.F2);\n    curve.F12 = new WasmField2(tm, \"ftm\", curve.F6);\n\n    curve.Gt = curve.F12;\n\n    buildBatchApplyKey(curve, \"G1\");\n    buildBatchApplyKey(curve, \"G2\");\n    buildBatchApplyKey(curve, \"Fr\");\n\n    buildMultiExp(curve, \"G1\");\n    buildMultiExp(curve, \"G2\");\n\n    buildFFT(curve, \"G1\");\n    buildFFT(curve, \"G2\");\n    buildFFT(curve, \"Fr\");\n\n    buildPairing(curve);\n\n    curve.array2buffer = function(arr, sG) {\n        const buff = new Uint8Array(sG*arr.length);\n\n        for (let i=0; i<arr.length; i++) {\n            buff.set(arr[i], i*sG);\n        }\n\n        return buff;\n    };\n\n    curve.buffer2array = function(buff , sG) {\n        const n= buff.byteLength / sG;\n        const arr = new Array(n);\n        for (let i=0; i<n; i++) {\n            arr[i] = buff.slice(i*sG, i*sG+sG);\n        }\n        return arr;\n    };\n\n    return curve;\n}\n\n\n", "import * as Scalar from \"./scalar.js\";\nimport * as utils from \"./utils.js\";\nimport { getThreadRng } from \"./random.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default class WasmField1 {\n\n    constructor(tm, prefix, n8, p) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.p = p;\n        this.n8 = n8;\n        this.type = \"F1\";\n        this.m = 1;\n\n        this.half = Scalar.shiftRight(p, Scalar.one);\n        this.bitLength = Scalar.bitLength(p);\n        this.mask = Scalar.sub(Scalar.shiftLeft(Scalar.one, this.bitLength), Scalar.one);\n\n        this.pOp1 = tm.alloc(n8);\n        this.pOp2 = tm.alloc(n8);\n        this.pOp3 = tm.alloc(n8);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = this.tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.n64 = Math.floor(n8/8);\n        this.n32 = Math.floor(n8/4);\n\n        if(this.n64*8 != this.n8) {\n            throw new Error(\"n8 must be a multiple of 8\");\n        }\n\n        this.half = Scalar.shiftRight(this.p, Scalar.one);\n        this.nqr = this.two;\n        let r = this.exp(this.nqr, this.half);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.add(this.nqr, this.one);\n            r = this.exp(this.nqr, this.half);\n        }\n\n        this.shift = this.mul(this.nqr, this.nqr);\n        this.shiftInv = this.inv(this.shift);\n\n        this.s = 0;\n        let t = Scalar.sub(this.p, Scalar.one);\n\n        while ( !Scalar.isOdd(t) ) {\n            this.s = this.s + 1;\n            t = Scalar.shiftRight(t, Scalar.one);\n        }\n\n        this.w = [];\n        this.w[this.s] = this.exp(this.nqr, t);\n\n        for (let i= this.s-1; i>=0; i--) {\n            this.w[i] = this.square(this.w[i+1]);\n        }\n\n        if (!this.eq(this.w[0], this.one)) {\n            throw new Error(\"Error calculating roots of unity\");\n        }\n\n        this.batchToMontgomery = buildBatchConvert(tm, prefix + \"_batchToMontgomery\", this.n8, this.n8);\n        this.batchFromMontgomery = buildBatchConvert(tm, prefix + \"_batchFromMontgomery\", this.n8, this.n8);\n    }\n\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        let ra = Scalar.e(a, b);\n        if (Scalar.isNegative(ra)) {\n            ra = Scalar.neg(ra);\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n            ra = Scalar.sub(this.p, ra);\n        } else {\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n        }\n        const buff = utils.leInt2Buff(ra, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toString(a, radix) {\n        const an = this.fromMontgomery(a);\n        const s = Scalar.fromRprLE(an, 0);\n        return Scalar.toString(s, radix);\n    }\n\n    fromRng(rng) {\n        let v;\n        const buff = new Uint8Array(this.n8);\n        do {\n            v = Scalar.zero;\n            for (let i=0; i<this.n64; i++) {\n                v = Scalar.add(v,  Scalar.shiftLeft(rng.nextU64(), 64*i));\n            }\n            v = Scalar.band(v, this.mask);\n        } while (Scalar.geq(v, this.p));\n        Scalar.toRprLE(buff, 0, v, this.n8);\n        return buff;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const an = this.fromMontgomery(a);\n        return Scalar.fromRprLE(an, 0);\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.n8);\n        Scalar.toRprLE(buff, 0, a, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toRprLE(buff, offset, a) {\n        buff.set(this.fromMontgomery(a), offset);\n    }\n\n    toRprBE(buff, offset, a) {\n        const buff2 = this.fromMontgomery(a);\n        for (let i=0; i<this.n8/2; i++) {\n            const aux = buff2[i];\n            buff2[i] = buff2[this.n8-1-i];\n            buff2[this.n8-1-i] = aux;\n        }\n        buff.set(buff2, offset);\n    }\n\n    fromRprLE(buff, offset) {\n        offset = offset || 0;\n        const res = buff.slice(offset, offset + this.n8);\n        return this.toMontgomery(res);\n    }\n\n    async batchInverse(buffIn) {\n        let returnArray = false;\n        const sIn = this.n8;\n        const sOut = this.n8;\n\n        if (Array.isArray(buffIn)) {\n            buffIn = utils.array2buffer(buffIn, sIn );\n            returnArray = true;\n        } else {\n            buffIn = buffIn.slice(0, buffIn.byteLength);\n        }\n\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/this.tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<this.tm.concurrency; i++) {\n            let n;\n            if (i< this.tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: this.prefix + \"_batchInverse\", params: [\n                    {var: 0},\n                    {val: sIn},\n                    {val: n},\n                    {var: 1},\n                    {val: sOut},\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                this.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        if (returnArray) {\n            return utils.buffer2array(fullBuffOut, sOut);\n        } else {\n            return fullBuffOut;\n        }\n\n    }\n\n}\n\n\n", "/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\n\nexport function stringifyBigInts(o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return Scalar.fromRprLE(o, 0);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigInts);\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyBigInts(o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return BigInt(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return BigInt(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyBigInts);\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function beBuff2int(buff) {\n    let res = BigInt(0);\n    let i = buff.length;\n    let offset = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i > 0) {\n        if (i >= 4) {\n            i -= 4;\n            res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);\n            offset += 4;\n        } else if (i >= 2) {\n            i -= 2;\n            res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);\n            offset += 2;\n        } else {\n            i -= 1;\n            res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);\n            offset += 1;\n        }\n    }\n    return res;\n}\n\nexport function beInt2Buff(n, len) {\n    let r = n;\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = len;\n    while (o > 0) {\n        if (o - 4 >= 0) {\n            o -= 4;\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)));\n            r = r >> BigInt(32);\n        } else if (o - 2 >= 0) {\n            o -= 2;\n            buffV.setUint16(o, Number(r & BigInt(0xffff)));\n            r = r >> BigInt(16);\n        } else {\n            o -= 1;\n            buffV.setUint8(o, Number(r & BigInt(0xff)));\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function leBuff2int(buff) {\n    let res = BigInt(0);\n    let i = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i < buff.length) {\n        if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);\n            i += 4;\n        } else if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);\n            i += 2;\n        } else {\n            res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);\n            i += 1;\n        }\n    }\n    return res;\n}\n\nexport function leInt2Buff(n, len) {\n    let r = n;\n    if (typeof len === \"undefined\") {\n        len = Math.floor((Scalar.bitLength(n) - 1) / 8) + 1;\n        if (len == 0) len = 1;\n    }\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = 0;\n    while (o < len) {\n        if (o + 4 <= len) {\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)), true);\n            o += 4;\n            r = r >> BigInt(32);\n        } else if (o + 2 <= len) {\n            buffV.setUint16(Number(o, r & BigInt(0xffff)), true);\n            o += 2;\n            r = r >> BigInt(16);\n        } else {\n            buffV.setUint8(Number(o, r & BigInt(0xff)), true);\n            o += 1;\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function stringifyFElements(F, o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return F.toString(F.e(o));\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyFElements(F, o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return F.e(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return F.e(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nconst _revTable = [];\nfor (let i = 0; i < 256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res = 0;\n    let a = idx;\n    for (let i = 0; i < bits; i++) {\n        res <<= 1;\n        res = res | (a & 1);\n        a >>= 1;\n    }\n    return res;\n}\n\nexport function bitReverse(idx, bits) {\n    return (\n        (_revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xff] << 8) |\n        (_revTable[(idx >>> 8) & 0xff] << 16) |\n        (_revTable[idx & 0xff] << 24)) >>>\n        (32 - bits)\n    );\n}\n\nexport function log2(V) {\n    return (\n        ((V & 0xffff0000) !== 0 ? ((V &= 0xffff0000), 16) : 0) |\n        ((V & 0xff00ff00) !== 0 ? ((V &= 0xff00ff00), 8) : 0) |\n        ((V & 0xf0f0f0f0) !== 0 ? ((V &= 0xf0f0f0f0), 4) : 0) |\n        ((V & 0xcccccccc) !== 0 ? ((V &= 0xcccccccc), 2) : 0) |\n        ((V & 0xaaaaaaaa) !== 0)\n    );\n}\n\nexport function buffReverseBits(buff, eSize) {\n    const n = buff.byteLength / eSize;\n    const bits = log2(n);\n    if (n != 1 << bits) {\n        throw new Error(\"Invalid number of pointers\");\n    }\n    for (let i = 0; i < n; i++) {\n        const r = bitReverse(i, bits);\n        if (i > r) {\n            const tmp = buff.slice(i * eSize, (i + 1) * eSize);\n            buff.set(buff.slice(r * eSize, (r + 1) * eSize), i * eSize);\n            buff.set(tmp, r * eSize);\n        }\n    }\n}\n\nexport function array2buffer(arr, sG) {\n    const buff = new Uint8Array(sG * arr.length);\n\n    for (let i = 0; i < arr.length; i++) {\n        buff.set(arr[i], i * sG);\n    }\n\n    return buff;\n}\n\nexport function buffer2array(buff, sG) {\n    const n = buff.byteLength / sG;\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = buff.slice(i * sG, i * sG + sG);\n    }\n    return arr;\n}\n", "import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchConvert(tm, fnName, sIn, sOut) {\n    return async function batchConvert(buffIn) {\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1}\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n", "\nconst PAGE_SIZE = 1<<30;\n\nexport default class BigBuffer {\n\n    constructor(size) {\n        this.buffers = [];\n        this.byteLength = size;\n        for (let i=0; i<size; i+= PAGE_SIZE) {\n            const n = Math.min(size-i, PAGE_SIZE);\n            this.buffers.push(new Uint8Array(n));\n        }\n\n    }\n\n    slice(fr, to) {\n        if ( to === undefined ) to = this.byteLength;\n        if ( fr === undefined ) fr = 0;\n        const len = to-fr;\n\n        const firstPage = Math.floor(fr / PAGE_SIZE);\n        const lastPage = Math.floor((fr+len-1) / PAGE_SIZE);\n\n        if ((firstPage == lastPage)||(len==0))\n            return this.buffers[firstPage].slice(fr%PAGE_SIZE, fr%PAGE_SIZE + len);\n\n        let buff;\n\n        let p = firstPage;\n        let o = fr % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset+o, l);\n            if (l == len) return srcView.slice();\n            if (!buff) {\n                if (len <= PAGE_SIZE) {\n                    buff = new Uint8Array(len);\n                } else {\n                    buff = new BigBuffer(len);\n                }\n            }\n            buff.set(srcView, len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        return buff;\n    }\n\n    set(buff, offset) {\n        if (offset === undefined) offset = 0;\n\n        const len = buff.byteLength;\n\n        if (len==0) return;\n\n        const firstPage = Math.floor(offset / PAGE_SIZE);\n        const lastPage = Math.floor((offset+len-1) / PAGE_SIZE);\n\n        if (firstPage == lastPage) {\n            if ((buff instanceof BigBuffer)&&(buff.buffers.length==1)) {\n                return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);\n            } else {\n                return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);\n            }\n\n        }\n\n\n        let p = firstPage;\n        let o = offset % PAGE_SIZE;\n        let r = len;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice( len -r, len -r+l);\n            const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n    }\n}\n", "import { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField2 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F2\";\n        this.m = F.m * 2;\n        this.n8 = this.F.n8*2;\n        this.n32 = this.F.n32*2;\n        this.n64 = this.F.n64*2;\n\n        this.pOp1 = tm.alloc(F.n8*2);\n        this.pOp2 = tm.alloc(F.n8*2);\n        this.pOp3 = tm.alloc(F.n8*2);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    mul1(a,b) {\n        return this.op2(\"_mul1\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 2)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const res = new Uint8Array(this.F.n8*2);\n            res.set(c1);\n            res.set(c2, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F2\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8), radix);\n        return `[${s1}, ${s2}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*2);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        return [c1, c2];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8);\n    }\n\n}\n\n", "\n\nimport { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField3 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F3\";\n        this.m = F.m * 3;\n        this.n8 = this.F.n8*3;\n        this.n32 = this.F.n32*3;\n        this.n64 = this.F.n64*3;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 3)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const c3 = this.F.e(a[2], b);\n            const res = new Uint8Array(this.F.n8*3);\n            res.set(c1);\n            res.set(c2, this.F.n8);\n            res.set(c3, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F3\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n        const s3 = this.F.toString(a.slice(this.F.n8*2), radix);\n        return `[${s1}, ${s2}, ${s3}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const c3 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*3);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        res.set(c3, this.F.n8*2);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        const c3 = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        return [c1, c2, c3];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*3);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        const b3 = this.F.fromObject(a[2]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        buff.set(b3, this.F.n8*2);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8, this.F.n8*2);\n    }\n\n    c3(a) {\n        return a.slice(this.F.n8*2);\n    }\n\n}\n\n\n", "\n\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\n\nexport default class WasmCurve {\n\n    constructor(tm, prefix, F, pGen, pGb, cofactor) {\n        this.tm = tm;\n        this.prefix = prefix;\n        this.F = F;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, F.n8*3);\n        this.tm.instance.exports[prefix + \"_zeroAffine\"](this.pOp1);\n        this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8*2);\n        this.one = this.tm.getBuff(pGen, F.n8*3);\n        this.g = this.one;\n        this.oneAffine = this.tm.getBuff(pGen, F.n8*2);\n        this.gAffine = this.oneAffine;\n        this.b = this.tm.getBuff(pGb, F.n8);\n\n        if (cofactor) {\n            this.cofactor = Scalar.toLEBuff(cofactor);\n        }\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.batchLEMtoC = buildBatchConvert(tm, prefix + \"_batchLEMtoC\", F.n8*2, F.n8);\n        this.batchLEMtoU = buildBatchConvert(tm, prefix + \"_batchLEMtoU\", F.n8*2, F.n8*2);\n        this.batchCtoLEM = buildBatchConvert(tm, prefix + \"_batchCtoLEM\", F.n8, F.n8*2);\n        this.batchUtoLEM = buildBatchConvert(tm, prefix + \"_batchUtoLEM\", F.n8*2, F.n8*2);\n        this.batchToJacobian = buildBatchConvert(tm, prefix + \"_batchToJacobian\", F.n8*2, F.n8*3);\n        this.batchToAffine = buildBatchConvert(tm, prefix + \"_batchToAffine\", F.n8*3, F.n8*2);\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op2bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op1Affine(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*2);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_add\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_addMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    sub(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_sub\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_subMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    neg(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_neg\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Affine(\"_negAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    double(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_double\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_doubleAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isZero(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Bool(\"_isZero\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Bool(\"_isZeroAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    timesScalar(a, s) {\n        if (!(s instanceof Uint8Array)) {\n            s = Scalar.toLEBuff(Scalar.e(s));\n        }\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesScalar\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesScalarAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    timesFr(a, s) {\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesFr\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesFrAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    eq(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eq\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eqMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toAffine(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Affine(\"_toAffine\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return a;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toJacobian(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return a;\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_toJacobian\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toRprUncompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoU\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n        arr.set(res, offset);\n    }\n\n    fromRprUncompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8*2);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_UtoLEM\"](this.pOp1, this.pOp1);\n        return this.tm.getBuff(this.pOp1, this.F.n8*2);\n    }\n\n    toRprCompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoC\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8);\n        arr.set(res, offset);\n    }\n\n    fromRprCompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_CtoLEM\"](this.pOp1, this.pOp2);\n        return this.tm.getBuff(this.pOp2, this.F.n8*2);\n    }\n\n    toUncompressed(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        this.toRprUncompressed(buff, 0, a);\n        return buff;\n    }\n\n    toRprLEM(arr, offset, a) {\n        if (a.byteLength == this.F.n8*2) {\n            arr.set(a, offset);\n            return;\n        } else if (a.byteLength == this.F.n8*3) {\n            this.tm.setBuff(this.pOp1, a);\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n            const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n            arr.set(res, offset);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    fromRprLEM(arr, offset) {\n        offset = offset || 0;\n        return arr.slice(offset, offset+this.F.n8*2);\n    }\n\n    toString(a, radix) {\n        if (a.byteLength == this.F.n8*3) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n            const z = this.F.toString(a.slice(this.F.n8*2), radix);\n            return `[ ${x}, ${y}, ${z} ]`;\n        } else if (a.byteLength == this.F.n8*2) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8), radix);\n            return `[ ${x}, ${y} ]`;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isValid(a) {\n        if (this.isZero(a)) return true;\n        const F = this.F;\n        const aa = this.toAffine(a);\n        const x = aa.slice(0, this.F.n8);\n        const y = aa.slice(this.F.n8, this.F.n8*2);\n        const x3b = F.add(F.mul(F.square(x),x), this.b);\n        const y2 = F.square(y);\n        return F.eq(x3b, y2);\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        let x3b;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        } while (!F.isSquare(x3b));\n\n        P[1] = F.sqrt(x3b);\n\n        const s = F.isNegative(P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n\n        let Pbuff = new Uint8Array(this.F.n8*2);\n        Pbuff.set(P[0]);\n        Pbuff.set(P[1], this.F.n8);\n\n        if (this.cofactor) {\n            Pbuff = this.timesScalar(Pbuff, this.cofactor);\n        }\n\n        return Pbuff;\n    }\n\n\n\n    toObject(a) {\n        if (this.isZero(a)) {\n            return [\n                this.F.toObject(this.F.zero),\n                this.F.toObject(this.F.one),\n                this.F.toObject(this.F.zero),\n            ];\n        }\n        const x = this.F.toObject(a.slice(0, this.F.n8));\n        const y = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        let z;\n        if (a.byteLength == this.F.n8*3) {\n            z = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        } else {\n            z = this.F.toObject(this.F.one);\n        }\n        return [x, y, z];\n    }\n\n    fromObject(a) {\n        const x = this.F.fromObject(a[0]);\n        const y = this.F.fromObject(a[1]);\n        let z;\n        if (a.length==3) {\n            z = this.F.fromObject(a[2]);\n        } else {\n            z = this.F.one;\n        }\n        if (this.F.isZero(z, this.F.one)) {\n            return this.zeroAffine;\n        } else if (this.F.eq(z, this.F.one)) {\n            const buff = new Uint8Array(this.F.n8*2);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            return buff;\n        } else {\n            const buff = new Uint8Array(this.F.n8*3);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            buff.set(z, this.F.n8*2);\n            return buff;\n        }\n    }\n\n    e(a) {\n        if (a instanceof Uint8Array) return a;\n        return this.fromObject(a);\n    }\n\n    x(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(0, this.F.n8);\n    }\n\n    y(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(this.F.n8);\n    }\n\n}\n\n\n", "/* global navigator, WebAssembly */\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// const MEM_SIZE = 1000;  // Memory size in 64K Pakes (512Mb)\nconst MEM_SIZE = 25;  // Memory size in 64K Pakes (1600Kb)\n\n\nimport thread from \"./threadman_thread.js\";\nimport os from \"os\";\nimport Worker from \"web-worker\";\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject)=> {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction stringToBase64(str) {\n    if (process.browser) {\n        return globalThis.btoa(str);\n    } else {\n        return Buffer.from(str).toString(\"base64\");\n    }\n}\n\nconst threadSource = stringToBase64(\"(\" + thread.toString() + \")(self)\");\nconst workerSource = \"data:application/javascript;base64,\" + threadSource;\n\n\n\nexport default async function buildThreadManager(wasm, singleThread) {\n    const tm = new ThreadManager();\n\n    tm.memory = new WebAssembly.Memory({initial:MEM_SIZE});\n    tm.u8 = new Uint8Array(tm.memory.buffer);\n    tm.u32 = new Uint32Array(tm.memory.buffer);\n\n    const wasmModule = await WebAssembly.compile(wasm.code);\n\n    tm.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": tm.memory\n        }\n    });\n\n    tm.singleThread = singleThread;\n    tm.initalPFree = tm.u32[0];   // Save the Pointer to free space.\n    tm.pq = wasm.pq;\n    tm.pr = wasm.pr;\n    tm.pG1gen = wasm.pG1gen;\n    tm.pG1zero = wasm.pG1zero;\n    tm.pG2gen = wasm.pG2gen;\n    tm.pG2zero = wasm.pG2zero;\n    tm.pOneT = wasm.pOneT;\n\n    //    tm.pTmp0 = tm.alloc(curve.G2.F.n8*3);\n    //    tm.pTmp1 = tm.alloc(curve.G2.F.n8*3);\n\n\n    if (singleThread) {\n        tm.code = wasm.code;\n        tm.taskManager = thread();\n        await tm.taskManager([{\n            cmd: \"INIT\",\n            init: MEM_SIZE,\n            code: tm.code.slice()\n        }]);\n        tm.concurrency  = 1;\n    } else {\n        tm.workers = [];\n        tm.pendingDeferreds = [];\n        tm.working = [];\n\n        let concurrency;\n\n        if ((typeof(navigator) === \"object\") && navigator.hardwareConcurrency) {\n            concurrency = navigator.hardwareConcurrency;\n        } else {\n            concurrency = os.cpus().length;\n        }\n\n        if(concurrency == 0){\n            concurrency = 2;\n        }\n\n        // Limit to 64 threads for memory reasons.\n        if (concurrency>64) concurrency=64;\n        tm.concurrency = concurrency;\n\n        for (let i = 0; i<concurrency; i++) {\n\n            tm.workers[i] = new Worker(workerSource);\n\n            tm.workers[i].addEventListener(\"message\", getOnMsg(i));\n\n            tm.working[i]=false;\n        }\n\n        const initPromises = [];\n        for (let i=0; i<tm.workers.length;i++) {\n            const copyCode = wasm.code.slice();\n            initPromises.push(tm.postAction(i, [{\n                cmd: \"INIT\",\n                init: MEM_SIZE,\n                code: copyCode\n            }], [copyCode.buffer]));\n        }\n\n        await Promise.all(initPromises);\n\n    }\n    return tm;\n\n    function getOnMsg(i) {\n        return function(e) {\n            let data;\n            if ((e)&&(e.data)) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            tm.working[i]=false;\n            tm.pendingDeferreds[i].resolve(data);\n            tm.processWorks();\n        };\n    }\n\n}\n\nclass ThreadManager {\n    constructor() {\n        this.actionQueue = [];\n        this.oldPFree = 0;\n    }\n\n    startSyncOp() {\n        if (this.oldPFree != 0) throw new Error(\"Sync operation in progress\");\n        this.oldPFree = this.u32[0];\n    }\n\n    endSyncOp() {\n        if (this.oldPFree == 0) throw new Error(\"No sync operation in progress\");\n        this.u32[0] = this.oldPFree;\n        this.oldPFree = 0;\n    }\n\n    postAction(workerId, e, transfers, _deferred) {\n        if (this.working[workerId]) {\n            throw new Error(\"Posting a job t a working worker\");\n        }\n        this.working[workerId] = true;\n\n        this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();\n        this.workers[workerId].postMessage(e, transfers);\n\n        return this.pendingDeferreds[workerId].promise;\n    }\n\n    processWorks() {\n        for (let i=0; (i<this.workers.length)&&(this.actionQueue.length > 0); i++) {\n            if (this.working[i] == false) {\n                const work = this.actionQueue.shift();\n                this.postAction(i, work.data, work.transfers, work.deferred);\n            }\n        }\n    }\n\n    queueAction(actionData, transfers) {\n        const d = new Deferred();\n\n        if (this.singleThread) {\n            const res = this.taskManager(actionData);\n            d.resolve(res);\n        } else {\n            this.actionQueue.push({\n                data: actionData,\n                transfers: transfers,\n                deferred: d\n            });\n            this.processWorks();\n        }\n        return d.promise;\n    }\n\n    resetMemory() {\n        this.u32[0] = this.initalPFree;\n    }\n\n    allocBuff(buff) {\n        const pointer = this.alloc(buff.byteLength);\n        this.setBuff(pointer, buff);\n        return pointer;\n    }\n\n    getBuff(pointer, length) {\n        return this.u8.slice(pointer, pointer+ length);\n    }\n\n    setBuff(pointer, buffer) {\n        this.u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    alloc(length) {\n        while (this.u32[0] & 3) this.u32[0]++;  // Return always aligned pointers\n        const res = this.u32[0];\n        this.u32[0] += length;\n        return res;\n    }\n\n    async terminate() {\n        for (let i=0; i<this.workers.length; i++) {\n            this.workers[i].postMessage([{cmd: \"TERMINATE\"}]);\n        }\n        await sleep(200);\n    }\n\n}\n", "/* global WebAssembly */\n\nexport default function thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == \"INIT\") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == \"TERMINATE\") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == \"INIT\") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case \"ALLOCSET\":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case \"ALLOC\":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case \"SET\":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case \"CALL\": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== \"undefined\") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != \"undefined\") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case \"GET\":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error(\"Invalid cmd\");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}\n", "import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchApplyKey(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = curve.tm;\n\n    curve[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        let fnName, fnAffine;\n        let sGin, sGmid, sGout;\n        if (groupName == \"G1\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g1m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g1m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g1m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g2m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g2m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g2m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_batchApplyKey\";\n            sGin = G.n8;\n            sGmid = G.n8;\n            sGout = G.n8;\n        } else {\n            throw new Error(\"Invalid group: \" + groupName);\n        }\n        const nPoints = Math.floor(buff.byteLength / sGin);\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        inc = Fr.e(inc);\n        let t = Fr.e(first);\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({\n                cmd: \"ALLOCSET\",\n                var: 0,\n                buff: buff.slice(i*pointsPerChunk*sGin, i*pointsPerChunk*sGin + n*sGin)\n            });\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: t});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: inc});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*Math.max(sGmid, sGout)});\n            task.push({\n                cmd: \"CALL\",\n                fnName: fnName,\n                params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1},\n                    {var: 2},\n                    {var:3}\n                ]\n            });\n            if (fnAffine) {\n                task.push({\n                    cmd: \"CALL\",\n                    fnName: fnAffine,\n                    params: [\n                        {var: 3},\n                        {val: n},\n                        {var: 3},\n                    ]\n                });\n            }\n            task.push({cmd: \"GET\", out: 0, var: 3, len: n*sGout});\n\n            opPromises.push(tm.queueAction(task));\n            t = Fr.mul(t, Fr.exp(inc, n));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let outBuff;\n        if (buff instanceof BigBuffer) {\n            outBuff = new BigBuffer(nPoints*sGout);\n        } else {\n            outBuff = new Uint8Array(nPoints*sGout);\n        }\n\n        let p=0;\n        for (let i=0; i<result.length; i++) {\n            outBuff.set(result[i][0], p);\n            p += result[i][0].byteLength;\n        }\n\n        return outBuff;\n    };\n}\n", "\nexport default function buildPairing(curve) {\n    const tm = curve.tm;\n    curve.pairing = function pairing(a, b) {\n\n        tm.startSyncOp();\n        const pA = tm.allocBuff(curve.G1.toJacobian(a));\n        const pB = tm.allocBuff(curve.G2.toJacobian(b));\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports[curve.name + \"_pairing\"](pA, pB, pRes);\n\n        const res = tm.getBuff(pRes, curve.Gt.n8);\n\n        tm.endSyncOp();\n        return res;\n    };\n\n    curve.pairingEq = async function pairingEq() {\n        let  buffCt;\n        let nEqs;\n        if ((arguments.length % 2) == 1) {\n            buffCt = arguments[arguments.length-1];\n            nEqs = (arguments.length -1) /2;\n        } else {\n            buffCt = curve.Gt.one;\n            nEqs = arguments.length /2;\n        }\n\n        const opPromises = [];\n        for (let i=0; i<nEqs; i++) {\n\n            const task = [];\n\n            const g1Buff = curve.G1.toJacobian(arguments[i*2]);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: g1Buff});\n            task.push({cmd: \"ALLOC\", var: 1, len: curve.prePSize});\n\n            const g2Buff = curve.G2.toJacobian(arguments[i*2 +1]);\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: g2Buff});\n            task.push({cmd: \"ALLOC\", var: 3, len: curve.preQSize});\n\n            task.push({cmd: \"ALLOC\", var: 4, len: curve.Gt.n8});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG1\", params: [\n                {var: 0},\n                {var: 1}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG2\", params: [\n                {var: 2},\n                {var: 3}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_millerLoop\", params: [\n                {var: 1},\n                {var: 3},\n                {var: 4}\n            ]});\n\n            task.push({cmd: \"GET\", out: 0, var: 4, len: curve.Gt.n8});\n\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        tm.startSyncOp();\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports.ftm_one(pRes);\n\n        for (let i=0; i<result.length; i++) {\n            const pMR = tm.allocBuff(result[i][0]);\n            tm.instance.exports.ftm_mul(pRes, pMR, pRes);\n        }\n        tm.instance.exports[curve.name + \"_finalExponentiation\"](pRes, pRes);\n\n        const pCt = tm.allocBuff(buffCt);\n\n        const r = !!tm.instance.exports.ftm_eq(pRes, pCt);\n\n        tm.endSyncOp();\n\n        return r;\n    };\n\n    curve.prepareG1 = function(p) {\n        this.tm.startSyncOp();\n        const pP = this.tm.allocBuff(p);\n        const pPrepP = this.tm.alloc(this.prePSize);\n        this.tm.instance.exports[this.name + \"_prepareG1\"](pP, pPrepP);\n        const res = this.tm.getBuff(pPrepP, this.prePSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.prepareG2 = function(q) {\n        this.tm.startSyncOp();\n        const pQ = this.tm.allocBuff(q);\n        const pPrepQ = this.tm.alloc(this.preQSize);\n        this.tm.instance.exports[this.name + \"_prepareG2\"](pQ, pPrepQ);\n        const res = this.tm.getBuff(pPrepQ, this.preQSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.millerLoop = function(preP, preQ) {\n        this.tm.startSyncOp();\n        const pPreP = this.tm.allocBuff(preP);\n        const pPreQ = this.tm.allocBuff(preQ);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_millerLoop\"](pPreP, pPreQ, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.finalExponentiation = function(a) {\n        this.tm.startSyncOp();\n        const pA = this.tm.allocBuff(a);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_finalExponentiation\"](pA, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n}\n", "import { log2 } from \"./utils.js\";\n\nconst pTSizes = [\n    1 ,  1,  1,  1,    2,  3,  4,  5,\n    6 ,  7,  7,  8,    9, 10, 11, 12,\n    13, 13, 14, 15,   16, 16, 17, 17,\n    17, 17, 17, 17,   17, 17, 17, 17\n];\n\nexport default function buildMultiexp(curve, groupName) {\n    const G = curve[groupName];\n    const tm = G.tm;\n    async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {\n        if ( ! (buffBases instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n        }\n        if ( ! (buffScalars instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n        }\n        inType = inType || \"affine\";\n\n        let sGIn;\n        let fnName;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                fnName = \"g1m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g1m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                fnName = \"g2m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g2m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff: buffBases},\n                {cmd: \"ALLOCSET\", var: 1, buff: buffScalars},\n                {cmd: \"ALLOC\", var: 2, len: G.F.n8*3},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {var: 1},\n                    {val: sScalar},\n                    {val: nPoints},\n                    {val: i*bitChunkSize},\n                    {val: Math.min(sScalar*8 - i*bitChunkSize, bitChunkSize)},\n                    {var: 2}\n                ]},\n                {cmd: \"GET\", out: 0, var: 2, len: G.F.n8*3}\n            ];\n            opPromises.push(\n                G.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            if (!G.isZero(res)) {\n                for (let j=0; j<bitChunkSize; j++) res = G.double(res);\n            }\n            res = G.add(res, result[i][0]);\n        }\n\n        return res;\n    }\n\n    async function _multiExp(buffBases, buffScalars, inType, logger, logText) {\n        const MAX_CHUNK_SIZE = 1 << 22;\n        const MIN_CHUNK_SIZE = 1 << 10;\n        let sGIn;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        let chunkSize;\n        chunkSize = Math.floor(nPoints / (tm.concurrency /nChunks));\n        if (chunkSize>MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n        if (chunkSize<MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n\n        const opPromises = [];\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n            const buffBasesChunk = buffBases.slice(i*sGIn, (i+n)*sGIn);\n            const buffScalarsChunk = buffScalars.slice(i*sScalar, (i+n)*sScalar);\n            opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then( (r) => {\n                if (logger) logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);\n                return r;\n            }));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            res = G.add(res, result[i]);\n        }\n\n        return res;\n    }\n\n    G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"jacobian\", logger, logText);\n    };\n    G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"affine\", logger, logText);\n    };\n}\n", "import {log2, buffReverseBits, array2buffer, buffer2array} from \"./utils.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default function buildFFT(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = G.tm;\n    async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {\n\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        const MAX_BITS_THREAD = 14;\n\n        let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g1m_fftFinal\";\n            }\n            fnFFTJoin = \"g1m_fftJoin\";\n            fnFFTMix = \"g1m_fftMix\";\n\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g1m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g2m_fftFinal\";\n            }\n            fnFFTJoin = \"g2m_fftJoin\";\n            fnFFTMix = \"g2m_fftMix\";\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g2m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = G.n8;\n            sMid = G.n8;\n            sOut = G.n8;\n            if (inverse) {\n                fnFFTFinal = \"frm_fftFinal\";\n            }\n            fnFFTMix = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        }\n\n\n        let returnArray = false;\n        if (Array.isArray(buff)) {\n            buff = array2buffer(buff, sIn);\n            returnArray = true;\n        } else {\n            buff = buff.slice(0, buff.byteLength);\n        }\n\n        const nPoints = buff.byteLength / sIn;\n        const bits = log2(nPoints);\n\n        if  ((1 << bits) != nPoints) {\n            throw new Error(\"fft must be multiple of 2\" );\n        }\n\n        if (bits == Fr.s +1) {\n            let buffOut;\n\n            if (inverse) {\n                buffOut =  await _fftExtInv(buff, inType, outType, logger, loggerTxt);\n            } else {\n                buffOut =  await _fftExt(buff, inType, outType, logger, loggerTxt);\n            }\n\n            if (returnArray) {\n                return buffer2array(buffOut, sOut);\n            } else {\n                return buffOut;\n            }\n        }\n\n        let inv;\n        if (inverse) {\n            inv = Fr.inv(Fr.e(nPoints));\n        }\n\n        let buffOut;\n\n        buffReverseBits(buff, sIn);\n\n        let chunks;\n        let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);\n        let nChunks = nPoints / pointsInChunk;\n\n        while ((nChunks < tm.concurrency)&&(pointsInChunk>=16)) {\n            nChunks *= 2;\n            pointsInChunk /= 2;\n        }\n\n        const l2Chunk = log2(pointsInChunk);\n\n        const promises = [];\n        for (let i = 0; i< nChunks; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix start: ${i}/${nChunks}`);\n            const task = [];\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*pointsInChunk});\n            const buffChunk = buff.slice( (pointsInChunk * i)*sIn, (pointsInChunk * (i+1))*sIn);\n            task.push({cmd: \"SET\", var: 0, buff: buffChunk});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n            }\n            for (let j=1; j<=l2Chunk;j++) {\n                task.push({cmd: \"CALL\", fnName:fnFFTMix, params: [{var:0}, {val: pointsInChunk}, {val: j}]});\n            }\n\n            if (l2Chunk==bits) {\n                if (fnFFTFinal) {\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: inv});\n                    task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                        {var: 0},\n                        {val: pointsInChunk},\n                        {var: 1},\n                    ]});\n                }\n                if (fnMid2Out) {\n                    task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                }\n                task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n            } else {\n                task.push({cmd: \"GET\", out:0, var: 0, len: sMid*pointsInChunk});\n            }\n            promises.push(tm.queueAction(task).then( (r) => {\n                if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix end: ${i}/${nChunks}`);\n                return r;\n            }));\n        }\n\n        chunks = await Promise.all(promises);\n        for (let i = 0; i< nChunks; i++) chunks[i] = chunks[i][0];\n\n        for (let i = l2Chunk+1;   i<=bits; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft  ${bits}  join: ${i}/${bits}`);\n            const nGroups = 1 << (bits - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsInChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsInChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    if (i==bits) {\n                        if (fnFFTFinal) {\n                            task.push({cmd: \"ALLOCSET\", var: 4, buff: inv});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 0},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 1},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                        }\n                        if (fnMid2Out) {\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: pointsInChunk}, {var: 1}]});\n                        }\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sOut});\n                    } else {\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sMid});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sMid});\n                    }\n                    opPromises.push(tm.queueAction(task).then( (r) => {\n                        if (logger) logger.debug(`${loggerTxt}: fft ${bits} join  ${i}/${bits}  ${j+1}/${nGroups} ${k}/${nChunksPerGroup/2}`);\n                        return r;\n                    }));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        if (buff instanceof BigBuffer) {\n            buffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            buffOut = new Uint8Array(nPoints*sOut);\n        }\n        if (inverse) {\n            buffOut.set(chunks[0].slice((pointsInChunk-1)*sOut));\n            let p= sOut;\n            for (let i=nChunks-1; i>0; i--) {\n                buffOut.set(chunks[i], p);\n                p += pointsInChunk*sOut;\n                delete chunks[i];  // Liberate mem\n            }\n            buffOut.set(chunks[0].slice(0, (pointsInChunk-1)*sOut), p);\n            delete chunks[0];\n        } else {\n            for (let i=0; i<nChunks; i++) {\n                buffOut.set(chunks[i], pointsInChunk*sOut*i);\n                delete chunks[i];\n            }\n        }\n\n        if (returnArray) {\n            return buffer2array(buffOut, sOut);\n        } else {\n            return buffOut;\n        }\n    }\n\n    async function _fftExt(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        [b1, b2] = await _fftJoinExt(b1, b2, \"fftJoinExt\", Fr.one, Fr.shift, inType, \"jacobian\", logger, loggerTxt);\n\n        promises.push( _fft(b1, false, \"jacobian\", outType, logger, loggerTxt));\n        promises.push( _fft(b2, false, \"jacobian\", outType, logger, loggerTxt));\n\n        const res1 = await Promise.all(promises);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n    async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        promises.push( _fft(b1, true, inType, \"jacobian\", logger, loggerTxt));\n        promises.push( _fft(b2, true, inType, \"jacobian\", logger, loggerTxt));\n\n        [b1, b2] = await Promise.all(promises);\n\n        const res1 = await _fftJoinExt(b1, b2, \"fftJoinExtInv\", Fr.one, Fr.shiftInv, \"jacobian\", outType, logger, loggerTxt);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n\n    async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const MIN_CHUNK_SIZE = 1<<4;\n\n        let fnName;\n        let fnIn2Mid, fnMid2Out;\n        let sOut, sIn, sMid;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            fnName = \"g1m_\"+fn;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g1m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            fnName = \"g2m_\"+fn;\n            sMid = G.F.n8*3;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g2m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n            sOut = Fr.n8;\n            sMid = Fr.n8;\n            fnName = \"frm_\" + fn;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sIn);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let chunkSize = Math.floor(nPoints /tm.concurrency);\n        if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n        if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n\n        const opPromises = [];\n\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n\n            const firstChunk = Fr.mul(first, Fr.exp( inc, i));\n            const task = [];\n\n            const b1 = buff1.slice(i*sIn, (i+n)*sIn);\n            const b2 = buff2.slice(i*sIn, (i+n)*sIn);\n\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*n});\n            task.push({cmd: \"SET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOC\", var: 1, len: sMid*n});\n            task.push({cmd: \"SET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: n},\n                {var: 2},\n                {var: 3},\n                {val: Fr.s},\n            ]});\n            if (fnMid2Out) {\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sOut});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: n*sOut});\n            opPromises.push(\n                tm.queueAction(task).then( (r) => {\n                    if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);\n                    return r;\n                })\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (nPoints * sOut > 1<<28) {\n            fullBuffOut1 = new BigBuffer(nPoints*sOut);\n            fullBuffOut2 = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sOut);\n            fullBuffOut2 = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    }\n\n\n    G.fft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, false, inType, outType, logger, loggerTxt);\n    };\n\n    G.ifft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, true, inType, outType, logger, loggerTxt);\n    };\n\n    G.lagrangeEvaluations = async function (buff, inType, outType, logger, loggerTxt) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n\n        let sIn;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = buff.byteLength /sIn;\n        const bits = log2(nPoints);\n\n        if ((2 ** bits)*sIn != buff.byteLength) {\n            if (logger) logger.error(\"lagrangeEvaluations iinvalid input size\");\n            throw new Error(\"lagrangeEvaluations invalid Input size\");\n        }\n\n        if (bits <= Fr.s) {\n            return await G.ifft(buff, inType, outType, logger, loggerTxt);\n        }\n\n        if (bits > Fr.s+1) {\n            if (logger) logger.error(\"lagrangeEvaluations input too big\");\n            throw new Error(\"lagrangeEvaluations input too big\");\n        }\n\n        let t0 = buff.slice(0, buff.byteLength/2);\n        let t1 = buff.slice(buff.byteLength/2, buff.byteLength);\n\n\n        const shiftToSmallM = Fr.exp(Fr.shift, nPoints/2);\n        const sConst = Fr.inv( Fr.sub(Fr.one, shiftToSmallM));\n\n        [t0, t1] = await _fftJoinExt(t0, t1, \"prepareLagrangeEvaluation\", sConst, Fr.shiftInv, inType, \"jacobian\", logger, loggerTxt + \" prep\");\n\n        const promises = [];\n\n        promises.push( _fft(t0, true, \"jacobian\", outType, logger, loggerTxt + \" t0\"));\n        promises.push( _fft(t1, true, \"jacobian\", outType, logger, loggerTxt + \" t1\"));\n\n        [t0, t1] = await Promise.all(promises);\n\n        let buffOut;\n        if (t0.byteLength > (1<<28)) {\n            buffOut = new BigBuffer(t0.byteLength*2);\n        } else {\n            buffOut = new Uint8Array(t0.byteLength*2);\n        }\n\n        buffOut.set(t0);\n        buffOut.set(t1, t0.byteLength);\n\n        return buffOut;\n    };\n\n    G.fftMix = async function fftMix(buff) {\n        const sG = G.F.n8*3;\n        let fnName, fnFFTJoin;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftMix\";\n            fnFFTJoin = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftMix\";\n            fnFFTJoin = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        const power = log2(nPoints);\n\n        let nChunks = 1 << log2(tm.concurrency);\n\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n        const powerChunk = log2(pointsPerChunk);\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            for (let j=1; j<=powerChunk; j++) {\n                task.push({cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: pointsPerChunk},\n                    {val: j}\n                ]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        const chunks = [];\n        for (let i=0; i<result.length; i++) chunks[i] = result[i][0];\n\n\n        for (let i = powerChunk+1; i<=power; i++) {\n            const nGroups = 1 << (power - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsPerChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsPerChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n                    task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n                    opPromises.push(tm.queueAction(task));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sG);\n        }\n        let p =0;\n        for (let i=0; i<nChunks; i++) {\n            fullBuffOut.set(chunks[i], p);\n            p+=chunks[i].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n\n    G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {\n        const sG = G.F.n8*3;\n        let fnName;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let nChunks = 1 << log2(tm.concurrency);\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n\n            const firstChunk = Fr.mul(first, Fr.exp(inc, i*pointsPerChunk));\n            const b1 = buff1.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            const b2 = buff2.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: pointsPerChunk},\n                {var: 2},\n                {var: 3}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (buff1 instanceof BigBuffer) {\n            fullBuffOut1 = new BigBuffer(nPoints*sG);\n            fullBuffOut2 = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sG);\n            fullBuffOut2 = new Uint8Array(nPoints*sG);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    };\n\n\n\n    G.fftFinal =  async function fftFinal(buff, factor) {\n        const sG = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnName, fnToAffine;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftFinal\";\n            fnToAffine = \"g1m_batchToAffine\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftFinal\";\n            fnToAffine = \"g2m_batchToAffine\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        const pointsPerChunk = Math.floor(nPoints / tm.concurrency);\n\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, (i*pointsPerChunk+n)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: factor});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {val: n},\n                {var: 1},\n            ]});\n            task.push({cmd: \"CALL\", fnName: fnToAffine, params: [\n                {var: 0},\n                {val: n},\n                {var: 0},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sGout});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sGout);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sGout);\n        }\n\n        let p =0;\n        for (let i=result.length-1; i>=0; i--) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n", "import { buildBls12381 as buildBls12381wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bls12381 = null;\n\nexport default async function buildBls12381(singleThread, plugins) {\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBls12381wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bls12381wasm = {};\n\n    bls12381wasm.code = moduleBuilder.build();\n    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;\n    bls12381wasm.pr = moduleBuilder.modules.frm.pq;\n    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;\n    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;\n    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;\n    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;\n    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;\n    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;\n    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;\n    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;\n    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;\n    bls12381wasm.n8q = 48;\n    bls12381wasm.n8r = 32;\n    bls12381wasm.q = moduleBuilder.modules.bls12381.q;\n    bls12381wasm.r = moduleBuilder.modules.bls12381.r;\n\n\n    if ((!singleThread) && (globalThis.curve_bls12381)) return globalThis.curve_bls12381;\n    const params = {\n        name: \"bls12381\",\n        wasm: bls12381wasm,\n        q: Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16),\n        r: Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16),\n        n8q: 48,\n        n8r: 32,\n        cofactorG1: Scalar.e(\"0x396c8c005555e1568c00aaab0000aaab\", 16),\n        cofactorG2: Scalar.e(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bls12381 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bls12381 = curve;\n    }\n\n    return curve;\n}\n\n", "import * as Scalar from \"./scalar.js\";\nimport {default as buildBn128} from \"./bn128.js\";\nimport {default as buildBls12381} from \"./bls12381.js\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nexport async function getCurveFromR(r, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(r, bn128r)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(r, bls12381r)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromQ(q, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(q, bn128q)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(q, bls12381q)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(q, 16)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromName(name, singleThread, plugins) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n", "import { Scalar, buildBn128, buildBls12381} from \"ffjavascript\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nexport async function getCurveFromR(r) {\n    let curve;\n    if (Scalar.eq(r, bn128r)) {\n        curve = await buildBn128();\n    } else if (Scalar.eq(r, bls12381r)) {\n        curve = await buildBls12381();\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromQ(q) {\n    let curve;\n    if (Scalar.eq(q, bn128q)) {\n        curve = await buildBn128();\n    } else if (Scalar.eq(q, bls12381q)) {\n        curve = await buildBls12381();\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(q)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromName(name) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await buildBn128();\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await buildBls12381();\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* global window */\nimport Blake2b from \"blake2b-wasm\";\nimport readline from \"readline\";\nimport { ChaCha } from \"ffjavascript\";\nimport crypto from \"crypto\";\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nexport function bitReverse(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\n\nexport function log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nexport function formatHash(b, title) {\n    const a = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    let S = \"\";\n    for (let i=0; i<4; i++) {\n        if (i>0) S += \"\\n\";\n        S += \"\\t\\t\";\n        for (let j=0; j<4; j++) {\n            if (j>0) S += \" \";\n            S += a.getUint32(i*16+j*4).toString(16).padStart(8, \"0\");\n        }\n    }\n    if (title) S = title + \"\\n\" + S;\n    return S;\n}\n\nexport function hashIsEqual(h1, h2) {\n    if (h1.byteLength != h2.byteLength) return false;\n    var dv1 = new Int8Array(h1);\n    var dv2 = new Int8Array(h2);\n    for (var i = 0 ; i != h1.byteLength ; i++)\n    {\n        if (dv1[i] != dv2[i]) return false;\n    }\n    return true;\n}\n\nexport function cloneHasher(h) {\n    const ph = h.getPartialHash();\n    const res = Blake2b(64);\n    res.setPartialHash(ph);\n    return res;\n}\n\nexport async function sameRatio(curve, g1s, g1sx, g2s, g2sx) {\n    if (curve.G1.isZero(g1s)) return false;\n    if (curve.G1.isZero(g1sx)) return false;\n    if (curve.G2.isZero(g2s)) return false;\n    if (curve.G2.isZero(g2sx)) return false;\n    // return curve.F12.eq(curve.pairing(g1s, g2sx), curve.pairing(g1sx, g2s));\n    const res = await curve.pairingEq(g1s, g2sx, curve.G1.neg(g1sx), g2s);\n    return res;\n}\n\n\nexport function askEntropy() {\n    if (process.browser) {\n        return window.prompt(\"Enter a random text. (Entropy): \", \"\");\n    } else {\n        const rl = readline.createInterface({\n            input: process.stdin,\n            output: process.stdout\n        });\n\n        return new Promise((resolve) => {\n            rl.question(\"Enter a random text. (Entropy): \", (input) => resolve(input) );\n        });\n    }\n}\n\nexport async function getRandomRng(entropy) {\n    // Generate a random Rng\n    while (!entropy) {\n        entropy = await askEntropy();\n    }\n    const hasher = Blake2b(64);\n    hasher.update(crypto.randomBytes(64));\n    const enc = new TextEncoder(); // always utf-8\n    hasher.update(enc.encode(entropy));\n    const hash = Buffer.from(hasher.digest());\n\n    const seed = [];\n    for (let i=0;i<8;i++) {\n        seed[i] = hash.readUInt32BE(i*4);\n    }\n    const rng = new ChaCha(seed);\n    return rng;\n}\n\nexport function rngFromBeaconParams(beaconHash, numIterationsExp) {\n    let nIterationsInner;\n    let nIterationsOuter;\n    if (numIterationsExp<32) {\n        nIterationsInner = (1 << numIterationsExp) >>> 0;\n        nIterationsOuter = 1;\n    } else {\n        nIterationsInner = 0x100000000;\n        nIterationsOuter = (1 << (numIterationsExp-32)) >>> 0;\n    }\n\n    let curHash = beaconHash;\n    for (let i=0; i<nIterationsOuter; i++) {\n        for (let j=0; j<nIterationsInner; j++) {\n            curHash = crypto.createHash(\"sha256\").update(curHash).digest();\n        }\n    }\n\n    const curHashV = new DataView(curHash.buffer, curHash.byteOffset, curHash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = curHashV.getUint32(i*4, false);\n    }\n\n    const rng = new ChaCha(seed);\n\n    return rng;\n}\n\nexport function hex2ByteArray(s) {\n    if (s instanceof Uint8Array) return s;\n    if (s.slice(0,2) == \"0x\") s= s.slice(2);\n    return new Uint8Array(s.match(/[\\da-f]{2}/gi).map(function (h) {\n        return parseInt(h, 16);\n    }));\n}\n\nexport function byteArray2hex(byteArray) {\n    return Array.prototype.map.call(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nexport function stringifyBigIntsWithField(Fr, o) {\n    if (o instanceof Uint8Array)  {\n        return Fr.toString(o);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigIntsWithField.bind(null, Fr));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach( (k) => {\n            res[k] = stringifyBigIntsWithField(Fr, o[k]);\n        });\n        return res;\n    } else if ((typeof(o) == \"bigint\") || o.eq !== undefined)  {\n        return o.toString(10);\n    } else {\n        return o;\n    }\n}", "export default {};\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { Scalar } from \"ffjavascript\";\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\n\nexport async function write(fd, witness, prime) {\n\n    await binFileUtils.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await binFileUtils.writeBigInt(fd, prime, n8);\n    await fd.writeULE32(witness.length);\n    await binFileUtils.endWriteSection(fd);\n\n    await binFileUtils.startWriteSection(fd, 2);\n    for (let i=0; i<witness.length; i++) {\n        await binFileUtils.writeBigInt(fd, witness[i], n8);\n    }\n    await binFileUtils.endWriteSection(fd, 2);\n\n\n}\n\nexport async function writeBin(fd, witnessBin, prime) {\n\n    await binFileUtils.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await binFileUtils.writeBigInt(fd, prime, n8);\n    if (witnessBin.byteLength % n8 != 0) {\n        throw new Error(\"Invalid witness length\");\n    }\n    await fd.writeULE32(witnessBin.byteLength / n8);\n    await binFileUtils.endWriteSection(fd);\n\n\n    await binFileUtils.startWriteSection(fd, 2);\n    await fd.write(witnessBin);\n    await binFileUtils.endWriteSection(fd);\n\n}\n\nexport async function readHeader(fd, sections) {\n\n    await binFileUtils.startReadUniqueSection(fd, sections, 1);\n    const n8 = await fd.readULE32();\n    const q = await binFileUtils.readBigInt(fd, n8);\n    const nWitness = await fd.readULE32();\n    await binFileUtils.endReadSection(fd);\n\n    return {n8, q, nWitness};\n\n}\n\nexport async function read(fileName) {\n\n    const {fd, sections} = await binFileUtils.readBinFile(fileName, \"wtns\", 2);\n\n    const {n8, nWitness} = await readHeader(fd, sections);\n\n    await binFileUtils.startReadUniqueSection(fd, sections, 2);\n    const res = [];\n    for (let i=0; i<nWitness; i++) {\n        const v = await binFileUtils.readBigInt(fd, n8);\n        res.push(v);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    await fd.close();\n\n    return res;\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\nimport { WitnessCalculatorBuilder } from \"circom_runtime\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport {  utils }   from \"ffjavascript\";\nconst { unstringifyBigInts} = utils;\n\nexport default async function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastFile.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wc = await WitnessCalculatorBuilder(wasm);\n    if (wc.circom_version() == 1) {\n        const w = await wc.calculateBinWitness(input);\n\n        const fdWtns = await binFileUtils.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n        await wtnsUtils.writeBin(fdWtns, w, wc.prime);\n        await fdWtns.close();\n    } else {\n        const fdWtns = await fastFile.createOverride(wtnsFileName);\n\n        const w = await wc.calculateWTNSBin(input);\n\n        await fdWtns.write(w);\n        await fdWtns.close();\n    }\n}\n", "export { default as WitnessCalculatorBuilder } from \"./js/witness_calculator.js\";\n", "/* globals WebAssembly */\n/*\n\nCopyright 2020 0KIMS association.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nimport { flatArray, fnvHash, toArray32 } from \"./utils.js\";\nimport { Scalar, F1Field } from \"ffjavascript\";\n\nexport default async function builder(code, options) {\n\n    options = options || {};\n\n    let memorySize = 32767;\n    let memory;\n    let memoryAllocated = false;\n    while (!memoryAllocated){\n        try{\n            memory = new WebAssembly.Memory({initial:memorySize});\n            memoryAllocated = true;\n        } catch(err){\n            if(memorySize === 1){\n                throw err;\n            }\n            console.warn(\"Could not allocate \" + memorySize * 1024 * 64 + \" bytes. This may cause severe instability. Trying with \" + memorySize * 1024 * 64 / 2 + \" bytes\");\n            memorySize = Math.floor(memorySize/2);\n        }\n    }\n\n    const wasmModule = await WebAssembly.compile(code);\n\n    let wc;\n\n    let errStr = \"\";\n    let msgStr = \"\";\n\n    // Only circom 2 implements version lookup through exports in the WASM\n    // We default to `1` and update if we see the `getVersion` export (major version)\n    // These are updated after the instance is instantiated, assuming the functions are available\n    let majorVersion = 1;\n    // After Circom 2.0.7, Blaine added exported functions for getting minor and patch versions\n    let minorVersion = 0;\n    // If we can't lookup the patch version, assume the lowest\n    let patchVersion = 0;\n\n    const instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": memory\n        },\n        runtime: {\n            exceptionHandler: function(code) {\n                let err;\n                if (code == 1) {\n                    err = \"Signal not found. \";\n                } else if (code == 2) {\n                    err = \"Too many signals set. \";\n                } else if (code == 3) {\n                    err = \"Signal already set. \";\n                } else if (code == 4) {\n                    err = \"Assert Failed. \";\n                } else if (code == 5) {\n                    err = \"Not enough memory. \";\n                } else if (code == 6) {\n                    err = \"Input signal array access exceeds the size. \";\n                } else {\n                    err = \"Unknown error. \";\n                }\n                console.error(\"ERROR: \", code, errStr);\n                throw new Error(err + errStr);\n            },\n            // A new way of logging messages was added in Circom 2.0.7 that requires 2 new imports\n            // `printErrorMessage` and `writeBufferMessage`.\n            printErrorMessage: function() {\n                errStr += getMessage() + \"\\n\";\n            },\n            writeBufferMessage: function() {\n                const msg = getMessage();\n                // Any calls to `log()` will always end with a `\\n`, so that's when we print and reset\n                if (msg === \"\\n\") {\n                    console.log(msgStr);\n                    msgStr = \"\";\n                } else {\n                    // If we've buffered other content, put a space in between the items\n                    if (msgStr !== \"\") {\n                        msgStr += \" \"\n                    }\n                    // Then append the message to the message we are creating\n                    msgStr += msg;\n                }\n            },\n            showSharedRWMemory: function() {\n                const shared_rw_memory_size = instance.exports.getFieldNumLen32();\n                const arr = new Uint32Array(shared_rw_memory_size);\n                for (let j=0; j<shared_rw_memory_size; j++) {\n                    arr[shared_rw_memory_size-1-j] = instance.exports.readSharedRWMemory(j);\n                }\n\n                // In circom 2.0.7, they changed the log() function to allow strings and changed the\n                // output API. This smoothes over the breaking change.\n                if (majorVersion >= 2 && (minorVersion >= 1 || patchVersion >= 7)) {\n                    // If we've buffered other content, put a space in between the items\n                    if (msgStr !== \"\") {\n                        msgStr += \" \"\n                    }\n                    // Then append the value to the message we are creating\n                    const msg = (Scalar.fromArray(arr, 0x100000000).toString());\n                    msgStr += msg;\n                } else {\n                    console.log(Scalar.fromArray(arr, 0x100000000));\n                }\n            },\n            error: function(code, pstr, a,b,c,d) {\n                let errStr;\n                if (code == 7) {\n                    errStr=p2str(pstr) + \" \" + wc.getFr(b).toString() + \" != \" + wc.getFr(c).toString() + \" \" +p2str(d);\n                } else if (code == 9) {\n                    errStr=p2str(pstr) + \" \" + wc.getFr(b).toString() + \" \" +p2str(c);\n                } else if ((code == 5)&&(options.sym)) {\n                    errStr=p2str(pstr)+ \" \" + options.sym.labelIdx2Name[c];\n                } else {\n                    errStr=p2str(pstr)+ \" \" + a + \" \" + b + \" \" + c + \" \" + d;\n                }\n                console.log(\"ERROR: \", code, errStr);\n                throw new Error(errStr);\n            },\n            log: function(a) {\n                console.log(wc.getFr(a).toString());\n            },\n            logGetSignal: function(signal, pVal) {\n                if (options.logGetSignal) {\n                    options.logGetSignal(signal, wc.getFr(pVal) );\n                }\n            },\n            logSetSignal: function(signal, pVal) {\n                if (options.logSetSignal) {\n                    options.logSetSignal(signal, wc.getFr(pVal) );\n                }\n            },\n            logStartComponent: function(cIdx) {\n                if (options.logStartComponent) {\n                    options.logStartComponent(cIdx);\n                }\n            },\n            logFinishComponent: function(cIdx) {\n                if (options.logFinishComponent) {\n                    options.logFinishComponent(cIdx);\n                }\n            }\n        }\n    });\n\n    if (typeof instance.exports.getVersion == 'function') {\n        majorVersion = instance.exports.getVersion();\n    }\n    if (typeof instance.exports.getMinorVersion == 'function') {\n        minorVersion = instance.exports.getMinorVersion();\n    }\n    if (typeof instance.exports.getPatchVersion == 'function') {\n        patchVersion = instance.exports.getPatchVersion();\n    }\n\n    const sanityCheck =\n        options &&\n        (\n            options.sanityCheck ||\n            options.logGetSignal ||\n            options.logSetSignal ||\n            options.logStartComponent ||\n            options.logFinishComponent\n        );\n\n    // We explicitly check for major version 2 in case there's a circom v3 in the future\n    if (majorVersion === 2) {\n        wc = new WitnessCalculatorCircom2(instance, sanityCheck);\n    } else {\n        // TODO: Maybe we want to check for the explicit version 1 before choosing this?\n        wc = new WitnessCalculatorCircom1(memory, instance, sanityCheck);\n    }\n    return wc;\n\n    function getMessage() {\n        var message = \"\";\n        var c = instance.exports.getMessageChar();\n        while ( c != 0 ) {\n            message += String.fromCharCode(c);\n            c = instance.exports.getMessageChar();\n        }\n        return message;\n    }\n\n    function p2str(p) {\n        const i8 = new Uint8Array(memory.buffer);\n\n        const bytes = [];\n\n        for (let i=0; i8[p+i]>0; i++)  bytes.push(i8[p+i]);\n\n        return String.fromCharCode.apply(null, bytes);\n    }\n};\n\nclass WitnessCalculatorCircom1 {\n    constructor(memory, instance, sanityCheck) {\n        this.memory = memory;\n        this.i32 = new Uint32Array(memory.buffer);\n        this.instance = instance;\n\n        this.n32 = (this.instance.exports.getFrLen() >> 2) - 2;\n        const pRawPrime = this.instance.exports.getPRawPrime();\n\n        const arr = new Array(this.n32);\n        for (let i=0; i<this.n32; i++) {\n            arr[this.n32-1-i] = this.i32[(pRawPrime >> 2) + i];\n        }\n\n        this.prime = Scalar.fromArray(arr, 0x100000000);\n\n        this.Fr = new F1Field(this.prime);\n\n        this.mask32 = Scalar.fromString(\"FFFFFFFF\", 16);\n        this.NVars = this.instance.exports.getNVars();\n        this.n64 = Math.floor((this.Fr.bitLength - 1) / 64)+1;\n        this.R = this.Fr.e( Scalar.shiftLeft(1 , this.n64*64));\n        this.RInv = this.Fr.inv(this.R);\n        this.sanityCheck = sanityCheck;\n    }\n\n    circom_version() {\n        return 1;\n    }\n\n    async _doCalculateWitness(input, sanityCheck) {\n        this.instance.exports.init((this.sanityCheck || sanityCheck) ? 1 : 0);\n        const pSigOffset = this.allocInt();\n        const pFr = this.allocFr();\n        const keys = Object.keys(input);\n        keys.forEach( (k) => {\n            const h = fnvHash(k);\n            const hMSB = parseInt(h.slice(0,8), 16);\n            const hLSB = parseInt(h.slice(8,16), 16);\n            try {\n                this.instance.exports.getSignalOffset32(pSigOffset, 0, hMSB, hLSB);\n            } catch (err) {\n                throw new Error(`Signal ${k} is not an input of the circuit.`);\n            }\n            const sigOffset = this.getInt(pSigOffset);\n            const fArr = flatArray(input[k]);\n            for (let i=0; i<fArr.length; i++) {\n                this.setFr(pFr, fArr[i]);\n                this.instance.exports.setSignal(0, 0, sigOffset + i, pFr);\n            }\n        });\n    }\n\n    async calculateWitness(input, sanityCheck) {\n        const self = this;\n\n        const old0 = self.i32[0];\n        const w = [];\n\n        await self._doCalculateWitness(input, sanityCheck);\n\n        for (let i=0; i<self.NVars; i++) {\n            const pWitness = self.instance.exports.getPWitness(i);\n            w.push(self.getFr(pWitness));\n        }\n\n        self.i32[0] = old0;\n        return w;\n    }\n\n    async calculateBinWitness(input, sanityCheck) {\n        const self = this;\n\n        const old0 = self.i32[0];\n\n        await self._doCalculateWitness(input, sanityCheck);\n\n        const pWitnessBuffer = self.instance.exports.getWitnessBuffer();\n\n        self.i32[0] = old0;\n\n        const buff = self.memory.buffer.slice(pWitnessBuffer, pWitnessBuffer + (self.NVars * self.n64 * 8));\n        return new Uint8Array(buff);\n    }\n\n    allocInt() {\n        const p = this.i32[0];\n        this.i32[0] = p+8;\n        return p;\n    }\n\n    allocFr() {\n        const p = this.i32[0];\n        this.i32[0] = p+this.n32*4 + 8;\n        return p;\n    }\n\n    getInt(p) {\n        return this.i32[p>>2];\n    }\n\n    setInt(p, v) {\n        this.i32[p>>2] = v;\n    }\n\n    getFr(p) {\n        const self = this;\n        const idx = (p>>2);\n\n        if (self.i32[idx + 1] & 0x80000000) {\n            const arr = new Array(self.n32);\n            for (let i=0; i<self.n32; i++) {\n                arr[self.n32-1-i] = self.i32[idx+2+i];\n            }\n            const res = self.Fr.e(Scalar.fromArray(arr, 0x100000000));\n            if (self.i32[idx + 1] & 0x40000000) {\n                return fromMontgomery(res);\n            } else {\n                return res;\n            }\n\n        } else {\n            if (self.i32[idx] & 0x80000000) {\n                return self.Fr.e( self.i32[idx] - 0x100000000);\n            } else {\n                return self.Fr.e(self.i32[idx]);\n            }\n        }\n\n        function fromMontgomery(n) {\n            return self.Fr.mul(self.RInv, n);\n        }\n\n    }\n\n\n    setFr(p, v) {\n        const self = this;\n\n        v = self.Fr.e(v);\n\n        const minShort = self.Fr.neg(self.Fr.e(\"80000000\", 16));\n        const maxShort = self.Fr.e(\"7FFFFFFF\", 16);\n\n        if (  (self.Fr.geq(v, minShort))\n            &&(self.Fr.leq(v, maxShort)))\n        {\n            let a;\n            if (self.Fr.geq(v, self.Fr.zero)) {\n                a = Scalar.toNumber(v);\n            } else {\n                a = Scalar.toNumber( self.Fr.sub(v, minShort));\n                a = a - 0x80000000;\n                a = 0x100000000 + a;\n            }\n            self.i32[(p >> 2)] = a;\n            self.i32[(p >> 2) + 1] = 0;\n            return;\n        }\n\n        self.i32[(p >> 2)] = 0;\n        self.i32[(p >> 2) + 1] = 0x80000000;\n        const arr = Scalar.toArray(v, 0x100000000);\n        for (let i=0; i<self.n32; i++) {\n            const idx = arr.length-1-i;\n\n            if ( idx >=0) {\n                self.i32[(p >> 2) + 2 + i] = arr[idx];\n            } else {\n                self.i32[(p >> 2) + 2 + i] = 0;\n            }\n        }\n    }\n}\n\nclass WitnessCalculatorCircom2 {\n    constructor(instance, sanityCheck) {\n        this.instance = instance;\n\n        this.version = this.instance.exports.getVersion();\n        this.n32 = this.instance.exports.getFieldNumLen32();\n\n        this.instance.exports.getRawPrime();\n        const arr = new Array(this.n32);\n        for (let i=0; i<this.n32; i++) {\n            arr[this.n32-1-i] = this.instance.exports.readSharedRWMemory(i);\n        }\n        this.prime = Scalar.fromArray(arr, 0x100000000);\n\n        this.witnessSize = this.instance.exports.getWitnessSize();\n\n        this.sanityCheck = sanityCheck;\n    }\n\n    circom_version() {\n        return this.instance.exports.getVersion();\n    }\n\n    async _doCalculateWitness(input, sanityCheck) {\n        //input is assumed to be a map from signals to arrays of bigints\n        this.instance.exports.init((this.sanityCheck || sanityCheck) ? 1 : 0);\n        const keys = Object.keys(input);\n        var input_counter = 0;\n        keys.forEach( (k) => {\n            const h = fnvHash(k);\n            const hMSB = parseInt(h.slice(0,8), 16);\n            const hLSB = parseInt(h.slice(8,16), 16);\n            const fArr = flatArray(input[k]);\n            for (let i=0; i<fArr.length; i++) {\n        const arrFr = toArray32(fArr[i],this.n32)\n        for (let j=0; j<this.n32; j++) {\n            this.instance.exports.writeSharedRWMemory(j,arrFr[this.n32-1-j]);\n        }\n        try {\n                    this.instance.exports.setInputSignal(hMSB, hLSB,i);\n            input_counter++;\n        } catch (err) {\n            // console.log(`After adding signal ${i} of ${k}`)\n                    throw new Error(err);\n        }\n            }\n\n        });\n        if (input_counter < this.instance.exports.getInputSize()) {\n            throw new Error(`Not all inputs have been set. Only ${input_counter} out of ${this.instance.exports.getInputSize()}`);\n        }\n    }\n\n    async calculateWitness(input, sanityCheck) {\n        const w = [];\n\n        await this._doCalculateWitness(input, sanityCheck);\n\n        for (let i=0; i<this.witnessSize; i++) {\n            this.instance.exports.getWitness(i);\n        const arr = new Uint32Array(this.n32);\n            for (let j=0; j<this.n32; j++) {\n            arr[this.n32-1-j] = this.instance.exports.readSharedRWMemory(j);\n            }\n            w.push(Scalar.fromArray(arr, 0x100000000));\n        }\n\n        return w;\n    }\n\n    async calculateWTNSBin(input, sanityCheck) {\n        const buff32 = new Uint32Array(this.witnessSize*this.n32+this.n32+11);\n        const buff = new  Uint8Array( buff32.buffer);\n        await this._doCalculateWitness(input, sanityCheck);\n\n        //\"wtns\"\n        buff[0] = \"w\".charCodeAt(0)\n        buff[1] = \"t\".charCodeAt(0)\n        buff[2] = \"n\".charCodeAt(0)\n        buff[3] = \"s\".charCodeAt(0)\n\n        //version 2\n        buff32[1] = 2;\n\n        //number of sections: 2\n        buff32[2] = 2;\n\n        //id section 1\n        buff32[3] = 1;\n\n        const n8 = this.n32*4;\n        //id section 1 length in 64bytes\n        const idSection1length = 8 + n8;\n        const idSection1lengthHex = idSection1length.toString(16);\n            buff32[4] = parseInt(idSection1lengthHex.slice(0,8), 16);\n            buff32[5] = parseInt(idSection1lengthHex.slice(8,16), 16);\n\n        //this.n32\n        buff32[6] = n8;\n\n        //prime number\n        this.instance.exports.getRawPrime();\n\n        var pos = 7;\n        for (let j=0; j<this.n32; j++) {\n            buff32[pos+j] = this.instance.exports.readSharedRWMemory(j);\n        }\n        pos += this.n32;\n\n        // witness size\n        buff32[pos] = this.witnessSize;\n        pos++;\n\n        //id section 2\n        buff32[pos] = 2;\n        pos++;\n\n        // section 2 length\n        const idSection2length = n8*this.witnessSize;\n        const idSection2lengthHex = idSection2length.toString(16);\n        buff32[pos] = parseInt(idSection2lengthHex.slice(0,8), 16);\n        buff32[pos+1] = parseInt(idSection2lengthHex.slice(8,16), 16);\n\n        pos += 2;\n        for (let i=0; i<this.witnessSize; i++) {\n            this.instance.exports.getWitness(i);\n            for (let j=0; j<this.n32; j++) {\n                buff32[pos+j] = this.instance.exports.readSharedRWMemory(j);\n            }\n            pos += this.n32;\n        }\n\n        return buff;\n    }\n\n}\n", "/*\n\nCopyright 2020 0KIMS association.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nexport function flatArray(a) {\n    var res = [];\n    fillArray(res, a);\n    return res;\n\n    function fillArray(res, a) {\n        if (Array.isArray(a)) {\n            for (let i=0; i<a.length; i++) {\n                fillArray(res, a[i]);\n            }\n        } else {\n            res.push(a);\n        }\n    }\n}\n\nexport function fnvHash(str) {\n    const uint64_max = BigInt(2) ** BigInt(64);\n    let hash = BigInt(\"0xCBF29CE484222325\");\n    for (var i = 0; i < str.length; i++) {\n    hash ^= BigInt(str[i].charCodeAt());\n    hash *= BigInt(0x100000001B3);\n    hash %= uint64_max;\n    }\n    let shash = hash.toString(16);\n    let n = 16 - shash.length;\n    shash = '0'.repeat(n).concat(shash);\n    return shash;\n}\n\n// Note that this pads zeros\nexport function toArray32(s,size) {\n    const res = []; //new Uint32Array(size); //has no unshift\n    let rem = BigInt(s);\n    const radix = BigInt(0x100000000);\n    while (rem) {\n        res.unshift( Number(rem % radix));\n        rem = rem / radix;\n    }\n    if (size) {\n    var i = size - res.length;\n    while (i>0) {\n        res.unshift(0);\n        i--;\n    }\n    }\n    return res;\n}\n", "\nimport * as _Scalar  from \"./src/scalar.js\";\nexport const Scalar=_Scalar;\n\nexport {default as PolField} from \"./src/polfield.js\";\nexport {default as F1Field} from \"./src/f1field.js\";\nexport {default as F2Field} from \"./src/f2field.js\";\nexport {default as F3Field} from \"./src/f3field.js\";\n\nexport {default as ZqField} from \"./src/f1field.js\";\n\nexport {default as EC} from \"./src/ec.js\";\n\nexport {default as buildBn128} from \"./src/bn128.js\";\nexport {default as buildBls12381} from \"./src/bls12381.js\";\n\nimport * as _utils from \"./src/utils.js\";\nexport const utils = _utils;\nexport {default as ChaCha} from \"./src/chacha.js\";\n\nexport {default as BigBuffer} from \"./src/bigbuffer.js\";\n\nexport {getCurveFromR, getCurveFromQ, getCurveFromName} from \"./src/curves.js\";\n\n", "\n/* global BigInt */\nconst hexLen = [ 0, 1, 2, 2, 3, 3, 3, 3, 4 ,4 ,4 ,4 ,4 ,4 ,4 ,4];\n\nexport function fromString(s, radix) {\n    if ((!radix)||(radix==10)) {\n        return BigInt(s);\n    } else if (radix==16) {\n        if (s.slice(0,2) == \"0x\") {\n            return BigInt(s);\n        } else {\n            return BigInt(\"0x\"+s);\n        }\n    }\n}\n\nexport const e = fromString;\n\nexport function fromArray(a, radix) {\n    let acc =BigInt(0);\n    radix = BigInt(radix);\n    for (let i=0; i<a.length; i++) {\n        acc = acc*radix + BigInt(a[i]);\n    }\n    return acc;\n}\n\nexport function bitLength(a) {\n    const aS =a.toString(16);\n    return (aS.length-1)*4 +hexLen[parseInt(aS[0], 16)];\n}\n\nexport function isNegative(a) {\n    return BigInt(a) < BigInt(0);\n}\n\nexport function isZero(a) {\n    return !a;\n}\n\nexport function shiftLeft(a, n) {\n    return BigInt(a) << BigInt(n);\n}\n\nexport function shiftRight(a, n) {\n    return BigInt(a) >> BigInt(n);\n}\n\nexport const shl = shiftLeft;\nexport const shr = shiftRight;\n\nexport function isOdd(a) {\n    return (BigInt(a) & BigInt(1)) == BigInt(1);\n}\n\n\nexport function naf(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            const z = 2 - Number(E % BigInt(4));\n            res.push( z );\n            E = E - BigInt(z);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\n\nexport function bits(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\nexport function toNumber(s) {\n    if (s>BigInt(Number.MAX_SAFE_INTEGER )) {\n        throw new Error(\"Number too big\");\n    }\n    return Number(s);\n}\n\nexport function toArray(s, radix) {\n    const res = [];\n    let rem = BigInt(s);\n    radix = BigInt(radix);\n    while (rem) {\n        res.unshift( Number(rem % radix));\n        rem = rem / radix;\n    }\n    return res;\n}\n\n\nexport function add(a, b) {\n    return BigInt(a) + BigInt(b);\n}\n\nexport function sub(a, b) {\n    return BigInt(a) - BigInt(b);\n}\n\nexport function neg(a) {\n    return -BigInt(a);\n}\n\nexport function mul(a, b) {\n    return BigInt(a) * BigInt(b);\n}\n\nexport function square(a) {\n    return BigInt(a) * BigInt(a);\n}\n\nexport function pow(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function exp(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function abs(a) {\n    return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);\n}\n\nexport function div(a, b) {\n    return BigInt(a) / BigInt(b);\n}\n\nexport function mod(a, b) {\n    return BigInt(a) % BigInt(b);\n}\n\nexport function eq(a, b) {\n    return BigInt(a) == BigInt(b);\n}\n\nexport function neq(a, b) {\n    return BigInt(a) != BigInt(b);\n}\n\nexport function lt(a, b) {\n    return BigInt(a) < BigInt(b);\n}\n\nexport function gt(a, b) {\n    return BigInt(a) > BigInt(b);\n}\n\nexport function leq(a, b) {\n    return BigInt(a) <= BigInt(b);\n}\n\nexport function geq(a, b) {\n    return BigInt(a) >= BigInt(b);\n}\n\nexport function band(a, b) {\n    return BigInt(a) & BigInt(b);\n}\n\nexport function bor(a, b) {\n    return BigInt(a) | BigInt(b);\n}\n\nexport function bxor(a, b) {\n    return BigInt(a) ^ BigInt(b);\n}\n\nexport function land(a, b) {\n    return BigInt(a) && BigInt(b);\n}\n\nexport function lor(a, b) {\n    return BigInt(a) || BigInt(b);\n}\n\nexport function lnot(a) {\n    return !BigInt(a);\n}\n\n// Returns a buffer with Little Endian Representation\nexport function toRprLE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new Uint32Array(buff.buffer, o, n8/4);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v[i] = parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16);\n    for (let i=l; i<v.length; i++) v[i] = 0;\n    for (let i=v.length*4; i<n8; i++) buff[i] = toNumber(band(shiftRight(e, i*8), 0xFF));\n}\n\n// Returns a buffer with Big Endian Representation\nexport function toRprBE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v.setUint32(n8-i*4 -4, parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16), false);\n    for (let i=0; i<n8/4-l; i++) v[i] = 0;\n}\n\n// Pases a buffer with Little Endian Representation\nexport function fromRprLE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new Uint32Array(buff.buffer, o, n8/4);\n    const a = new Array(n8/4);\n    v.forEach( (ch,i) => a[a.length-i-1] = ch.toString(16).padStart(8,\"0\") );\n    return fromString(a.join(\"\"), 16);\n}\n\n// Pases a buffer with Big Endian Representation\nexport function fromRprBE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const a = new Array(n8/4);\n    for (let i=0; i<n8/4; i++) {\n        a[i] = v.getUint32(i*4, false).toString(16).padStart(8, \"0\");\n    }\n    return fromString(a.join(\"\"), 16);\n}\n\nexport function toString(a, radix) {\n    return a.toString(radix);\n}\n\nexport function toLEBuff(a) {\n    const buff = new Uint8Array(Math.floor((bitLength(a) - 1) / 8) +1);\n    toRprLE(buff, 0, a, buff.byteLength);\n    return buff;\n}\n\nexport const zero = e(0);\nexport const one = e(1);\n\n\n\n\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class PolField {\n    constructor (F) {\n        this.F = F;\n\n        let rem = F.sqrt_t;\n        let s = F.sqrt_s;\n\n        const five = this.F.add(this.F.add(this.F.two, this.F.two), this.F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(five, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n/*        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n    */\n        this._setRoots(15);\n    }\n\n    _setRoots(n) {\n        if (n > this.F.sqrt_s) n = this.s;\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n            this.roots[i] = rootsi;\n        }\n    }\n\n    add(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.add(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.sub(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    mulScalar(p, b) {\n        if (this.F.eq(b, this.F.zero)) return [];\n        if (this.F.eq(b, this.F.one)) return p;\n        const res = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.mul(p[i], b);\n        }\n        return res;\n    }\n\n\n\n    mul(a, b) {\n        if (a.length == 0) return [];\n        if (b.length == 0) return [];\n        if (a.length == 1) return this.mulScalar(b, a[0]);\n        if (b.length == 1) return this.mulScalar(a, b[0]);\n\n        if (b.length > a.length) {\n            [b, a] = [a, b];\n        }\n\n        if ((b.length <= 2) || (b.length < log2(a.length))) {\n            return this.mulNormal(a,b);\n        } else {\n            return this.mulFFT(a,b);\n        }\n    }\n\n    mulNormal(a, b) {\n        let res = [];\n        for (let i=0; i<b.length; i++) {\n            res = this.add(res, this.scaleX(this.mulScalar(a, b[i]), i) );\n        }\n        return res;\n    }\n\n    mulFFT(a,b) {\n        const longestN = Math.max(a.length, b.length);\n        const bitsResult = log2(longestN-1)+2;\n        this._setRoots(bitsResult);\n\n        const m = 1 << bitsResult;\n        const ea = this.extend(a,m);\n        const eb = this.extend(b,m);\n\n        const ta = __fft(this, ea, bitsResult, 0, 1, false);\n        const tb = __fft(this, eb, bitsResult, 0, 1, false);\n\n        const tres = new Array(m);\n\n        for (let i=0; i<m; i++) {\n            tres[i] = this.F.mul(ta[i], tb[i]);\n        }\n\n        const res = __fft(this, tres, bitsResult, 0, 1, true);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return this.reduce(resn);\n    }\n\n\n\n    square(a) {\n        return this.mul(a,a);\n    }\n\n    scaleX(p, n) {\n        if (n==0) {\n            return p;\n        } else if (n>0) {\n            const z = new Array(n).fill(this.F.zero);\n            return z.concat(p);\n        } else {\n            if (-n >= p.length) return [];\n            return p.slice(-n);\n        }\n    }\n\n    eval2(p, x) {\n        let v = this.F.zero;\n        let ix = this.F.one;\n        for (let i=0; i<p.length; i++) {\n            v = this.F.add(v, this.F.mul(p[i], ix));\n            ix = this.F.mul(ix, x);\n        }\n        return v;\n    }\n\n    eval(p,x) {\n        const F = this.F;\n        if (p.length == 0) return F.zero;\n        const m = this._next2Power(p.length);\n        const ep = this.extend(p, m);\n\n        return _eval(ep, x, 0, 1, m);\n\n        function _eval(p, x, offset, step, n) {\n            if (n==1) return p[offset];\n            const newX = F.square(x);\n            const res= F.add(\n                _eval(p, newX, offset, step << 1, n >> 1),\n                F.mul(\n                    x,\n                    _eval(p, newX, offset+step , step << 1, n >> 1)));\n            return res;\n        }\n    }\n\n    lagrange(points) {\n        let roots = [this.F.one];\n        for (let i=0; i<points.length; i++) {\n            roots = this.mul(roots, [this.F.neg(points[i][0]), this.F.one]);\n        }\n\n        let sum = [];\n        for (let i=0; i<points.length; i++) {\n            let mpol = this.ruffini(roots, points[i][0]);\n            const factor =\n                this.F.mul(\n                    this.F.inv(this.eval(mpol, points[i][0])),\n                    points[i][1]);\n            mpol = this.mulScalar(mpol, factor);\n            sum = this.add(sum, mpol);\n        }\n        return sum;\n    }\n\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res = __fft(this, ep, bits, 0, 1);\n        return res;\n    }\n\n    fft2(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res = __fft2(this, ep, bits);\n        return res;\n    }\n\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res =  __fft(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n\n    ifft2(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res =  __fft2(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n    _fft(pall, bits, offset, step) {\n\n        const n = 1 << bits;\n        if (n==1) {\n            return [ pall[offset] ];\n        }\n\n        const ndiv2 = n >> 1;\n        const p1 = this._fft(pall, bits-1, offset, step*2);\n        const p2 = this._fft(pall, bits-1, offset+step, step*2);\n\n        const out = new Array(n);\n\n        let m= this.F.one;\n        for (let i=0; i<ndiv2; i++) {\n            out[i] = this.F.add(p1[i], this.F.mul(m, p2[i]));\n            out[i+ndiv2] = this.F.sub(p1[i], this.F.mul(m, p2[i]));\n            m = this.F.mul(m, this.w[bits]);\n        }\n\n        return out;\n    }\n\n    extend(p, e) {\n        if (e == p.length) return p;\n        const z = new Array(e-p.length).fill(this.F.zero);\n\n        return p.concat(z);\n    }\n\n    reduce(p) {\n        if (p.length == 0) return p;\n        if (! this.F.eq(p[p.length-1], this.F.zero) ) return p;\n        let i=p.length-1;\n        while( i>0 && this.F.eq(p[i], this.F.zero) ) i--;\n        return p.slice(0, i+1);\n    }\n\n    eq(a, b) {\n        const pa = this.reduce(a);\n        const pb = this.reduce(b);\n\n        if (pa.length != pb.length) return false;\n        for (let i=0; i<pb.length; i++) {\n            if (!this.F.eq(pa[i], pb[i])) return false;\n        }\n\n        return true;\n    }\n\n    ruffini(p, r) {\n        const res = new Array(p.length-1);\n        res[res.length-1] = p[p.length-1];\n        for (let i = res.length-2; i>=0; i--) {\n            res[i] = this.F.add(this.F.mul(res[i+1], r), p[i+1]);\n        }\n        return res;\n    }\n\n    _next2Power(v) {\n        v--;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v++;\n        return v;\n    }\n\n    toString(p) {\n        const ap = this.normalize(p);\n        let S = \"\";\n        for (let i=ap.length-1; i>=0; i--) {\n            if (!this.F.eq(p[i], this.F.zero)) {\n                if (S!=\"\") S += \" + \";\n                S = S + p[i].toString(10);\n                if (i>0) {\n                    S = S + \"x\";\n                    if (i>1) {\n                        S = S + \"^\" +i;\n                    }\n                }\n            }\n        }\n        return S;\n    }\n\n    normalize(p) {\n        const res  = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.normalize(p[i]);\n        }\n        return res;\n    }\n\n\n    _reciprocal(p, bits) {\n        const k = 1 << bits;\n        if (k==1) {\n            return [ this.F.inv(p[0]) ];\n        }\n        const np = this.scaleX(p, -k/2);\n        const q = this._reciprocal(np, bits-1);\n        const a = this.scaleX(this.double(q), 3*k/2-2);\n        const b = this.mul( this.square(q), p);\n\n        return this.scaleX(this.sub(a,b),   -(k-2));\n    }\n\n    // divides x^m / v\n    _div2(m, v) {\n        const kbits = log2(v.length-1)+1;\n        const k = 1 << kbits;\n\n        const scaleV = k - v.length;\n\n        // rec = x^(k - 2) / v* x^scaleV =>\n        // rec = x^(k-2-scaleV)/ v\n        //\n        // res = x^m/v = x^(m + (2*k-2 - scaleV) - (2*k-2 - scaleV)) /v =>\n        // res = rec * x^(m - (2*k-2 - scaleV)) =>\n        // res = rec * x^(m - 2*k + 2 + scaleV)\n\n        const rec = this._reciprocal(this.scaleX(v, scaleV), kbits);\n        const res = this.scaleX(rec, m - 2*k + 2 + scaleV);\n\n        return res;\n    }\n\n    div(_u, _v) {\n        if (_u.length < _v.length) return [];\n        const kbits = log2(_v.length-1)+1;\n        const k = 1 << kbits;\n\n        const u = this.scaleX(_u, k-_v.length);\n        const v = this.scaleX(_v, k-_v.length);\n\n        const n = v.length-1;\n        let m = u.length-1;\n\n        const s = this._reciprocal(v, kbits);\n        let t;\n        if (m>2*n) {\n            t = this.sub(this.scaleX([this.F.one], 2*n), this.mul(s, v));\n        }\n\n        let q = [];\n        let rem = u;\n        let us, ut;\n        let finish = false;\n\n        while (!finish) {\n            us = this.mul(rem, s);\n            q = this.add(q, this.scaleX(us, -2*n));\n\n            if ( m > 2*n ) {\n                ut = this.mul(rem, t);\n                rem = this.scaleX(ut, -2*n);\n                m = rem.length-1;\n            } else {\n                finish = true;\n            }\n        }\n\n        return q;\n    }\n\n\n    // returns the ith nth-root of one\n    oneRoot(n, i) {\n        let nbits = log2(n-1)+1;\n        let res = this.F.one;\n        let r = i;\n\n        if(i>=n) {\n            throw new Error(\"Given 'i' should be lower than 'n'\");\n        }\n        else if (1<<nbits !== n) {\n            throw new Error(`Internal errlr: ${n} should equal ${1<<nbits}`);\n        }\n\n        while (r>0) {\n            if (r & 1 == 1) {\n                res = this.F.mul(res, this.w[nbits]);\n            }\n            r = r >> 1;\n            nbits --;\n        }\n        return res;\n    }\n\n    computeVanishingPolinomial(bits, t) {\n        const m = 1 << bits;\n        return this.F.sub(this.F.pow(t, m), this.F.one);\n    }\n\n    evaluateLagrangePolynomials(bits, t) {\n        const m= 1 << bits;\n        const tm = this.F.pow(t, m);\n        const u= new Array(m).fill(this.F.zero);\n        this._setRoots(bits);\n        const omega = this.w[bits];\n\n        if (this.F.eq(tm, this.F.one)) {\n            for (let i = 0; i < m; i++) {\n                if (this.F.eq(this.roots[bits][0],t)) { // i.e., t equals omega^i\n                    u[i] = this.F.one;\n                    return u;\n                }\n            }\n        }\n\n        const z = this.F.sub(tm, this.F.one);\n        //        let l = this.F.mul(z,  this.F.pow(this.F.twoinv, m));\n        let l = this.F.mul(z,  this.F.inv(this.F.e(m)));\n        for (let i = 0; i < m; i++) {\n            u[i] = this.F.mul(l, this.F.inv(this.F.sub(t,this.roots[bits][i])));\n            l = this.F.mul(l, omega);\n        }\n\n        return u;\n    }\n\n    log2(V) {\n        return log2(V);\n    }\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.F.add(pall[offset], pall[offset + step]),\n            PF.F.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\n\nfunction __fft2(PF, pall, bits) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[0] ];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft2(PF, pall.slice(0, ndiv2), bits-1);\n    const p2 = __fft2(PF, pall.slice(ndiv2), bits-1);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction rev(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\nfunction __bitReverse(p, bits) {\n    for (let k=0; k<p.length; k++) {\n        const r = rev(k, bits);\n        if (r>k) {\n            const tmp= p[k];\n            p[k] = p[r];\n            p[r] = tmp;\n        }\n    }\n\n}\n\n\n", "/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\nimport * as futils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\nimport {getRandomBytes} from \"./random.js\";\nimport FFFT from \"./fft.js\";\n\nexport default class ZqField {\n    constructor(p) {\n        this.type=\"F1\";\n        this.one = BigInt(1);\n        this.zero = BigInt(0);\n        this.p = BigInt(p);\n        this.m = 1;\n        this.negone = this.p-this.one;\n        this.two = BigInt(2);\n        this.half = this.p >> this.one;\n        this.bitLength = Scalar.bitLength(this.p);\n        this.mask = (this.one << BigInt(this.bitLength)) - this.one;\n\n        this.n64 = Math.floor((this.bitLength - 1) / 64)+1;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n        this.R = this.e(this.one << BigInt(this.n64*64));\n        this.Ri = this.inv(this.R);\n\n        const e = this.negone >> this.one;\n        this.nqr = this.two;\n        let r = this.pow(this.nqr, e);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.nqr + this.one;\n            r = this.pow(this.nqr, e);\n        }\n\n\n        this.s = 0;\n        this.t = this.negone;\n\n        while ((this.t & this.one) == this.zero) {\n            this.s = this.s + 1;\n            this.t = this.t >> this.one;\n        }\n\n        this.nqr_to_t = this.pow(this.nqr, this.t);\n\n        buildSqrt(this);\n\n        this.FFT = new FFFT(this, this, this.mul.bind(this));\n\n        this.fft = this.FFT.fft.bind(this.FFT);\n        this.ifft = this.FFT.ifft.bind(this.FFT);\n        this.w = this.FFT.w;\n        this.wi = this.FFT.wi; \n    \n        this.shift = this.square(this.nqr);\n        this.k = this.exp(this.nqr, 2**this.s);\n    }\n\n    e(a,b) {\n        let res;\n        if (!b) {\n            res = BigInt(a);\n        } else if (b==16) {\n            res = BigInt(\"0x\"+a);\n        }\n        if (res < 0) {\n            let nres = -res;\n            if (nres >= this.p) nres = nres % this.p;\n            return this.p - nres;\n        } else {\n            return (res>= this.p) ? res%this.p : res;\n        }\n\n    }\n\n    add(a, b) {\n        const res = a + b;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    sub(a, b) {\n        return (a >= b) ? a-b : this.p-b+a;\n    }\n\n    neg(a) {\n        return a ? this.p-a : a;\n    }\n\n    mul(a, b) {\n        return (a*b)%this.p;\n    }\n\n    mulScalar(base, s) {\n        return (base * this.e(s)) % this.p;\n    }\n\n    square(a) {\n        return (a*a) % this.p;\n    }\n\n    eq(a, b) {\n        return a==b;\n    }\n\n    neq(a, b) {\n        return a!=b;\n    }\n\n    lt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa < bb;\n    }\n\n    gt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa > bb;\n    }\n\n    leq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa <= bb;\n    }\n\n    geq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa >= bb;\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    idiv(a, b) {\n        if (!b) throw new Error(\"Division by zero\");\n        return a / b;\n    }\n\n    inv(a) {\n        if (!a) throw new Error(\"Division by zero\");\n\n        let t = this.zero;\n        let r = this.p;\n        let newt = this.one;\n        let newr = a % this.p;\n        while (newr) {\n            let q = r/newr;\n            [t, newt] = [newt, t-q*newt];\n            [r, newr] = [newr, r-q*newr];\n        }\n        if (t<this.zero) t += this.p;\n        return t;\n    }\n\n    mod(a, b) {\n        return a % b;\n    }\n\n    pow(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    exp(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    band(a, b) {\n        const res =  ((a & b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bor(a, b) {\n        const res =  ((a | b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bxor(a, b) {\n        const res =  ((a ^ b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bnot(a) {\n        const res = a ^ this.mask;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    shl(a, b) {\n        if (Number(b) < this.bitLength) {\n            const res = (a << b) & this.mask;\n            return res >= this.p ? res-this.p : res;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                return a >> nb;\n            } else {\n                return this.zero;\n            }\n        }\n    }\n\n    shr(a, b) {\n        if (Number(b) < this.bitLength) {\n            return a >> b;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                const res = (a << nb) & this.mask;\n                return res >= this.p ? res-this.p : res;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    land(a, b) {\n        return (a && b) ? this.one : this.zero;\n    }\n\n    lor(a, b) {\n        return (a || b) ? this.one : this.zero;\n    }\n\n    lnot(a) {\n        return (a) ? this.zero : this.one;\n    }\n\n    sqrt_old(n) {\n\n        if (n == this.zero) return this.zero;\n\n        // Test that have solution\n        const res = this.pow(n, this.negone >> this.one);\n        if ( res != this.one ) return null;\n\n        let m = this.s;\n        let c = this.nqr_to_t;\n        let t = this.pow(n, this.t);\n        let r = this.pow(n, this.add(this.t, this.one) >> this.one );\n\n        while ( t != this.one ) {\n            let sq = this.square(t);\n            let i = 1;\n            while (sq != this.one ) {\n                i++;\n                sq = this.square(sq);\n            }\n\n            // b = c ^ m-i-1\n            let b = c;\n            for (let j=0; j< m-i-1; j ++) b = this.square(b);\n\n            m = i;\n            c = this.square(b);\n            t = this.mul(t, c);\n            r = this.mul(r, b);\n        }\n\n        if (r > (this.p >> this.one)) {\n            r = this.neg(r);\n        }\n\n        return r;\n    }\n\n    normalize(a, b) {\n        a = BigInt(a,b);\n        if (a < 0) {\n            let na = -a;\n            if (na >= this.p) na = na % this.p;\n            return this.p - na;\n        } else {\n            return (a>= this.p) ? a%this.p : a;\n        }\n    }\n\n    random() {\n        const nBytes = (this.bitLength*2 / 8);\n        let res =this.zero;\n        for (let i=0; i<nBytes; i++) {\n            res = (res << BigInt(8)) + BigInt(getRandomBytes(1)[0]);\n        }\n        return res % this.p;\n    }\n\n    toString(a, base) {\n        base = base || 10;\n        let vs;\n        if ((a > this.half)&&(base == 10)) {\n            const v = this.p-a;\n            vs = \"-\"+v.toString(base);\n        } else {\n            vs = a.toString(base);\n        }\n        return vs;\n    }\n\n    isZero(a) {\n        return a == this.zero;\n    }\n\n    fromRng(rng) {\n        let v;\n        do {\n            v=this.zero;\n            for (let i=0; i<this.n64; i++) {\n                v += rng.nextU64() << BigInt(64 *i);\n            }\n            v &= this.mask;\n        } while (v >= this.p);\n        v = (v * this.Ri) % this.p;   // Convert from montgomery\n        return v;\n    }\n\n    fft(a) {\n        return this.FFT.fft(a);\n    }\n\n    ifft(a) {\n        return this.FFT.ifft(a);\n    }\n\n    // Returns a buffer with Little Endian Representation\n    toRprLE(buff, o, e) {\n        Scalar.toRprLE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Representation\n    toRprBE(buff, o, e) {\n        Scalar.toRprBE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Montgomery Representation\n    toRprBEM(buff, o, e) {\n        return this.toRprBE(buff, o, this.mul(this.R, e));\n    }\n\n    toRprLEM(buff, o, e) {\n        return this.toRprLE(buff, o, this.mul(this.R, e));\n    }\n\n\n    // Pases a buffer with Little Endian Representation\n    fromRprLE(buff, o) {\n        return Scalar.fromRprLE(buff, o, this.n8);\n    }\n\n    // Pases a buffer with Big Endian Representation\n    fromRprBE(buff, o) {\n        return Scalar.fromRprBE(buff, o, this.n8);\n    }\n\n    fromRprLEM(buff, o) {\n        return this.mul(this.fromRprLE(buff, o), this.Ri);\n    }\n\n    fromRprBEM(buff, o) {\n        return this.mul(this.fromRprBE(buff, o), this.Ri);\n    }\n\n    toObject(a) {\n        return a;\n    }\n}", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as Scalar from \"./scalar.js\";\n\n\nexport function mulScalar(F, base, e) {\n    let res;\n\n    if (Scalar.isZero(e)) return F.zero;\n\n    const n = Scalar.naf(e);\n\n    if (n[n.length-1] == 1) {\n        res = base;\n    } else if (n[n.length-1] == -1) {\n        res = F.neg(base);\n    } else {\n        throw new Error(\"invlaud NAF\");\n    }\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.double(res);\n\n        if (n[i] == 1) {\n            res = F.add(res, base);\n        } else if (n[i] == -1) {\n            res = F.sub(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n/*\nexports.mulScalar = (F, base, e) =>{\n    let res = F.zero;\n    let rem = bigInt(e);\n    let exp = base;\n\n    while (! rem.eq(bigInt.zero)) {\n        if (rem.and(bigInt.one).eq(bigInt.one)) {\n            res = F.add(res, exp);\n        }\n        exp = F.double(exp);\n        rem = rem.shiftRight(1);\n    }\n\n    return res;\n};\n*/\n\n\nexport function exp(F, base, e) {\n\n    if (Scalar.isZero(e)) return F.one;\n\n    const n = Scalar.bits(e);\n\n    if (n.length==0) return F.one;\n\n    let res = base;\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.square(res);\n\n        if (n[i]) {\n            res = F.mul(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n", "import * as Scalar from \"./scalar.js\";\n// Check here: https://eprint.iacr.org/2012/685.pdf\n\nexport default function buildSqrt (F) {\n    if ((F.m % 2) == 1) {\n        if (Scalar.eq(Scalar.mod(F.p, 4), 1 )) {\n            if (Scalar.eq(Scalar.mod(F.p, 8), 1 )) {\n                if (Scalar.eq(Scalar.mod(F.p, 16), 1 )) {\n                    // alg7_muller(F);\n                    alg5_tonelliShanks(F);\n                } else if (Scalar.eq(Scalar.mod(F.p, 16), 9 )) {\n                    alg4_kong(F);\n                } else {\n                    throw new Error(\"Field withot sqrt\");\n                }\n            } else if (Scalar.eq(Scalar.mod(F.p, 8), 5 )) {\n                alg3_atkin(F);\n            } else {\n                throw new Error(\"Field withot sqrt\");\n            }\n        } else if (Scalar.eq(Scalar.mod(F.p, 4), 3 )) {\n            alg2_shanks(F);\n        }\n    } else {\n        const pm2mod4 = Scalar.mod(Scalar.pow(F.p, F.m/2), 4);\n        if (pm2mod4 == 1) {\n            alg10_adj(F);\n        } else if (pm2mod4 == 3) {\n            alg9_adj(F);\n        } else {\n            alg8_complex(F);\n        }\n\n    }\n}\n\n\nfunction alg5_tonelliShanks(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n\n    F.sqrt_s = 0;\n    F.sqrt_t = Scalar.sub(F.sqrt_q, 1);\n\n    while (!Scalar.isOdd(F.sqrt_t)) {\n        F.sqrt_s = F.sqrt_s + 1;\n        F.sqrt_t = Scalar.div(F.sqrt_t, 2);\n    }\n\n    let c0 = F.one;\n\n    while (F.eq(c0, F.one)) {\n        const c = F.random();\n        F.sqrt_z = F.pow(c, F.sqrt_t);\n        c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s-1) );\n    }\n\n    F.sqrt_tm1d2 = Scalar.div(Scalar.sub(F.sqrt_t, 1),2);\n\n    F.sqrt = function(a) {\n        const F=this;\n        if (F.isZero(a)) return F.zero;\n        let w = F.pow(a, F.sqrt_tm1d2);\n        const a0 = F.pow( F.mul(F.square(w), a), 2 ** (F.sqrt_s-1) );\n        if (F.eq(a0, F.negone)) return null;\n\n        let v = F.sqrt_s;\n        let x = F.mul(a, w);\n        let b = F.mul(x, w);\n        let z = F.sqrt_z;\n        while (!F.eq(b, F.one)) {\n            let b2k = F.square(b);\n            let k=1;\n            while (!F.eq(b2k, F.one)) {\n                b2k = F.square(b2k);\n                k++;\n            }\n\n            w = z;\n            for (let i=0; i<v-k-1; i++) {\n                w = F.square(w);\n            }\n            z = F.square(w);\n            b = F.mul(b, z);\n            x = F.mul(x, w);\n            v = k;\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg4_kong(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 4 not implemented\");\n    };\n}\n\nfunction alg3_atkin(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 3 not implemented\");\n    };\n}\n\nfunction alg2_shanks(F) {\n\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n    F.sqrt_e1 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n\n    F.sqrt = function(a) {\n        if (this.isZero(a)) return this.zero;\n\n        // Test that have solution\n        const a1 = this.pow(a, this.sqrt_e1);\n\n        const a0 = this.mul(this.square(a1), a);\n\n        if ( this.eq(a0, this.negone) ) return null;\n\n        const x = this.mul(a1, a);\n\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg10_adj(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 10 not implemented\");\n    };\n}\n\nfunction alg9_adj(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m/2);\n    F.sqrt_e34 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n    F.sqrt_e12 = Scalar.div( Scalar.sub(F.sqrt_q, 1) , 2);\n\n    F.frobenius = function(n, x) {\n        if ((n%2) == 1) {\n            return F.conjugate(x);\n        } else {\n            return x;\n        }\n    };\n\n    F.sqrt = function(a) {\n        const F = this;\n        const a1 = F.pow(a, F.sqrt_e34);\n        const alfa = F.mul(F.square(a1), a);\n        const a0 = F.mul(F.frobenius(1, alfa), alfa);\n        if (F.eq(a0, F.negone)) return null;\n        const x0 = F.mul(a1, a);\n        let x;\n        if (F.eq(alfa, F.negone)) {\n            x = F.mul(x0, [F.F.zero, F.F.one]);\n        } else {\n            const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n            x = F.mul(b, x0);\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\n\nfunction alg8_complex(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 8 not implemented\");\n    };\n}\n", "import ChaCha from \"./chacha.js\";\nimport crypto from \"crypto\";\n\nexport function getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (process.browser) { // Browser\n        if (typeof globalThis.crypto !== \"undefined\") { // Supported\n            globalThis.crypto.getRandomValues(array);\n        } else { // fallback\n            for (let i=0; i<n; i++) {\n                array[i] = (Math.random()*4294967296)>>>0;\n            }\n        }\n    }\n    else { // NodeJS\n        crypto.randomFillSync(array);\n    }\n    return array;\n}\n\nexport function getRandomSeed() {\n    const arr = getRandomBytes(32);\n    const arrV = new Uint32Array(arr.buffer);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed.push(arrV[i]);\n    }\n    return seed;\n}\n\nlet threadRng = null;\n\nexport function getThreadRng() {\n    if (threadRng) return threadRng;\n    threadRng = new ChaCha(getRandomSeed());\n    return threadRng;\n}\n", "\n\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction quarterRound(st, a, b, c, d) {\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 16) | ((st[d]>>>16) & 0xFFFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 12) | ((st[b]>>>20) & 0xFFF)) >>> 0;\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 8) | ((st[d]>>>24) & 0xFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 7) | ((st[b]>>>25) & 0x7F)) >>> 0;\n}\n\nfunction doubleRound(st) {\n    quarterRound(st, 0, 4, 8,12);\n    quarterRound(st, 1, 5, 9,13);\n    quarterRound(st, 2, 6,10,14);\n    quarterRound(st, 3, 7,11,15);\n\n    quarterRound(st, 0, 5,10,15);\n    quarterRound(st, 1, 6,11,12);\n    quarterRound(st, 2, 7, 8,13);\n    quarterRound(st, 3, 4, 9,14);\n}\n\nexport default class ChaCha {\n\n    constructor(seed) {\n        seed = seed || [0,0,0,0,0,0,0,0];\n        this.state = [\n            0x61707865,\n            0x3320646E,\n            0x79622D32,\n            0x6B206574,\n            seed[0],\n            seed[1],\n            seed[2],\n            seed[3],\n            seed[4],\n            seed[5],\n            seed[6],\n            seed[7],\n            0,\n            0,\n            0,\n            0\n        ];\n        this.idx = 16;\n        this.buff = new Array(16);\n    }\n\n    nextU32() {\n        if (this.idx == 16) this.update();\n        return this.buff[this.idx++];\n    }\n\n    nextU64() {\n        return Scalar.add(Scalar.mul(this.nextU32(), 0x100000000), this.nextU32());\n    }\n\n    nextBool() {\n        return (this.nextU32() & 1) == 1;\n    }\n\n    update() {\n        // Copy the state\n        for (let i=0; i<16; i++) this.buff[i] = this.state[i];\n\n        // Apply the rounds\n        for (let i=0; i<10; i++) doubleRound(this.buff);\n\n        // Add to the initial\n        for (let i=0; i<16; i++) this.buff[i] = (this.buff[i] + this.state[i]) >>> 0;\n\n        this.idx = 0;\n\n        this.state[12] = (this.state[12] + 1) >>> 0;\n        if (this.state[12] != 0) return;\n        this.state[13] = (this.state[13] + 1) >>> 0;\n        if (this.state[13] != 0) return;\n        this.state[14] = (this.state[14] + 1) >>> 0;\n        if (this.state[14] != 0) return;\n        this.state[15] = (this.state[15] + 1) >>> 0;\n    }\n}\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class FFT {\n    constructor (G, F, opMulGF) {\n        this.F = F;\n        this.G = G;\n        this.opMulGF = opMulGF;\n\n        let rem = F.sqrt_t || F.t;\n        let s = F.sqrt_s || F.s;\n\n        let nqr = F.one;\n        while (F.eq(F.pow(nqr, F.half), F.one)) nqr = F.add(nqr, F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(nqr, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n        /*\n        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n        */\n        this._setRoots(Math.min(s, 15));\n    }\n\n    _setRoots(n) {\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots[i] = rootsi;\n        }\n    }\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res = __fft(this, p, bits, 0, 1);\n        return res;\n    }\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res =  __fft(this, p, bits, 0, 1);\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.opMulGF(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n    }\n\n\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.G.add(pall[offset], pall[offset + step]),\n            PF.G.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n        out[i+ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n    }\n\n    return out;\n}\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\n\nexport default class F2Field {\n    constructor(F, nonResidue) {\n        this.type=\"F2\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*2;\n        this.p = F.p;\n        this.n64 = F.n64*2;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n\n        buildSqrt(this);\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    conjugate(a) {\n        return [\n            a[0],\n            this.F.neg(a[1])\n        ];\n    }\n\n    mul(a, b) {\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n\n        return [\n            this.F.add( aA , this._mulByNonResidue(bB)),\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]),\n                    this.F.add(b[0], b[1])),\n                this.F.add(aA, bB))];\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);\n        const t1 = this.F.square(a[1]);\n        const t2 = this.F.sub(t0, this._mulByNonResidue(t1));\n        const t3 = this.F.inv(t2);\n        return [\n            this.F.mul(a[0], t3),\n            this.F.neg(this.F.mul( a[1], t3)) ];\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const ab = this.F.mul(a[0] , a[1]);\n\n        /*\n        [\n            (a + b) * (a + non_residue * b) - ab - non_residue * ab,\n            ab + ab\n        ];\n        */\n\n        return [\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]) ,\n                    this.F.add(\n                        a[0] ,\n                        this._mulByNonResidue(a[1]))),\n                this.F.add(\n                    ab,\n                    this._mulByNonResidue(ab))),\n            this.F.add(ab, ab)\n        ];\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        return [c0, c1];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        return false;\n    }\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBE(buff, o);\n        const c0 = this.F.fromRprBE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBEM(buff, o);\n        const c0 = this.F.fromRprBEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    toObject(a) {\n        return a;\n    }\n\n}\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\n\nexport default class F3Field {\n    constructor(F, nonResidue) {\n        this.type=\"F3\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*3;\n        this.p = F.p;\n        this.n64 = F.n64*3;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1]), this.F.copy(a[2])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1]),\n            this.F.add(a[2], b[2])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1]),\n            this.F.sub(a[2], b[2])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    mul(a, b) {\n\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n        const cC = this.F.mul(a[2] , b[2]);\n\n        return [\n            this.F.add(\n                aA,\n                this._mulByNonResidue(\n                    this.F.sub(\n                        this.F.mul(\n                            this.F.add(a[1], a[2]),\n                            this.F.add(b[1], b[2])),\n                        this.F.add(bB, cC)))),    // aA + non_residue*((b+c)*(B+C)-bB-cC),\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[1]),\n                        this.F.add(b[0], b[1])),\n                    this.F.add(aA, bB)),\n                this._mulByNonResidue( cC)),   // (a+b)*(A+B)-aA-bB+non_residue*cC\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[2]),\n                        this.F.add(b[0], b[2])),\n                    this.F.add(aA, cC)),\n                bB)];                           // (a+c)*(A+C)-aA+bB-cC)\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);             // t0 = a^2 ;\n        const t1 = this.F.square(a[1]);             // t1 = b^2 ;\n        const t2 = this.F.square(a[2]);             // t2 = c^2;\n        const t3 = this.F.mul(a[0],a[1]);           // t3 = ab\n        const t4 = this.F.mul(a[0],a[2]);           // t4 = ac\n        const t5 = this.F.mul(a[1],a[2]);           // t5 = bc;\n        // c0 = t0 - non_residue * t5;\n        const c0 = this.F.sub(t0, this._mulByNonResidue(t5));\n        // c1 = non_residue * t2 - t3;\n        const c1 = this.F.sub(this._mulByNonResidue(t2), t3);\n        const c2 = this.F.sub(t1, t4);              // c2 = t1-t4\n\n        // t6 = (a * c0 + non_residue * (c * c1 + b * c2)).inv();\n        const t6 =\n            this.F.inv(\n                this.F.add(\n                    this.F.mul(a[0], c0),\n                    this._mulByNonResidue(\n                        this.F.add(\n                            this.F.mul(a[2], c1),\n                            this.F.mul(a[1], c2)))));\n\n        return [\n            this.F.mul(t6, c0),         // t6*c0\n            this.F.mul(t6, c1),         // t6*c1\n            this.F.mul(t6, c2)];        // t6*c2\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const s0 = this.F.square(a[0]);                   // s0 = a^2\n        const ab = this.F.mul(a[0], a[1]);                // ab = a*b\n        const s1 = this.F.add(ab, ab);                    // s1 = 2ab;\n        const s2 = this.F.square(\n            this.F.add(this.F.sub(a[0],a[1]), a[2]));     // s2 = (a - b + c)^2;\n        const bc = this.F.mul(a[1],a[2]);                 // bc = b*c\n        const s3 = this.F.add(bc, bc);                    // s3 = 2*bc\n        const s4 = this.F.square(a[2]);                   // s4 = c^2\n\n\n        return [\n            this.F.add(\n                s0,\n                this._mulByNonResidue(s3)),           // s0 + non_residue * s3,\n            this.F.add(\n                s1,\n                this._mulByNonResidue(s4)),           // s1 + non_residue * s4,\n            this.F.sub(\n                this.F.add( this.F.add(s1, s2) , s3 ),\n                this.F.add(s0, s4))];                      // s1 + s2 + s3 - s0 - s4\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]) && this.F.isZero(a[2]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]) && this.F.eq(a[2], b[2]);\n    }\n\n    affine(a) {\n        return [this.F.affine(a[0]), this.F.affine(a[1]), this.F.affine(a[2])];\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])}, ${this.F.toString(a[2])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        return [c0, c1, c2];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        if (this.F.gt(b[1], a[1])) return false;\n        if (this.F.gt(a[2], b[2])) return true;\n        return false;\n    }\n\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n        this.F.toRprLE(buff, o+this.F.n8*2, e[2]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[2]);\n        this.F.toRprBE(buff, o+this.F.n8, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8*2, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprLEM(buff, o+this.F.n8*2, e[2]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[2]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8*2, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.n8);\n        const c2 = this.F.fromRprLE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBE(buff, o);\n        const c1 = this.F.fromRprBE(buff, o+this.n8);\n        const c0 = this.F.fromRprBE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.n8);\n        const c2 = this.F.fromRprLEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBEM(buff, o);\n        const c1 = this.F.fromRprBEM(buff, o+this.n8);\n        const c0 = this.F.fromRprBEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nimport * as fUtils from \"./futils.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction isGreatest(F, a) {\n    if (Array.isArray(a)) {\n        for (let i=a.length-1; i>=0; i--) {\n            if (!F.F.isZero(a[i])) {\n                return isGreatest(F.F, a[i]);\n            }\n        }\n        return 0;\n    } else {\n        const na = F.neg(a);\n        return Scalar.gt(a, na);\n    }\n}\n\n\nexport default class EC {\n\n    constructor(F, g) {\n        this.F = F;\n        this.g = g;\n        if (this.g.length == 2) this.g[2] = this.F.one;\n        this.zero = [this.F.zero, this.F.one, this.F.zero];\n    }\n\n    add(p1, p2) {\n\n        const F = this.F;\n\n        if (this.eq(p1, this.zero)) return p2;\n        if (this.eq(p2, this.zero)) return p1;\n\n        const res = new Array(3);\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );     // U1 = X1  * Z2Z2\n        const U2 = F.mul( p2[0] , Z1Z1 );     // U2 = X2  * Z1Z1\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);  // S1 = Y1 * Z2 * Z2Z2\n        const S2 = F.mul( p2[1] , Z1_cubed);  // S2 = Y2 * Z1 * Z1Z1\n\n        if (F.eq(U1,U2) && F.eq(S1,S2)) {\n            return this.double(p1);\n        }\n\n        const H = F.sub( U2 , U1 );                    // H = U2-U1\n\n        const S2_minus_S1 = F.sub( S2 , S1 );\n\n        const I = F.square( F.add(H,H) );         // I = (2 * H)^2\n        const J = F.mul( H , I );                      // J = H * I\n\n        const r = F.add( S2_minus_S1 , S2_minus_S1 );  // r = 2 * (S2-S1)\n        const V = F.mul( U1 , I );                     // V = U1 * I\n\n        res[0] =\n            F.sub(\n                F.sub( F.square(r) , J ),\n                F.add( V , V ));                       // X3 = r^2 - J - 2 * V\n\n        const S1_J = F.mul( S1 , J );\n\n        res[1] =\n            F.sub(\n                F.mul( r , F.sub(V,res[0])),\n                F.add( S1_J,S1_J ));                   // Y3 = r * (V-X3)-2 S1 J\n\n        res[2] =\n            F.mul(\n                H,\n                F.sub(\n                    F.square( F.add(p1[2],p2[2]) ),\n                    F.add( Z1Z1 , Z2Z2 )));            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2) * H\n\n        return res;\n    }\n\n    neg(p) {\n        return [p[0], this.F.neg(p[1]), p[2]];\n    }\n\n    sub(a, b) {\n        return this.add(a, this.neg(b));\n    }\n\n    double(p) {\n        const F = this.F;\n\n        const res = new Array(3);\n\n        if (this.eq(p, this.zero)) return p;\n\n        const A = F.square( p[0] );                    // A = X1^2\n        const B = F.square( p[1] );                    // B = Y1^2\n        const C = F.square( B );                       // C = B^2\n\n        let D =\n            F.sub(\n                F.square( F.add(p[0] , B )),\n                F.add( A , C));\n        D = F.add(D,D);                    // D = 2 * ((X1 + B)^2 - A - C)\n\n        const E = F.add( F.add(A,A), A);          // E = 3 * A\n        const FF =F.square( E );                       // F = E^2\n\n        res[0] = F.sub( FF , F.add(D,D) );         // X3 = F - 2 D\n\n        let eightC = F.add( C , C );\n        eightC = F.add( eightC , eightC );\n        eightC = F.add( eightC , eightC );\n\n        res[1] =\n            F.sub(\n                F.mul(\n                    E,\n                    F.sub( D, res[0] )),\n                eightC);                                    // Y3 = E * (D - X3) - 8 * C\n\n        const Y1Z1 = F.mul( p[1] , p[2] );\n        res[2] = F.add( Y1Z1 , Y1Z1 );                 // Z3 = 2 * Y1 * Z1\n\n        return res;\n    }\n\n    timesScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    affine(p) {\n        const F = this.F;\n        if (this.isZero(p)) {\n            return this.zero;\n        } else if (F.eq(p[2], F.one)) {\n            return p;\n        } else {\n            const Z_inv = F.inv(p[2]);\n            const Z2_inv = F.square(Z_inv);\n            const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n            const res = new Array(3);\n            res[0] = F.mul(p[0],Z2_inv);\n            res[1] = F.mul(p[1],Z3_inv);\n            res[2] = F.one;\n\n            return res;\n        }\n    }\n\n    multiAffine(arr) {\n        const keys = Object.keys(arr);\n        const F = this.F;\n        const accMul = new Array(keys.length+1);\n        accMul[0] = F.one;\n        for (let i = 0; i< keys.length; i++) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i+1] = accMul[i];\n            } else {\n                accMul[i+1] = F.mul(accMul[i], arr[keys[i]][2]);\n            }\n        }\n\n        accMul[keys.length] = F.inv(accMul[keys.length]);\n\n        for (let i = keys.length-1; i>=0; i--) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i] = accMul[i+1];\n                arr[keys[i]] = this.zero;\n            } else {\n                const Z_inv = F.mul(accMul[i], accMul[i+1]);\n                accMul[i] = F.mul(arr[keys[i]][2], accMul[i+1]);\n\n                const Z2_inv = F.square(Z_inv);\n                const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n                arr[keys[i]][0] = F.mul(arr[keys[i]][0],Z2_inv);\n                arr[keys[i]][1] = F.mul(arr[keys[i]][1],Z3_inv);\n                arr[keys[i]][2] = F.one;\n            }\n        }\n\n    }\n\n    eq(p1, p2) {\n        const F = this.F;\n\n        if (this.F.eq(p1[2], this.F.zero)) return this.F.eq(p2[2], this.F.zero);\n        if (this.F.eq(p2[2], this.F.zero)) return false;\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );\n        const U2 = F.mul( p2[0] , Z1Z1 );\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);\n        const S2 = F.mul( p2[1] , Z1_cubed);\n\n        return (F.eq(U1,U2) && F.eq(S1,S2));\n    }\n\n    isZero(p) {\n        return this.F.isZero(p[2]);\n    }\n\n    toString(p) {\n        const cp = this.affine(p);\n        return `[ ${this.F.toString(cp[0])} , ${this.F.toString(cp[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n            P[1] = F.sqrt(x3b);\n        } while ((P[1] == null)||(F.isZero[P]));\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        if (this.cofactor) {\n            P = this.mulScalar(P, this.cofactor);\n        }\n\n        P = this.affine(P);\n\n        return P;\n\n    }\n\n    toRprLE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLE(buff, o, p[0]);\n        this.F.toRprLE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprBE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n        this.F.toRprBE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEJM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n        this.F.toRprLEM(buff, o+2*this.F.n8, p[2]);\n    }\n\n\n    toRprBEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBEM(buff, o, p[0]);\n        this.F.toRprBEM(buff, o+this.F.n8, p[1]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLE(buff, o);\n        const y = this.F.fromRprLE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBE(buff, o);\n        const y = this.F.fromRprBE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEJM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        const z = this.F.fromRprLEM(buff, o+this.F.n8*2);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, z];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBEM(buff, o);\n        const y = this.F.fromRprBEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprCompressed(buff, o) {\n        const F = this.F;\n        const v = new Uint8Array(buff.buffer, o, F.n8);\n        if (v[0] & 0x40) return this.zero;\n        const P = new Array(3);\n\n        const greatest = ((v[0] & 0x80) != 0);\n        v[0] = v[0] & 0x7F;\n        P[0] = F.fromRprBE(buff, o);\n        if (greatest) v[0] = v[0] | 0x80;  // set back again the old value\n\n        const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        P[1] = F.sqrt(x3b);\n\n        if (P[1] === null) {\n            throw new Error(\"Invalid Point!\");\n        }\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        return P;\n    }\n\n    toRprCompressed(buff, o, p) {\n        p = this.affine(p);\n        const v = new Uint8Array(buff.buffer, o, this.F.n8);\n        if (this.isZero(p)) {\n            v.fill(0);\n            v[0] = 0x40;\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n\n        if (isGreatest(this.F, p[1])) {\n            v[0] = v[0] | 0x80;\n        }\n    }\n\n\n    fromRprUncompressed(buff, o) {\n        if (buff[0] & 0x40) return this.zero;\n\n        return this.fromRprBE(buff, o);\n    }\n\n    toRprUncompressed(buff, o, p) {\n        this.toRprBE(buff, o, p);\n\n        if (this.isZero(p)) {\n            buff[o] = buff[o] | 0x40;\n        }\n    }\n\n\n}\n\n\n", "import { buildBn128 as buildBn128wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bn128 = null;\n\nexport default async function buildBn128(singleThread, plugins) {\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBn128wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bn128wasm = {};\n\n    bn128wasm.code = moduleBuilder.build();\n    bn128wasm.pq = moduleBuilder.modules.f1m.pq;\n    bn128wasm.pr = moduleBuilder.modules.frm.pq;\n    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;\n    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;\n    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;\n    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;\n    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;\n    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;\n    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;\n    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;\n    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;\n    bn128wasm.n8q = 32;\n    bn128wasm.n8r = 32;\n    bn128wasm.q = moduleBuilder.modules.bn128.q;\n    bn128wasm.r = moduleBuilder.modules.bn128.r;\n\n    if ((!singleThread) && (globalThis.curve_bn128)) return globalThis.curve_bn128;\n    const params = {\n        name: \"bn128\",\n        wasm: bn128wasm,\n        q: Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\"),\n        r: Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\"),\n        n8q: 32,\n        n8r: 32,\n        cofactorG2: Scalar.e(\"30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bn128 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bn128 = curve;\n    }\n\n    return curve;\n}\n\n", "import WasmField1 from \"./wasm_field1.js\";\nimport WasmField2 from \"./wasm_field2.js\";\nimport WasmField3 from \"./wasm_field3.js\";\nimport WasmCurve from \"./wasm_curve.js\";\nimport buildThreadManager from \"./threadman.js\";\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchApplyKey from \"./engine_applykey.js\";\nimport buildPairing from \"./engine_pairing.js\";\nimport buildMultiExp from \"./engine_multiexp.js\";\nimport buildFFT from \"./engine_fft.js\";\n\nexport default async function buildEngine(params) {\n\n    const tm = await buildThreadManager(params.wasm, params.singleThread);\n\n\n    const curve = {};\n\n    curve.q = Scalar.e(params.wasm.q.toString());\n    curve.r = Scalar.e(params.wasm.r.toString());\n    curve.name = params.name;\n    curve.tm = tm;\n    curve.prePSize = params.wasm.prePSize;\n    curve.preQSize = params.wasm.preQSize;\n    curve.Fr = new WasmField1(tm, \"frm\", params.n8r, params.r);\n    curve.F1 = new WasmField1(tm, \"f1m\", params.n8q, params.q);\n    curve.F2 = new WasmField2(tm, \"f2m\", curve.F1);\n    curve.G1 = new WasmCurve(tm, \"g1m\", curve.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);\n    curve.G2 = new WasmCurve(tm, \"g2m\", curve.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);\n    curve.F6 = new WasmField3(tm, \"f6m\", curve.F2);\n    curve.F12 = new WasmField2(tm, \"ftm\", curve.F6);\n\n    curve.Gt = curve.F12;\n\n    buildBatchApplyKey(curve, \"G1\");\n    buildBatchApplyKey(curve, \"G2\");\n    buildBatchApplyKey(curve, \"Fr\");\n\n    buildMultiExp(curve, \"G1\");\n    buildMultiExp(curve, \"G2\");\n\n    buildFFT(curve, \"G1\");\n    buildFFT(curve, \"G2\");\n    buildFFT(curve, \"Fr\");\n\n    buildPairing(curve);\n\n    curve.array2buffer = function(arr, sG) {\n        const buff = new Uint8Array(sG*arr.length);\n\n        for (let i=0; i<arr.length; i++) {\n            buff.set(arr[i], i*sG);\n        }\n\n        return buff;\n    };\n\n    curve.buffer2array = function(buff , sG) {\n        const n= buff.byteLength / sG;\n        const arr = new Array(n);\n        for (let i=0; i<n; i++) {\n            arr[i] = buff.slice(i*sG, i*sG+sG);\n        }\n        return arr;\n    };\n\n    return curve;\n}\n\n\n", "import * as Scalar from \"./scalar.js\";\nimport * as utils from \"./utils.js\";\nimport { getThreadRng } from \"./random.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default class WasmField1 {\n\n    constructor(tm, prefix, n8, p) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.p = p;\n        this.n8 = n8;\n        this.type = \"F1\";\n        this.m = 1;\n\n        this.half = Scalar.shiftRight(p, Scalar.one);\n        this.bitLength = Scalar.bitLength(p);\n        this.mask = Scalar.sub(Scalar.shiftLeft(Scalar.one, this.bitLength), Scalar.one);\n\n        this.pOp1 = tm.alloc(n8);\n        this.pOp2 = tm.alloc(n8);\n        this.pOp3 = tm.alloc(n8);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = this.tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.n64 = Math.floor(n8/8);\n        this.n32 = Math.floor(n8/4);\n\n        if(this.n64*8 != this.n8) {\n            throw new Error(\"n8 must be a multiple of 8\");\n        }\n\n        this.half = Scalar.shiftRight(this.p, Scalar.one);\n        this.nqr = this.two;\n        let r = this.exp(this.nqr, this.half);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.add(this.nqr, this.one);\n            r = this.exp(this.nqr, this.half);\n        }\n\n        this.shift = this.mul(this.nqr, this.nqr);\n        this.shiftInv = this.inv(this.shift);\n\n        this.s = 0;\n        let t = Scalar.sub(this.p, Scalar.one);\n\n        while ( !Scalar.isOdd(t) ) {\n            this.s = this.s + 1;\n            t = Scalar.shiftRight(t, Scalar.one);\n        }\n\n        this.w = [];\n        this.w[this.s] = this.exp(this.nqr, t);\n\n        for (let i= this.s-1; i>=0; i--) {\n            this.w[i] = this.square(this.w[i+1]);\n        }\n\n        if (!this.eq(this.w[0], this.one)) {\n            throw new Error(\"Error calculating roots of unity\");\n        }\n\n        this.batchToMontgomery = buildBatchConvert(tm, prefix + \"_batchToMontgomery\", this.n8, this.n8);\n        this.batchFromMontgomery = buildBatchConvert(tm, prefix + \"_batchFromMontgomery\", this.n8, this.n8);\n    }\n\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        let ra = Scalar.e(a, b);\n        if (Scalar.isNegative(ra)) {\n            ra = Scalar.neg(ra);\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n            ra = Scalar.sub(this.p, ra);\n        } else {\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n        }\n        const buff = utils.leInt2Buff(ra, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toString(a, radix) {\n        const an = this.fromMontgomery(a);\n        const s = Scalar.fromRprLE(an, 0);\n        return Scalar.toString(s, radix);\n    }\n\n    fromRng(rng) {\n        let v;\n        const buff = new Uint8Array(this.n8);\n        do {\n            v = Scalar.zero;\n            for (let i=0; i<this.n64; i++) {\n                v = Scalar.add(v,  Scalar.shiftLeft(rng.nextU64(), 64*i));\n            }\n            v = Scalar.band(v, this.mask);\n        } while (Scalar.geq(v, this.p));\n        Scalar.toRprLE(buff, 0, v, this.n8);\n        return buff;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const an = this.fromMontgomery(a);\n        return Scalar.fromRprLE(an, 0);\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.n8);\n        Scalar.toRprLE(buff, 0, a, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toRprLE(buff, offset, a) {\n        buff.set(this.fromMontgomery(a), offset);\n    }\n\n    toRprBE(buff, offset, a) {\n        const buff2 = this.fromMontgomery(a);\n        for (let i=0; i<this.n8/2; i++) {\n            const aux = buff2[i];\n            buff2[i] = buff2[this.n8-1-i];\n            buff2[this.n8-1-i] = aux;\n        }\n        buff.set(buff2, offset);\n    }\n\n    fromRprLE(buff, offset) {\n        offset = offset || 0;\n        const res = buff.slice(offset, offset + this.n8);\n        return this.toMontgomery(res);\n    }\n\n    async batchInverse(buffIn) {\n        let returnArray = false;\n        const sIn = this.n8;\n        const sOut = this.n8;\n\n        if (Array.isArray(buffIn)) {\n            buffIn = utils.array2buffer(buffIn, sIn );\n            returnArray = true;\n        } else {\n            buffIn = buffIn.slice(0, buffIn.byteLength);\n        }\n\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/this.tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<this.tm.concurrency; i++) {\n            let n;\n            if (i< this.tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: this.prefix + \"_batchInverse\", params: [\n                    {var: 0},\n                    {val: sIn},\n                    {val: n},\n                    {var: 1},\n                    {val: sOut},\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                this.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        if (returnArray) {\n            return utils.buffer2array(fullBuffOut, sOut);\n        } else {\n            return fullBuffOut;\n        }\n\n    }\n\n}\n\n\n", "/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\n\nexport function stringifyBigInts(o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return Scalar.fromRprLE(o, 0);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigInts);\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyBigInts(o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return BigInt(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return BigInt(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyBigInts);\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function beBuff2int(buff) {\n    let res = BigInt(0);\n    let i = buff.length;\n    let offset = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i > 0) {\n        if (i >= 4) {\n            i -= 4;\n            res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);\n            offset += 4;\n        } else if (i >= 2) {\n            i -= 2;\n            res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);\n            offset += 2;\n        } else {\n            i -= 1;\n            res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);\n            offset += 1;\n        }\n    }\n    return res;\n}\n\nexport function beInt2Buff(n, len) {\n    let r = n;\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = len;\n    while (o > 0) {\n        if (o - 4 >= 0) {\n            o -= 4;\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)));\n            r = r >> BigInt(32);\n        } else if (o - 2 >= 0) {\n            o -= 2;\n            buffV.setUint16(o, Number(r & BigInt(0xffff)));\n            r = r >> BigInt(16);\n        } else {\n            o -= 1;\n            buffV.setUint8(o, Number(r & BigInt(0xff)));\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function leBuff2int(buff) {\n    let res = BigInt(0);\n    let i = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i < buff.length) {\n        if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);\n            i += 4;\n        } else if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);\n            i += 2;\n        } else {\n            res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);\n            i += 1;\n        }\n    }\n    return res;\n}\n\nexport function leInt2Buff(n, len) {\n    let r = n;\n    if (typeof len === \"undefined\") {\n        len = Math.floor((Scalar.bitLength(n) - 1) / 8) + 1;\n        if (len == 0) len = 1;\n    }\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = 0;\n    while (o < len) {\n        if (o + 4 <= len) {\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)), true);\n            o += 4;\n            r = r >> BigInt(32);\n        } else if (o + 2 <= len) {\n            buffV.setUint16(Number(o, r & BigInt(0xffff)), true);\n            o += 2;\n            r = r >> BigInt(16);\n        } else {\n            buffV.setUint8(Number(o, r & BigInt(0xff)), true);\n            o += 1;\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function stringifyFElements(F, o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return F.toString(F.e(o));\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyFElements(F, o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return F.e(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return F.e(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nconst _revTable = [];\nfor (let i = 0; i < 256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res = 0;\n    let a = idx;\n    for (let i = 0; i < bits; i++) {\n        res <<= 1;\n        res = res | (a & 1);\n        a >>= 1;\n    }\n    return res;\n}\n\nexport function bitReverse(idx, bits) {\n    return (\n        (_revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xff] << 8) |\n        (_revTable[(idx >>> 8) & 0xff] << 16) |\n        (_revTable[idx & 0xff] << 24)) >>>\n        (32 - bits)\n    );\n}\n\nexport function log2(V) {\n    return (\n        ((V & 0xffff0000) !== 0 ? ((V &= 0xffff0000), 16) : 0) |\n        ((V & 0xff00ff00) !== 0 ? ((V &= 0xff00ff00), 8) : 0) |\n        ((V & 0xf0f0f0f0) !== 0 ? ((V &= 0xf0f0f0f0), 4) : 0) |\n        ((V & 0xcccccccc) !== 0 ? ((V &= 0xcccccccc), 2) : 0) |\n        ((V & 0xaaaaaaaa) !== 0)\n    );\n}\n\nexport function buffReverseBits(buff, eSize) {\n    const n = buff.byteLength / eSize;\n    const bits = log2(n);\n    if (n != 1 << bits) {\n        throw new Error(\"Invalid number of pointers\");\n    }\n    for (let i = 0; i < n; i++) {\n        const r = bitReverse(i, bits);\n        if (i > r) {\n            const tmp = buff.slice(i * eSize, (i + 1) * eSize);\n            buff.set(buff.slice(r * eSize, (r + 1) * eSize), i * eSize);\n            buff.set(tmp, r * eSize);\n        }\n    }\n}\n\nexport function array2buffer(arr, sG) {\n    const buff = new Uint8Array(sG * arr.length);\n\n    for (let i = 0; i < arr.length; i++) {\n        buff.set(arr[i], i * sG);\n    }\n\n    return buff;\n}\n\nexport function buffer2array(buff, sG) {\n    const n = buff.byteLength / sG;\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = buff.slice(i * sG, i * sG + sG);\n    }\n    return arr;\n}\n", "import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchConvert(tm, fnName, sIn, sOut) {\n    return async function batchConvert(buffIn) {\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1}\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n", "\nconst PAGE_SIZE = 1<<30;\n\nexport default class BigBuffer {\n\n    constructor(size) {\n        this.buffers = [];\n        this.byteLength = size;\n        for (let i=0; i<size; i+= PAGE_SIZE) {\n            const n = Math.min(size-i, PAGE_SIZE);\n            this.buffers.push(new Uint8Array(n));\n        }\n\n    }\n\n    slice(fr, to) {\n        if ( to === undefined ) to = this.byteLength;\n        if ( fr === undefined ) fr = 0;\n        const len = to-fr;\n\n        const firstPage = Math.floor(fr / PAGE_SIZE);\n        const lastPage = Math.floor((fr+len-1) / PAGE_SIZE);\n\n        if ((firstPage == lastPage)||(len==0))\n            return this.buffers[firstPage].slice(fr%PAGE_SIZE, fr%PAGE_SIZE + len);\n\n        let buff;\n\n        let p = firstPage;\n        let o = fr % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset+o, l);\n            if (l == len) return srcView.slice();\n            if (!buff) {\n                if (len <= PAGE_SIZE) {\n                    buff = new Uint8Array(len);\n                } else {\n                    buff = new BigBuffer(len);\n                }\n            }\n            buff.set(srcView, len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        return buff;\n    }\n\n    set(buff, offset) {\n        if (offset === undefined) offset = 0;\n\n        const len = buff.byteLength;\n\n        if (len==0) return;\n\n        const firstPage = Math.floor(offset / PAGE_SIZE);\n        const lastPage = Math.floor((offset+len-1) / PAGE_SIZE);\n\n        if (firstPage == lastPage) {\n            if ((buff instanceof BigBuffer)&&(buff.buffers.length==1)) {\n                return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);\n            } else {\n                return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);\n            }\n\n        }\n\n\n        let p = firstPage;\n        let o = offset % PAGE_SIZE;\n        let r = len;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice( len -r, len -r+l);\n            const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n    }\n}\n", "import { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField2 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F2\";\n        this.m = F.m * 2;\n        this.n8 = this.F.n8*2;\n        this.n32 = this.F.n32*2;\n        this.n64 = this.F.n64*2;\n\n        this.pOp1 = tm.alloc(F.n8*2);\n        this.pOp2 = tm.alloc(F.n8*2);\n        this.pOp3 = tm.alloc(F.n8*2);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    mul1(a,b) {\n        return this.op2(\"_mul1\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 2)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const res = new Uint8Array(this.F.n8*2);\n            res.set(c1);\n            res.set(c2, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F2\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8), radix);\n        return `[${s1}, ${s2}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*2);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        return [c1, c2];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8);\n    }\n\n}\n\n", "\n\nimport { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField3 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F3\";\n        this.m = F.m * 3;\n        this.n8 = this.F.n8*3;\n        this.n32 = this.F.n32*3;\n        this.n64 = this.F.n64*3;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 3)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const c3 = this.F.e(a[2], b);\n            const res = new Uint8Array(this.F.n8*3);\n            res.set(c1);\n            res.set(c2, this.F.n8);\n            res.set(c3, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F3\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n        const s3 = this.F.toString(a.slice(this.F.n8*2), radix);\n        return `[${s1}, ${s2}, ${s3}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const c3 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*3);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        res.set(c3, this.F.n8*2);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        const c3 = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        return [c1, c2, c3];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*3);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        const b3 = this.F.fromObject(a[2]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        buff.set(b3, this.F.n8*2);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8, this.F.n8*2);\n    }\n\n    c3(a) {\n        return a.slice(this.F.n8*2);\n    }\n\n}\n\n\n", "\n\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\n\nexport default class WasmCurve {\n\n    constructor(tm, prefix, F, pGen, pGb, cofactor) {\n        this.tm = tm;\n        this.prefix = prefix;\n        this.F = F;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, F.n8*3);\n        this.tm.instance.exports[prefix + \"_zeroAffine\"](this.pOp1);\n        this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8*2);\n        this.one = this.tm.getBuff(pGen, F.n8*3);\n        this.g = this.one;\n        this.oneAffine = this.tm.getBuff(pGen, F.n8*2);\n        this.gAffine = this.oneAffine;\n        this.b = this.tm.getBuff(pGb, F.n8);\n\n        if (cofactor) {\n            this.cofactor = Scalar.toLEBuff(cofactor);\n        }\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.batchLEMtoC = buildBatchConvert(tm, prefix + \"_batchLEMtoC\", F.n8*2, F.n8);\n        this.batchLEMtoU = buildBatchConvert(tm, prefix + \"_batchLEMtoU\", F.n8*2, F.n8*2);\n        this.batchCtoLEM = buildBatchConvert(tm, prefix + \"_batchCtoLEM\", F.n8, F.n8*2);\n        this.batchUtoLEM = buildBatchConvert(tm, prefix + \"_batchUtoLEM\", F.n8*2, F.n8*2);\n        this.batchToJacobian = buildBatchConvert(tm, prefix + \"_batchToJacobian\", F.n8*2, F.n8*3);\n        this.batchToAffine = buildBatchConvert(tm, prefix + \"_batchToAffine\", F.n8*3, F.n8*2);\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op2bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op1Affine(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*2);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_add\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_addMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    sub(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_sub\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_subMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    neg(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_neg\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Affine(\"_negAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    double(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_double\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_doubleAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isZero(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Bool(\"_isZero\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Bool(\"_isZeroAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    timesScalar(a, s) {\n        if (!(s instanceof Uint8Array)) {\n            s = Scalar.toLEBuff(Scalar.e(s));\n        }\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesScalar\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesScalarAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    timesFr(a, s) {\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesFr\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesFrAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    eq(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eq\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eqMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toAffine(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Affine(\"_toAffine\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return a;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toJacobian(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return a;\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_toJacobian\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toRprUncompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoU\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n        arr.set(res, offset);\n    }\n\n    fromRprUncompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8*2);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_UtoLEM\"](this.pOp1, this.pOp1);\n        return this.tm.getBuff(this.pOp1, this.F.n8*2);\n    }\n\n    toRprCompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoC\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8);\n        arr.set(res, offset);\n    }\n\n    fromRprCompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_CtoLEM\"](this.pOp1, this.pOp2);\n        return this.tm.getBuff(this.pOp2, this.F.n8*2);\n    }\n\n    toUncompressed(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        this.toRprUncompressed(buff, 0, a);\n        return buff;\n    }\n\n    toRprLEM(arr, offset, a) {\n        if (a.byteLength == this.F.n8*2) {\n            arr.set(a, offset);\n            return;\n        } else if (a.byteLength == this.F.n8*3) {\n            this.tm.setBuff(this.pOp1, a);\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n            const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n            arr.set(res, offset);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    fromRprLEM(arr, offset) {\n        offset = offset || 0;\n        return arr.slice(offset, offset+this.F.n8*2);\n    }\n\n    toString(a, radix) {\n        if (a.byteLength == this.F.n8*3) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n            const z = this.F.toString(a.slice(this.F.n8*2), radix);\n            return `[ ${x}, ${y}, ${z} ]`;\n        } else if (a.byteLength == this.F.n8*2) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8), radix);\n            return `[ ${x}, ${y} ]`;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isValid(a) {\n        if (this.isZero(a)) return true;\n        const F = this.F;\n        const aa = this.toAffine(a);\n        const x = aa.slice(0, this.F.n8);\n        const y = aa.slice(this.F.n8, this.F.n8*2);\n        const x3b = F.add(F.mul(F.square(x),x), this.b);\n        const y2 = F.square(y);\n        return F.eq(x3b, y2);\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        let x3b;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        } while (!F.isSquare(x3b));\n\n        P[1] = F.sqrt(x3b);\n\n        const s = F.isNegative(P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n\n        let Pbuff = new Uint8Array(this.F.n8*2);\n        Pbuff.set(P[0]);\n        Pbuff.set(P[1], this.F.n8);\n\n        if (this.cofactor) {\n            Pbuff = this.timesScalar(Pbuff, this.cofactor);\n        }\n\n        return Pbuff;\n    }\n\n\n\n    toObject(a) {\n        if (this.isZero(a)) {\n            return [\n                this.F.toObject(this.F.zero),\n                this.F.toObject(this.F.one),\n                this.F.toObject(this.F.zero),\n            ];\n        }\n        const x = this.F.toObject(a.slice(0, this.F.n8));\n        const y = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        let z;\n        if (a.byteLength == this.F.n8*3) {\n            z = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        } else {\n            z = this.F.toObject(this.F.one);\n        }\n        return [x, y, z];\n    }\n\n    fromObject(a) {\n        const x = this.F.fromObject(a[0]);\n        const y = this.F.fromObject(a[1]);\n        let z;\n        if (a.length==3) {\n            z = this.F.fromObject(a[2]);\n        } else {\n            z = this.F.one;\n        }\n        if (this.F.isZero(z, this.F.one)) {\n            return this.zeroAffine;\n        } else if (this.F.eq(z, this.F.one)) {\n            const buff = new Uint8Array(this.F.n8*2);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            return buff;\n        } else {\n            const buff = new Uint8Array(this.F.n8*3);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            buff.set(z, this.F.n8*2);\n            return buff;\n        }\n    }\n\n    e(a) {\n        if (a instanceof Uint8Array) return a;\n        return this.fromObject(a);\n    }\n\n    x(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(0, this.F.n8);\n    }\n\n    y(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(this.F.n8);\n    }\n\n}\n\n\n", "/* global navigator, WebAssembly */\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// const MEM_SIZE = 1000;  // Memory size in 64K Pakes (512Mb)\nconst MEM_SIZE = 25;  // Memory size in 64K Pakes (1600Kb)\n\n\nimport thread from \"./threadman_thread.js\";\nimport os from \"os\";\nimport Worker from \"web-worker\";\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject)=> {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction stringToBase64(str) {\n    if (process.browser) {\n        return globalThis.btoa(str);\n    } else {\n        return Buffer.from(str).toString(\"base64\");\n    }\n}\n\nconst threadSource = stringToBase64(\"(\" + thread.toString() + \")(self)\");\nconst workerSource = \"data:application/javascript;base64,\" + threadSource;\n\n\n\nexport default async function buildThreadManager(wasm, singleThread) {\n    const tm = new ThreadManager();\n\n    tm.memory = new WebAssembly.Memory({initial:MEM_SIZE});\n    tm.u8 = new Uint8Array(tm.memory.buffer);\n    tm.u32 = new Uint32Array(tm.memory.buffer);\n\n    const wasmModule = await WebAssembly.compile(wasm.code);\n\n    tm.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": tm.memory\n        }\n    });\n\n    tm.singleThread = singleThread;\n    tm.initalPFree = tm.u32[0];   // Save the Pointer to free space.\n    tm.pq = wasm.pq;\n    tm.pr = wasm.pr;\n    tm.pG1gen = wasm.pG1gen;\n    tm.pG1zero = wasm.pG1zero;\n    tm.pG2gen = wasm.pG2gen;\n    tm.pG2zero = wasm.pG2zero;\n    tm.pOneT = wasm.pOneT;\n\n    //    tm.pTmp0 = tm.alloc(curve.G2.F.n8*3);\n    //    tm.pTmp1 = tm.alloc(curve.G2.F.n8*3);\n\n\n    if (singleThread) {\n        tm.code = wasm.code;\n        tm.taskManager = thread();\n        await tm.taskManager([{\n            cmd: \"INIT\",\n            init: MEM_SIZE,\n            code: tm.code.slice()\n        }]);\n        tm.concurrency  = 1;\n    } else {\n        tm.workers = [];\n        tm.pendingDeferreds = [];\n        tm.working = [];\n\n        let concurrency;\n\n        if ((typeof(navigator) === \"object\") && navigator.hardwareConcurrency) {\n            concurrency = navigator.hardwareConcurrency;\n        } else {\n            concurrency = os.cpus().length;\n        }\n\n        if(concurrency == 0){\n            concurrency = 2;\n        }\n\n        // Limit to 64 threads for memory reasons.\n        if (concurrency>64) concurrency=64;\n        tm.concurrency = concurrency;\n\n        for (let i = 0; i<concurrency; i++) {\n\n            tm.workers[i] = new Worker(workerSource);\n\n            tm.workers[i].addEventListener(\"message\", getOnMsg(i));\n\n            tm.working[i]=false;\n        }\n\n        const initPromises = [];\n        for (let i=0; i<tm.workers.length;i++) {\n            const copyCode = wasm.code.slice();\n            initPromises.push(tm.postAction(i, [{\n                cmd: \"INIT\",\n                init: MEM_SIZE,\n                code: copyCode\n            }], [copyCode.buffer]));\n        }\n\n        await Promise.all(initPromises);\n\n    }\n    return tm;\n\n    function getOnMsg(i) {\n        return function(e) {\n            let data;\n            if ((e)&&(e.data)) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            tm.working[i]=false;\n            tm.pendingDeferreds[i].resolve(data);\n            tm.processWorks();\n        };\n    }\n\n}\n\nclass ThreadManager {\n    constructor() {\n        this.actionQueue = [];\n        this.oldPFree = 0;\n    }\n\n    startSyncOp() {\n        if (this.oldPFree != 0) throw new Error(\"Sync operation in progress\");\n        this.oldPFree = this.u32[0];\n    }\n\n    endSyncOp() {\n        if (this.oldPFree == 0) throw new Error(\"No sync operation in progress\");\n        this.u32[0] = this.oldPFree;\n        this.oldPFree = 0;\n    }\n\n    postAction(workerId, e, transfers, _deferred) {\n        if (this.working[workerId]) {\n            throw new Error(\"Posting a job t a working worker\");\n        }\n        this.working[workerId] = true;\n\n        this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();\n        this.workers[workerId].postMessage(e, transfers);\n\n        return this.pendingDeferreds[workerId].promise;\n    }\n\n    processWorks() {\n        for (let i=0; (i<this.workers.length)&&(this.actionQueue.length > 0); i++) {\n            if (this.working[i] == false) {\n                const work = this.actionQueue.shift();\n                this.postAction(i, work.data, work.transfers, work.deferred);\n            }\n        }\n    }\n\n    queueAction(actionData, transfers) {\n        const d = new Deferred();\n\n        if (this.singleThread) {\n            const res = this.taskManager(actionData);\n            d.resolve(res);\n        } else {\n            this.actionQueue.push({\n                data: actionData,\n                transfers: transfers,\n                deferred: d\n            });\n            this.processWorks();\n        }\n        return d.promise;\n    }\n\n    resetMemory() {\n        this.u32[0] = this.initalPFree;\n    }\n\n    allocBuff(buff) {\n        const pointer = this.alloc(buff.byteLength);\n        this.setBuff(pointer, buff);\n        return pointer;\n    }\n\n    getBuff(pointer, length) {\n        return this.u8.slice(pointer, pointer+ length);\n    }\n\n    setBuff(pointer, buffer) {\n        this.u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    alloc(length) {\n        while (this.u32[0] & 3) this.u32[0]++;  // Return always aligned pointers\n        const res = this.u32[0];\n        this.u32[0] += length;\n        return res;\n    }\n\n    async terminate() {\n        for (let i=0; i<this.workers.length; i++) {\n            this.workers[i].postMessage([{cmd: \"TERMINATE\"}]);\n        }\n        await sleep(200);\n    }\n\n}\n", "/* global WebAssembly */\n\nexport default function thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == \"INIT\") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == \"TERMINATE\") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == \"INIT\") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case \"ALLOCSET\":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case \"ALLOC\":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case \"SET\":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case \"CALL\": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== \"undefined\") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != \"undefined\") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case \"GET\":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error(\"Invalid cmd\");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}\n", "import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchApplyKey(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = curve.tm;\n\n    curve[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        let fnName, fnAffine;\n        let sGin, sGmid, sGout;\n        if (groupName == \"G1\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g1m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g1m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g1m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g2m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g2m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g2m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_batchApplyKey\";\n            sGin = G.n8;\n            sGmid = G.n8;\n            sGout = G.n8;\n        } else {\n            throw new Error(\"Invalid group: \" + groupName);\n        }\n        const nPoints = Math.floor(buff.byteLength / sGin);\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        inc = Fr.e(inc);\n        let t = Fr.e(first);\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({\n                cmd: \"ALLOCSET\",\n                var: 0,\n                buff: buff.slice(i*pointsPerChunk*sGin, i*pointsPerChunk*sGin + n*sGin)\n            });\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: t});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: inc});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*Math.max(sGmid, sGout)});\n            task.push({\n                cmd: \"CALL\",\n                fnName: fnName,\n                params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1},\n                    {var: 2},\n                    {var:3}\n                ]\n            });\n            if (fnAffine) {\n                task.push({\n                    cmd: \"CALL\",\n                    fnName: fnAffine,\n                    params: [\n                        {var: 3},\n                        {val: n},\n                        {var: 3},\n                    ]\n                });\n            }\n            task.push({cmd: \"GET\", out: 0, var: 3, len: n*sGout});\n\n            opPromises.push(tm.queueAction(task));\n            t = Fr.mul(t, Fr.exp(inc, n));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let outBuff;\n        if (buff instanceof BigBuffer) {\n            outBuff = new BigBuffer(nPoints*sGout);\n        } else {\n            outBuff = new Uint8Array(nPoints*sGout);\n        }\n\n        let p=0;\n        for (let i=0; i<result.length; i++) {\n            outBuff.set(result[i][0], p);\n            p += result[i][0].byteLength;\n        }\n\n        return outBuff;\n    };\n}\n", "\nexport default function buildPairing(curve) {\n    const tm = curve.tm;\n    curve.pairing = function pairing(a, b) {\n\n        tm.startSyncOp();\n        const pA = tm.allocBuff(curve.G1.toJacobian(a));\n        const pB = tm.allocBuff(curve.G2.toJacobian(b));\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports[curve.name + \"_pairing\"](pA, pB, pRes);\n\n        const res = tm.getBuff(pRes, curve.Gt.n8);\n\n        tm.endSyncOp();\n        return res;\n    };\n\n    curve.pairingEq = async function pairingEq() {\n        let  buffCt;\n        let nEqs;\n        if ((arguments.length % 2) == 1) {\n            buffCt = arguments[arguments.length-1];\n            nEqs = (arguments.length -1) /2;\n        } else {\n            buffCt = curve.Gt.one;\n            nEqs = arguments.length /2;\n        }\n\n        const opPromises = [];\n        for (let i=0; i<nEqs; i++) {\n\n            const task = [];\n\n            const g1Buff = curve.G1.toJacobian(arguments[i*2]);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: g1Buff});\n            task.push({cmd: \"ALLOC\", var: 1, len: curve.prePSize});\n\n            const g2Buff = curve.G2.toJacobian(arguments[i*2 +1]);\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: g2Buff});\n            task.push({cmd: \"ALLOC\", var: 3, len: curve.preQSize});\n\n            task.push({cmd: \"ALLOC\", var: 4, len: curve.Gt.n8});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG1\", params: [\n                {var: 0},\n                {var: 1}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG2\", params: [\n                {var: 2},\n                {var: 3}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_millerLoop\", params: [\n                {var: 1},\n                {var: 3},\n                {var: 4}\n            ]});\n\n            task.push({cmd: \"GET\", out: 0, var: 4, len: curve.Gt.n8});\n\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        tm.startSyncOp();\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports.ftm_one(pRes);\n\n        for (let i=0; i<result.length; i++) {\n            const pMR = tm.allocBuff(result[i][0]);\n            tm.instance.exports.ftm_mul(pRes, pMR, pRes);\n        }\n        tm.instance.exports[curve.name + \"_finalExponentiation\"](pRes, pRes);\n\n        const pCt = tm.allocBuff(buffCt);\n\n        const r = !!tm.instance.exports.ftm_eq(pRes, pCt);\n\n        tm.endSyncOp();\n\n        return r;\n    };\n\n    curve.prepareG1 = function(p) {\n        this.tm.startSyncOp();\n        const pP = this.tm.allocBuff(p);\n        const pPrepP = this.tm.alloc(this.prePSize);\n        this.tm.instance.exports[this.name + \"_prepareG1\"](pP, pPrepP);\n        const res = this.tm.getBuff(pPrepP, this.prePSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.prepareG2 = function(q) {\n        this.tm.startSyncOp();\n        const pQ = this.tm.allocBuff(q);\n        const pPrepQ = this.tm.alloc(this.preQSize);\n        this.tm.instance.exports[this.name + \"_prepareG2\"](pQ, pPrepQ);\n        const res = this.tm.getBuff(pPrepQ, this.preQSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.millerLoop = function(preP, preQ) {\n        this.tm.startSyncOp();\n        const pPreP = this.tm.allocBuff(preP);\n        const pPreQ = this.tm.allocBuff(preQ);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_millerLoop\"](pPreP, pPreQ, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.finalExponentiation = function(a) {\n        this.tm.startSyncOp();\n        const pA = this.tm.allocBuff(a);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_finalExponentiation\"](pA, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n}\n", "import { log2 } from \"./utils.js\";\n\nconst pTSizes = [\n    1 ,  1,  1,  1,    2,  3,  4,  5,\n    6 ,  7,  7,  8,    9, 10, 11, 12,\n    13, 13, 14, 15,   16, 16, 17, 17,\n    17, 17, 17, 17,   17, 17, 17, 17\n];\n\nexport default function buildMultiexp(curve, groupName) {\n    const G = curve[groupName];\n    const tm = G.tm;\n    async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {\n        if ( ! (buffBases instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n        }\n        if ( ! (buffScalars instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n        }\n        inType = inType || \"affine\";\n\n        let sGIn;\n        let fnName;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                fnName = \"g1m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g1m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                fnName = \"g2m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g2m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff: buffBases},\n                {cmd: \"ALLOCSET\", var: 1, buff: buffScalars},\n                {cmd: \"ALLOC\", var: 2, len: G.F.n8*3},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {var: 1},\n                    {val: sScalar},\n                    {val: nPoints},\n                    {val: i*bitChunkSize},\n                    {val: Math.min(sScalar*8 - i*bitChunkSize, bitChunkSize)},\n                    {var: 2}\n                ]},\n                {cmd: \"GET\", out: 0, var: 2, len: G.F.n8*3}\n            ];\n            opPromises.push(\n                G.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            if (!G.isZero(res)) {\n                for (let j=0; j<bitChunkSize; j++) res = G.double(res);\n            }\n            res = G.add(res, result[i][0]);\n        }\n\n        return res;\n    }\n\n    async function _multiExp(buffBases, buffScalars, inType, logger, logText) {\n        const MAX_CHUNK_SIZE = 1 << 22;\n        const MIN_CHUNK_SIZE = 1 << 10;\n        let sGIn;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        let chunkSize;\n        chunkSize = Math.floor(nPoints / (tm.concurrency /nChunks));\n        if (chunkSize>MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n        if (chunkSize<MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n\n        const opPromises = [];\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n            const buffBasesChunk = buffBases.slice(i*sGIn, (i+n)*sGIn);\n            const buffScalarsChunk = buffScalars.slice(i*sScalar, (i+n)*sScalar);\n            opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then( (r) => {\n                if (logger) logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);\n                return r;\n            }));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            res = G.add(res, result[i]);\n        }\n\n        return res;\n    }\n\n    G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"jacobian\", logger, logText);\n    };\n    G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"affine\", logger, logText);\n    };\n}\n", "import {log2, buffReverseBits, array2buffer, buffer2array} from \"./utils.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default function buildFFT(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = G.tm;\n    async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {\n\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        const MAX_BITS_THREAD = 14;\n\n        let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g1m_fftFinal\";\n            }\n            fnFFTJoin = \"g1m_fftJoin\";\n            fnFFTMix = \"g1m_fftMix\";\n\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g1m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g2m_fftFinal\";\n            }\n            fnFFTJoin = \"g2m_fftJoin\";\n            fnFFTMix = \"g2m_fftMix\";\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g2m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = G.n8;\n            sMid = G.n8;\n            sOut = G.n8;\n            if (inverse) {\n                fnFFTFinal = \"frm_fftFinal\";\n            }\n            fnFFTMix = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        }\n\n\n        let returnArray = false;\n        if (Array.isArray(buff)) {\n            buff = array2buffer(buff, sIn);\n            returnArray = true;\n        } else {\n            buff = buff.slice(0, buff.byteLength);\n        }\n\n        const nPoints = buff.byteLength / sIn;\n        const bits = log2(nPoints);\n\n        if  ((1 << bits) != nPoints) {\n            throw new Error(\"fft must be multiple of 2\" );\n        }\n\n        if (bits == Fr.s +1) {\n            let buffOut;\n\n            if (inverse) {\n                buffOut =  await _fftExtInv(buff, inType, outType, logger, loggerTxt);\n            } else {\n                buffOut =  await _fftExt(buff, inType, outType, logger, loggerTxt);\n            }\n\n            if (returnArray) {\n                return buffer2array(buffOut, sOut);\n            } else {\n                return buffOut;\n            }\n        }\n\n        let inv;\n        if (inverse) {\n            inv = Fr.inv(Fr.e(nPoints));\n        }\n\n        let buffOut;\n\n        buffReverseBits(buff, sIn);\n\n        let chunks;\n        let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);\n        let nChunks = nPoints / pointsInChunk;\n\n        while ((nChunks < tm.concurrency)&&(pointsInChunk>=16)) {\n            nChunks *= 2;\n            pointsInChunk /= 2;\n        }\n\n        const l2Chunk = log2(pointsInChunk);\n\n        const promises = [];\n        for (let i = 0; i< nChunks; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix start: ${i}/${nChunks}`);\n            const task = [];\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*pointsInChunk});\n            const buffChunk = buff.slice( (pointsInChunk * i)*sIn, (pointsInChunk * (i+1))*sIn);\n            task.push({cmd: \"SET\", var: 0, buff: buffChunk});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n            }\n            for (let j=1; j<=l2Chunk;j++) {\n                task.push({cmd: \"CALL\", fnName:fnFFTMix, params: [{var:0}, {val: pointsInChunk}, {val: j}]});\n            }\n\n            if (l2Chunk==bits) {\n                if (fnFFTFinal) {\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: inv});\n                    task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                        {var: 0},\n                        {val: pointsInChunk},\n                        {var: 1},\n                    ]});\n                }\n                if (fnMid2Out) {\n                    task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                }\n                task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n            } else {\n                task.push({cmd: \"GET\", out:0, var: 0, len: sMid*pointsInChunk});\n            }\n            promises.push(tm.queueAction(task).then( (r) => {\n                if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix end: ${i}/${nChunks}`);\n                return r;\n            }));\n        }\n\n        chunks = await Promise.all(promises);\n        for (let i = 0; i< nChunks; i++) chunks[i] = chunks[i][0];\n\n        for (let i = l2Chunk+1;   i<=bits; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft  ${bits}  join: ${i}/${bits}`);\n            const nGroups = 1 << (bits - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsInChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsInChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    if (i==bits) {\n                        if (fnFFTFinal) {\n                            task.push({cmd: \"ALLOCSET\", var: 4, buff: inv});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 0},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 1},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                        }\n                        if (fnMid2Out) {\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: pointsInChunk}, {var: 1}]});\n                        }\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sOut});\n                    } else {\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sMid});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sMid});\n                    }\n                    opPromises.push(tm.queueAction(task).then( (r) => {\n                        if (logger) logger.debug(`${loggerTxt}: fft ${bits} join  ${i}/${bits}  ${j+1}/${nGroups} ${k}/${nChunksPerGroup/2}`);\n                        return r;\n                    }));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        if (buff instanceof BigBuffer) {\n            buffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            buffOut = new Uint8Array(nPoints*sOut);\n        }\n        if (inverse) {\n            buffOut.set(chunks[0].slice((pointsInChunk-1)*sOut));\n            let p= sOut;\n            for (let i=nChunks-1; i>0; i--) {\n                buffOut.set(chunks[i], p);\n                p += pointsInChunk*sOut;\n                delete chunks[i];  // Liberate mem\n            }\n            buffOut.set(chunks[0].slice(0, (pointsInChunk-1)*sOut), p);\n            delete chunks[0];\n        } else {\n            for (let i=0; i<nChunks; i++) {\n                buffOut.set(chunks[i], pointsInChunk*sOut*i);\n                delete chunks[i];\n            }\n        }\n\n        if (returnArray) {\n            return buffer2array(buffOut, sOut);\n        } else {\n            return buffOut;\n        }\n    }\n\n    async function _fftExt(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        [b1, b2] = await _fftJoinExt(b1, b2, \"fftJoinExt\", Fr.one, Fr.shift, inType, \"jacobian\", logger, loggerTxt);\n\n        promises.push( _fft(b1, false, \"jacobian\", outType, logger, loggerTxt));\n        promises.push( _fft(b2, false, \"jacobian\", outType, logger, loggerTxt));\n\n        const res1 = await Promise.all(promises);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n    async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        promises.push( _fft(b1, true, inType, \"jacobian\", logger, loggerTxt));\n        promises.push( _fft(b2, true, inType, \"jacobian\", logger, loggerTxt));\n\n        [b1, b2] = await Promise.all(promises);\n\n        const res1 = await _fftJoinExt(b1, b2, \"fftJoinExtInv\", Fr.one, Fr.shiftInv, \"jacobian\", outType, logger, loggerTxt);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n\n    async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const MIN_CHUNK_SIZE = 1<<4;\n\n        let fnName;\n        let fnIn2Mid, fnMid2Out;\n        let sOut, sIn, sMid;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            fnName = \"g1m_\"+fn;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g1m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            fnName = \"g2m_\"+fn;\n            sMid = G.F.n8*3;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g2m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n            sOut = Fr.n8;\n            sMid = Fr.n8;\n            fnName = \"frm_\" + fn;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sIn);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let chunkSize = Math.floor(nPoints /tm.concurrency);\n        if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n        if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n\n        const opPromises = [];\n\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n\n            const firstChunk = Fr.mul(first, Fr.exp( inc, i));\n            const task = [];\n\n            const b1 = buff1.slice(i*sIn, (i+n)*sIn);\n            const b2 = buff2.slice(i*sIn, (i+n)*sIn);\n\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*n});\n            task.push({cmd: \"SET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOC\", var: 1, len: sMid*n});\n            task.push({cmd: \"SET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: n},\n                {var: 2},\n                {var: 3},\n                {val: Fr.s},\n            ]});\n            if (fnMid2Out) {\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sOut});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: n*sOut});\n            opPromises.push(\n                tm.queueAction(task).then( (r) => {\n                    if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);\n                    return r;\n                })\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (nPoints * sOut > 1<<28) {\n            fullBuffOut1 = new BigBuffer(nPoints*sOut);\n            fullBuffOut2 = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sOut);\n            fullBuffOut2 = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    }\n\n\n    G.fft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, false, inType, outType, logger, loggerTxt);\n    };\n\n    G.ifft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, true, inType, outType, logger, loggerTxt);\n    };\n\n    G.lagrangeEvaluations = async function (buff, inType, outType, logger, loggerTxt) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n\n        let sIn;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = buff.byteLength /sIn;\n        const bits = log2(nPoints);\n\n        if ((2 ** bits)*sIn != buff.byteLength) {\n            if (logger) logger.error(\"lagrangeEvaluations iinvalid input size\");\n            throw new Error(\"lagrangeEvaluations invalid Input size\");\n        }\n\n        if (bits <= Fr.s) {\n            return await G.ifft(buff, inType, outType, logger, loggerTxt);\n        }\n\n        if (bits > Fr.s+1) {\n            if (logger) logger.error(\"lagrangeEvaluations input too big\");\n            throw new Error(\"lagrangeEvaluations input too big\");\n        }\n\n        let t0 = buff.slice(0, buff.byteLength/2);\n        let t1 = buff.slice(buff.byteLength/2, buff.byteLength);\n\n\n        const shiftToSmallM = Fr.exp(Fr.shift, nPoints/2);\n        const sConst = Fr.inv( Fr.sub(Fr.one, shiftToSmallM));\n\n        [t0, t1] = await _fftJoinExt(t0, t1, \"prepareLagrangeEvaluation\", sConst, Fr.shiftInv, inType, \"jacobian\", logger, loggerTxt + \" prep\");\n\n        const promises = [];\n\n        promises.push( _fft(t0, true, \"jacobian\", outType, logger, loggerTxt + \" t0\"));\n        promises.push( _fft(t1, true, \"jacobian\", outType, logger, loggerTxt + \" t1\"));\n\n        [t0, t1] = await Promise.all(promises);\n\n        let buffOut;\n        if (t0.byteLength > (1<<28)) {\n            buffOut = new BigBuffer(t0.byteLength*2);\n        } else {\n            buffOut = new Uint8Array(t0.byteLength*2);\n        }\n\n        buffOut.set(t0);\n        buffOut.set(t1, t0.byteLength);\n\n        return buffOut;\n    };\n\n    G.fftMix = async function fftMix(buff) {\n        const sG = G.F.n8*3;\n        let fnName, fnFFTJoin;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftMix\";\n            fnFFTJoin = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftMix\";\n            fnFFTJoin = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        const power = log2(nPoints);\n\n        let nChunks = 1 << log2(tm.concurrency);\n\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n        const powerChunk = log2(pointsPerChunk);\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            for (let j=1; j<=powerChunk; j++) {\n                task.push({cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: pointsPerChunk},\n                    {val: j}\n                ]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        const chunks = [];\n        for (let i=0; i<result.length; i++) chunks[i] = result[i][0];\n\n\n        for (let i = powerChunk+1; i<=power; i++) {\n            const nGroups = 1 << (power - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsPerChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsPerChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n                    task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n                    opPromises.push(tm.queueAction(task));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sG);\n        }\n        let p =0;\n        for (let i=0; i<nChunks; i++) {\n            fullBuffOut.set(chunks[i], p);\n            p+=chunks[i].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n\n    G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {\n        const sG = G.F.n8*3;\n        let fnName;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let nChunks = 1 << log2(tm.concurrency);\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n\n            const firstChunk = Fr.mul(first, Fr.exp(inc, i*pointsPerChunk));\n            const b1 = buff1.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            const b2 = buff2.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: pointsPerChunk},\n                {var: 2},\n                {var: 3}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (buff1 instanceof BigBuffer) {\n            fullBuffOut1 = new BigBuffer(nPoints*sG);\n            fullBuffOut2 = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sG);\n            fullBuffOut2 = new Uint8Array(nPoints*sG);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    };\n\n\n\n    G.fftFinal =  async function fftFinal(buff, factor) {\n        const sG = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnName, fnToAffine;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftFinal\";\n            fnToAffine = \"g1m_batchToAffine\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftFinal\";\n            fnToAffine = \"g2m_batchToAffine\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        const pointsPerChunk = Math.floor(nPoints / tm.concurrency);\n\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, (i*pointsPerChunk+n)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: factor});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {val: n},\n                {var: 1},\n            ]});\n            task.push({cmd: \"CALL\", fnName: fnToAffine, params: [\n                {var: 0},\n                {val: n},\n                {var: 0},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sGout});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sGout);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sGout);\n        }\n\n        let p =0;\n        for (let i=result.length-1; i>=0; i--) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n", "import { buildBls12381 as buildBls12381wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bls12381 = null;\n\nexport default async function buildBls12381(singleThread, plugins) {\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBls12381wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bls12381wasm = {};\n\n    bls12381wasm.code = moduleBuilder.build();\n    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;\n    bls12381wasm.pr = moduleBuilder.modules.frm.pq;\n    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;\n    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;\n    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;\n    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;\n    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;\n    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;\n    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;\n    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;\n    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;\n    bls12381wasm.n8q = 48;\n    bls12381wasm.n8r = 32;\n    bls12381wasm.q = moduleBuilder.modules.bls12381.q;\n    bls12381wasm.r = moduleBuilder.modules.bls12381.r;\n\n\n    if ((!singleThread) && (globalThis.curve_bls12381)) return globalThis.curve_bls12381;\n    const params = {\n        name: \"bls12381\",\n        wasm: bls12381wasm,\n        q: Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16),\n        r: Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16),\n        n8q: 48,\n        n8r: 32,\n        cofactorG1: Scalar.e(\"0x396c8c005555e1568c00aaab0000aaab\", 16),\n        cofactorG2: Scalar.e(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bls12381 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bls12381 = curve;\n    }\n\n    return curve;\n}\n\n", "import * as Scalar from \"./scalar.js\";\nimport {default as buildBn128} from \"./bn128.js\";\nimport {default as buildBls12381} from \"./bls12381.js\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nexport async function getCurveFromR(r, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(r, bn128r)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(r, bls12381r)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromQ(q, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(q, bn128q)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(q, bls12381q)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(q, 16)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromName(name, singleThread, plugins) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2016/260.pdf */\nimport { Scalar } from \"ffjavascript\";\nimport * as curves from \"./curves.js\";\nimport {  utils }   from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\nexport default async function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {\n/*\n    let cpub = vk_verifier.IC[0];\n    for (let s= 0; s< vk_verifier.nPublic; s++) {\n        cpub  = G1.add( cpub, G1.timesScalar( vk_verifier.IC[s+1], publicSignals[s]));\n    }\n*/\n\n    const vk_verifier = unstringifyBigInts(_vk_verifier);\n    const proof = unstringifyBigInts(_proof);\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await curves.getCurveFromName(vk_verifier.curve);\n\n    const IC0 = curve.G1.fromObject(vk_verifier.IC[0]);\n    const IC = new Uint8Array(curve.G1.F.n8*2 * publicSignals.length);\n    const w = new Uint8Array(curve.Fr.n8 * publicSignals.length);\n\n    for (let i=0; i<publicSignals.length; i++) {\n        const buffP = curve.G1.fromObject(vk_verifier.IC[i+1]);\n        IC.set(buffP, i*curve.G1.F.n8*2);\n        Scalar.toRprLE(w, curve.Fr.n8*i, publicSignals[i], curve.Fr.n8);\n    }\n\n    let cpub = await curve.G1.multiExpAffine(IC, w);\n    cpub = curve.G1.add(cpub, IC0);\n\n    const pi_a = curve.G1.fromObject(proof.pi_a);\n    const pi_b = curve.G2.fromObject(proof.pi_b);\n    const pi_c = curve.G1.fromObject(proof.pi_c);\n\n    const vk_gamma_2 = curve.G2.fromObject(vk_verifier.vk_gamma_2);\n    const vk_delta_2 = curve.G2.fromObject(vk_verifier.vk_delta_2);\n    const vk_alpha_1 = curve.G1.fromObject(vk_verifier.vk_alpha_1);\n    const vk_beta_2 = curve.G2.fromObject(vk_verifier.vk_beta_2);\n\n    const res = await curve.pairingEq(\n        curve.G1.neg(pi_a) , pi_b,\n        cpub , vk_gamma_2,\n        pi_c , vk_delta_2,\n\n        vk_alpha_1, vk_beta_2\n    );\n\n    if (! res) {\n        if (logger) logger.error(\"Invalid proof\");\n        return false;\n    }\n\n    if (logger) logger.info(\"OK!\");\n    return true;\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nimport {  utils }   from \"ffjavascript\";\nconst { unstringifyBigInts} = utils;\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nexport default async function groth16ExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    let S;\n    S=`[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` +\n        `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` +\n        `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport {default as newAccumulator} from \"./powersoftau_new.js\";\nexport {default as exportChallenge} from \"./powersoftau_export_challenge.js\";\nexport {default as importResponse} from \"./powersoftau_import.js\";\nexport {default as verify} from \"./powersoftau_verify.js\";\nexport {default as challengeContribute} from \"./powersoftau_challenge_contribute.js\";\nexport {default as beacon} from \"./powersoftau_beacon.js\";\nexport {default as contribute} from \"./powersoftau_contribute.js\";\nexport {default as preparePhase2} from \"./powersoftau_preparephase2.js\";\nexport {default as truncate} from \"./powersoftau_truncate.js\";\nexport {default as convert} from \"./powersoftau_convert.js\";\nexport {default as exportJson} from \"./powersoftau_export_json.js\";\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\nHeader(1)\n    n8\n    prime\n    power\ntauG1(2)\n    {(2 ** power)*2-1} [\n        G1, tau*G1, tau^2 * G1, ....\n    ]\ntauG2(3)\n    {2 ** power}[\n        G2, tau*G2, tau^2 * G2, ...\n    ]\nalphaTauG1(4)\n    {2 ** power}[\n        alpha*G1, alpha*tau*G1, alpha*tau^2*G1,....\n    ]\nbetaTauG1(5)\n    {2 ** power} []\n        beta*G1, beta*tau*G1, beta*tau^2*G1, ....\n    ]\nbetaG2(6)\n    {1}[\n        beta*G2\n    ]\ncontributions(7)\n    NContributions\n    {NContributions}[\n        tau*G1\n        tau*G2\n        alpha*G1\n        beta*G1\n        beta*G2\n        pubKey\n            tau_g1s\n            tau_g1sx\n            tau_g2spx\n            alpha_g1s\n            alpha_g1sx\n            alpha_g1spx\n            beta_g1s\n            beta_g1sx\n            beta_g1spx\n        partialHash (216 bytes) See https://github.com/mafintosh/blake2b-wasm/blob/23bee06945806309977af802bc374727542617c7/blake2b.wat#L9\n        hashNewChallenge\n    ]\n */\n\nimport * as ptauUtils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport Blake2b from \"blake2b-wasm\";\nimport * as misc from \"./misc.js\";\n\nexport default async function newAccumulator(curve, power, fileName, logger) {\n\n    await Blake2b.ready();\n\n    const fd = await binFileUtils.createBinFile(fileName, \"ptau\", 1, 7);\n\n    await ptauUtils.writePTauHeader(fd, curve, power, 0);\n\n    const buffG1 = curve.G1.oneAffine;\n    const buffG2 = curve.G2.oneAffine;\n\n    // Write tauG1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 2);\n    const nTauG1 = (2 ** power) * 2 -1;\n    for (let i=0; i< nTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG1: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write tauG2\n    ///////////\n    await binFileUtils.startWriteSection(fd, 3);\n    const nTauG2 = (2 ** power);\n    for (let i=0; i< nTauG2; i++) {\n        await fd.write(buffG2);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG2: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write alphaTauG1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 4);\n    const nAlfaTauG1 = (2 ** power);\n    for (let i=0; i< nAlfaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"alphaTauG1: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write betaTauG1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 5);\n    const nBetaTauG1 = (2 ** power);\n    for (let i=0; i< nBetaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"betaTauG1: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write betaG2\n    ///////////\n    await binFileUtils.startWriteSection(fd, 6);\n    await fd.write(buffG2);\n    await binFileUtils.endWriteSection(fd);\n\n    // Contributions\n    ///////////\n    await binFileUtils.startWriteSection(fd, 7);\n    await fd.writeULE32(0); // 0 Contributions\n    await binFileUtils.endWriteSection(fd);\n\n    await fd.close();\n\n    const firstChallengeHash = ptauUtils.calculateFirstChallengeHash(curve, power, logger);\n\n    if (logger) logger.debug(misc.formatHash(Blake2b(64).digest(), \"Blank Contribution Hash:\"));\n\n    if (logger) logger.info(misc.formatHash(firstChallengeHash, \"First Contribution Hash:\"));\n\n    return firstChallengeHash;\n\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { Scalar } from \"ffjavascript\";\nimport Blake2b from \"blake2b-wasm\";\nimport * as keyPair from \"./keypair.js\";\nimport * as misc from \"./misc.js\";\nimport { getCurveFromQ } from \"./curves.js\";\n\nexport async function writePTauHeader(fd, curve, power, ceremonyPower) {\n    // Write the header\n    ///////////\n\n    if (! ceremonyPower) ceremonyPower = power;\n    await fd.writeULE32(1); // Header type\n    const pHeaderSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(curve.F1.n64*8);\n\n    const buff = new Uint8Array(curve.F1.n8);\n    Scalar.toRprLE(buff, 0, curve.q, curve.F1.n8);\n    await fd.write(buff);\n    await fd.writeULE32(power);                    // power\n    await fd.writeULE32(ceremonyPower);               // power\n\n    const headerSize = fd.pos - pHeaderSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(headerSize, pHeaderSize);\n\n    fd.pos = oldPos;\n}\n\nexport async function readPTauHeader(fd, sections) {\n    if (!sections[1])  throw new Error(fd.fileName + \": File has no  header\");\n    if (sections[1].length>1) throw new Error(fd.fileName +\": File has more than one header\");\n\n    fd.pos = sections[1][0].p;\n    const n8 = await fd.readULE32();\n    const buff = await fd.read(n8);\n    const q = Scalar.fromRprLE(buff);\n\n    const curve = await getCurveFromQ(q);\n\n    if (curve.F1.n64*8 != n8) throw new Error(fd.fileName +\": Invalid size\");\n\n    const power = await fd.readULE32();\n    const ceremonyPower = await fd.readULE32();\n\n    if (fd.pos-sections[1][0].p != sections[1][0].size) throw new Error(\"Invalid PTau header size\");\n\n    return {curve, power, ceremonyPower};\n}\n\n\nexport async function readPtauPubKey(fd, curve, montgomery) {\n\n    const buff = await fd.read(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n\n    return fromPtauPubKeyRpr(buff, 0, curve, montgomery);\n}\n\nexport function fromPtauPubKeyRpr(buff, pos, curve, montgomery) {\n\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n\n    key.tau.g1_s = readG1();\n    key.tau.g1_sx = readG1();\n    key.alpha.g1_s = readG1();\n    key.alpha.g1_sx = readG1();\n    key.beta.g1_s = readG1();\n    key.beta.g1_sx = readG1();\n    key.tau.g2_spx = readG2();\n    key.alpha.g2_spx = readG2();\n    key.beta.g2_spx = readG2();\n\n    return key;\n\n    function readG1() {\n        let p;\n        if (montgomery) {\n            p = curve.G1.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G1.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G1.F.n8*2;\n        return p;\n    }\n\n    function readG2() {\n        let p;\n        if (montgomery) {\n            p = curve.G2.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G2.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G2.F.n8*2;\n        return p;\n    }\n}\n\nexport function toPtauPubKeyRpr(buff, pos, curve, key, montgomery) {\n\n    writeG1(key.tau.g1_s);\n    writeG1(key.tau.g1_sx);\n    writeG1(key.alpha.g1_s);\n    writeG1(key.alpha.g1_sx);\n    writeG1(key.beta.g1_s);\n    writeG1(key.beta.g1_sx);\n    writeG2(key.tau.g2_spx);\n    writeG2(key.alpha.g2_spx);\n    writeG2(key.beta.g2_spx);\n\n    async function writeG1(p) {\n        if (montgomery) {\n            curve.G1.toRprLEM(buff, pos, p);\n        } else {\n            curve.G1.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F1.n8*2;\n    }\n\n    async function writeG2(p) {\n        if (montgomery) {\n            curve.G2.toRprLEM(buff, pos, p);\n        } else {\n            curve.G2.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F2.n8*2;\n    }\n\n    return buff;\n}\n\nexport async function writePtauPubKey(fd, curve, key, montgomery) {\n    const buff = new Uint8Array(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n    toPtauPubKeyRpr(buff, 0, curve, key, montgomery);\n    await fd.write(buff);\n}\n\nasync function readContribution(fd, curve) {\n    const c = {};\n\n    c.tauG1 = await readG1();\n    c.tauG2 = await readG2();\n    c.alphaG1 = await readG1();\n    c.betaG1 = await readG1();\n    c.betaG2 = await readG2();\n    c.key = await readPtauPubKey(fd, curve, true);\n    c.partialHash = await fd.read(216);\n    c.nextChallenge = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n    toPtauPubKeyRpr(buffV, 0, curve, c.key, false);\n\n    const responseHasher = Blake2b(64);\n    responseHasher.setPartialHash(c.partialHash);\n    responseHasher.update(buffV);\n    c.responseHash = responseHasher.digest();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await readDV(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await readDV(1);\n            const buffStr = await readDV(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await readDV(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await readDV(1);\n            c.beaconHash = await readDV(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parametes do not match\");\n    }\n\n    return c;\n\n    async function readG1() {\n        const pBuff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprLEM( pBuff );\n    }\n\n    async function readG2() {\n        const pBuff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprLEM( pBuff );\n    }\n\n    async function readDV(n) {\n        const b = await fd.read(n);\n        return new Uint8Array(b);\n    }\n}\n\nexport async function readContributions(fd, curve, sections) {\n    if (!sections[7])  throw new Error(fd.fileName + \": File has no  contributions\");\n    if (sections[7][0].length>1) throw new Error(fd.fileName +\": File has more than one contributions section\");\n\n    fd.pos = sections[7][0].p;\n    const nContributions = await fd.readULE32();\n    const contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = await readContribution(fd, curve);\n        c.id = i+1;\n        contributions.push(c);\n    }\n\n    if (fd.pos-sections[7][0].p != sections[7][0].size) throw new Error(\"Invalid contribution section size\");\n\n    return contributions;\n}\n\nasync function writeContribution(fd, curve, contribution) {\n\n    const buffG1 = new Uint8Array(curve.F1.n8*2);\n    const buffG2 = new Uint8Array(curve.F2.n8*2);\n    await writeG1(contribution.tauG1);\n    await writeG2(contribution.tauG2);\n    await writeG1(contribution.alphaG1);\n    await writeG1(contribution.betaG1);\n    await writeG2(contribution.betaG2);\n    await writePtauPubKey(fd, curve, contribution.key, true);\n    await fd.write(contribution.partialHash);\n    await fd.write(contribution.nextChallenge);\n    await fd.writeULE32(contribution.type || 0);\n\n    const params = [];\n    if (contribution.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(contribution.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (contribution.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(contribution.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(contribution.beaconHash.byteLength);\n        for (let i=0; i<contribution.beaconHash.byteLength; i++) params.push(contribution.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n\n    async function writeG1(p) {\n        curve.G1.toRprLEM(buffG1, 0, p);\n        await fd.write(buffG1);\n    }\n\n    async function writeG2(p) {\n        curve.G2.toRprLEM(buffG2, 0, p);\n        await fd.write(buffG2);\n    }\n\n}\n\nexport async function writeContributions(fd, curve, contributions) {\n\n    await fd.writeULE32(7); // Header type\n    const pContributionsSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(contributions.length);\n    for (let i=0; i< contributions.length; i++) {\n        await writeContribution(fd, curve, contributions[i]);\n    }\n    const contributionsSize = fd.pos - pContributionsSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(contributionsSize, pContributionsSize);\n    fd.pos = oldPos;\n}\n\nexport function calculateFirstChallengeHash(curve, power, logger) {\n    if (logger) logger.debug(\"Calculating First Challenge Hash\");\n\n    const hasher = new Blake2b(64);\n\n    const vG1 = new Uint8Array(curve.G1.F.n8*2);\n    const vG2 = new Uint8Array(curve.G2.F.n8*2);\n    curve.G1.toRprUncompressed(vG1, 0, curve.G1.g);\n    curve.G2.toRprUncompressed(vG2, 0, curve.G2.g);\n\n    hasher.update(Blake2b(64).digest());\n\n    let n;\n\n    n=(2 ** power)*2 -1;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG1\");\n    hashBlock(vG1, n);\n    n= 2 ** power;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG2\");\n    hashBlock(vG2, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: alphaTauG1\");\n    hashBlock(vG1, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: betaTauG1\");\n    hashBlock(vG1, n);\n    hasher.update(vG2);\n\n    return hasher.digest();\n\n    function hashBlock(buff, n) {\n        // this block size is a good compromise between speed and the maximum\n        // input size of the Blake2b update method (65,535,720 bytes).\n        const blockSize = 341000;\n        const nBlocks = Math.floor(n / blockSize);\n        const rem = n % blockSize;\n        const bigBuff = new Uint8Array(blockSize * buff.byteLength);\n        for (let i=0; i<blockSize; i++) {\n            bigBuff.set(buff, i*buff.byteLength);\n        }\n        for (let i=0; i<nBlocks; i++) {\n            hasher.update(bigBuff);\n            if (logger) logger.debug(\"Initial hash: \" +i*blockSize);\n        }\n        for (let i=0; i<rem; i++) {\n            hasher.update(buff);\n        }\n    }\n}\n\n\nexport function keyFromBeacon(curve, challengeHash, beaconHash, numIterationsExp) {\n\n    const rng = misc.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const key = keyPair.createPTauKey(curve, challengeHash, rng);\n\n    return key;\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport blake2b from \"blake2b-wasm\";\n\nimport { ChaCha } from \"ffjavascript\";\n\nexport function hashToG2(curve, hash) {\n    const hashV = new DataView(hash.buffer, hash.byteOffset, hash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = hashV.getUint32(i*4);\n    }\n\n    const rng = new ChaCha(seed);\n\n    const g2_sp = curve.G2.fromRng(rng);\n\n    return g2_sp;\n}\n\nexport function getG2sp(curve, persinalization, challenge, g1s, g1sx) {\n\n    const h = blake2b(64);\n    const b1 = new Uint8Array([persinalization]);\n    h.update(b1);\n    h.update(challenge);\n    const b3 = curve.G1.toUncompressed(g1s);\n    h.update( b3);\n    const b4 = curve.G1.toUncompressed(g1sx);\n    h.update( b4);\n    const hash =h.digest();\n\n    return hashToG2(curve, hash);\n}\n\nfunction calculatePubKey(k, curve, personalization, challengeHash, rng ) {\n    k.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    k.g1_sx = curve.G1.toAffine(curve.G1.timesFr(k.g1_s, k.prvKey));\n    k.g2_sp = curve.G2.toAffine(getG2sp(curve, personalization, challengeHash, k.g1_s, k.g1_sx));\n    k.g2_spx = curve.G2.toAffine(curve.G2.timesFr(k.g2_sp, k.prvKey));\n    return k;\n}\n\nexport function createPTauKey(curve, challengeHash, rng) {\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n    key.tau.prvKey = curve.Fr.fromRng(rng);\n    key.alpha.prvKey = curve.Fr.fromRng(rng);\n    key.beta.prvKey = curve.Fr.fromRng(rng);\n    calculatePubKey(key.tau, curve, 0, challengeHash, rng);\n    calculatePubKey(key.alpha, curve, 1, challengeHash, rng);\n    calculatePubKey(key.beta, curve, 2, challengeHash, rng);\n    return key;\n}\n\nexport function createDeltaKey(curve, transcript, rng) {\n    const delta = {};\n    delta.prvKey = curve.Fr.fromRng(rng);\n    delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    delta.g1_sx = curve.G1.toAffine(curve.G1.timesScalar(delta.g1_s, delta.prvKey));\n    delta.g2_sp = hashToG2(curve, transcript);\n    delta.g2_spx = curve.G2.toAffine(curve.G2.timesScalar(delta.g2_sp, delta.prvKey));\n    return delta;\n}\n", "// Format of the outpu\n//     Hash of the last contribution  64Bytes\n//     2^N * 2 -1  TauG1 points (uncompressed)\n//     2^N  TauG2 Points (uncompressed)\n//     2^N  AlphaTauG1 Points (uncompressed)\n//     2^N  BetaTauG1 Points (uncompressed)\n//     BetaG2 (uncompressed)\n\nimport * as fastFile from \"fastfile\";\nimport Blake2b from \"blake2b-wasm\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as misc from \"./misc.js\";\n\nexport default async function exportChallenge(pTauFilename, challengeFilename, logger) {\n    await Blake2b.ready();\n    const {fd: fdFrom, sections} = await binFileUtils.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await utils.readPTauHeader(fdFrom, sections);\n\n    const contributions = await utils.readContributions(fdFrom, curve, sections);\n    let lastResponseHash, curChallengeHash;\n    if (contributions.length == 0) {\n        lastResponseHash = Blake2b(64).digest();\n        curChallengeHash = utils.calculateFirstChallengeHash(curve, power);\n    } else {\n        lastResponseHash = contributions[contributions.length-1].responseHash;\n        curChallengeHash = contributions[contributions.length-1].nextChallenge;\n    }\n\n    if (logger) logger.info(misc.formatHash(lastResponseHash, \"Last Response Hash: \"));\n\n    if (logger) logger.info(misc.formatHash(curChallengeHash, \"New Challenge Hash: \"));\n\n\n    const fdTo = await fastFile.createOverride(challengeFilename);\n\n    const toHash = Blake2b(64);\n    await fdTo.write(lastResponseHash);\n    toHash.update(lastResponseHash);\n\n    await exportSection(2, \"G1\", (2 ** power) * 2 -1, \"tauG1\");\n    await exportSection(3, \"G2\", (2 ** power)       , \"tauG2\");\n    await exportSection(4, \"G1\", (2 ** power)       , \"alphaTauG1\");\n    await exportSection(5, \"G1\", (2 ** power)       , \"betaTauG1\");\n    await exportSection(6, \"G2\", 1                  , \"betaG2\");\n\n    await fdFrom.close();\n    await fdTo.close();\n\n    const calcCurChallengeHash = toHash.digest();\n\n    if (!misc.hashIsEqual (curChallengeHash, calcCurChallengeHash)) {\n        if (logger) logger.info(misc.formatHash(calcCurChallengeHash, \"Calc Curret Challenge Hash: \"));\n\n        if (logger) logger.error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n        throw new Error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n    }\n\n    return curChallengeHash;\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        await binFileUtils.startReadUniqueSection(fdFrom, sections, sectionId);\n        for (let i=0; i< nPoints; i+= nPointsChunk) {\n            if (logger) logger.debug(`Exporting ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n            let buff;\n            buff = await fdFrom.read(n*sG);\n            buff = await G.batchLEMtoU(buff);\n            await fdTo.write(buff);\n            toHash.update(buff);\n        }\n        await binFileUtils.endReadSection(fdFrom);\n    }\n\n\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\nimport Blake2b from \"blake2b-wasm\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as misc from \"./misc.js\";\n\nexport default async function importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger) {\n\n    await Blake2b.ready();\n\n    const noHash = new Uint8Array(64);\n    for (let i=0; i<64; i++) noHash[i] = 0xFF;\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await utils.readPTauHeader(fdOld, sections);\n    const contributions = await utils.readContributions(fdOld, curve, sections);\n    const currentContribution = {};\n\n    if (name) currentContribution.name = name;\n\n    const sG1 = curve.F1.n8*2;\n    const scG1 = curve.F1.n8; // Compresed size\n    const sG2 = curve.F2.n8*2;\n    const scG2 = curve.F2.n8; // Compresed size\n\n    const fdResponse = await fastFile.readExisting(contributionFilename);\n\n    if  (fdResponse.totalSize !=\n        64 +                            // Old Hash\n        ((2 ** power)*2-1)*scG1 +\n        (2 ** power)*scG2 +\n        (2 ** power)*scG1 +\n        (2 ** power)*scG1 +\n        scG2 +\n        sG1*6 + sG2*3)\n        throw new Error(\"Size of the contribution is invalid\");\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = utils.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, importPoints ? 7: 2);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    const contributionPreviousHash = await fdResponse.read(64);\n\n    if (misc.hashIsEqual(noHash,lastChallengeHash)) {\n        lastChallengeHash = contributionPreviousHash;\n        contributions[contributions.length-1].nextChallenge = lastChallengeHash;\n    }\n\n    if(!misc.hashIsEqual(contributionPreviousHash,lastChallengeHash))\n        throw new Error(\"Wrong contribution. this contribution is not based on the previus hash\");\n\n    const hasherResponse = new Blake2b(64);\n    hasherResponse.update(contributionPreviousHash);\n\n    const startSections = [];\n    let res;\n    res = await processSection(fdResponse, fdNew, \"G1\", 2, (2 ** power) * 2 -1, [1], \"tauG1\");\n    currentContribution.tauG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 3, (2 ** power)       , [1], \"tauG2\");\n    currentContribution.tauG2 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 4, (2 ** power)       , [0], \"alphaG1\");\n    currentContribution.alphaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 5, (2 ** power)       , [0], \"betaG1\");\n    currentContribution.betaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 6, 1                  , [0], \"betaG2\");\n    currentContribution.betaG2 = res[0];\n\n    currentContribution.partialHash = hasherResponse.getPartialHash();\n\n\n    const buffKey = await fdResponse.read(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    currentContribution.key = utils.fromPtauPubKeyRpr(buffKey, 0, curve, false);\n\n    hasherResponse.update(new Uint8Array(buffKey));\n    const hashResponse = hasherResponse.digest();\n\n    if (logger) logger.info(misc.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    if (importPoints) {\n        const nextChallengeHasher = new Blake2b(64);\n        nextChallengeHasher.update(hashResponse);\n\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n        currentContribution.nextChallenge = nextChallengeHasher.digest();\n\n        if (logger) logger.info(misc.formatHash(currentContribution.nextChallenge, \"Next Challenge Hash: \"));\n    } else {\n        currentContribution.nextChallenge = noHash;\n    }\n\n    contributions.push(currentContribution);\n\n    await utils.writeContributions(fdNew, curve, contributions);\n\n    await fdResponse.close();\n    await fdNew.close();\n    await fdOld.close();\n\n    return currentContribution.nextChallenge;\n\n    async function processSection(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n        if (importPoints) {\n            return await processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        } else {\n            return await processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        }\n    }\n\n    async function processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n        const sG = G.F.n8*2;\n\n        const singularPoints = [];\n\n        await binFileUtils.startWriteSection(fdTo, sectionId);\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        startSections[sectionId] = fdTo.pos;\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            const buffLEM = await G.batchCtoLEM(buffC);\n\n            await fdTo.write(buffLEM);\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(buffLEM, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        await binFileUtils.endWriteSection(fdTo);\n\n        return singularPoints;\n    }\n\n\n    async function processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n\n        const singularPoints = [];\n\n        const nPointsChunk = Math.floor((1<<24)/scG);\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprCompressed(buffC, (sp-i)*scG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        return singularPoints;\n    }\n\n\n    async function hashSection(nextChallengeHasher, fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport Blake2b from \"blake2b-wasm\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as keyPair from \"./keypair.js\";\nimport crypto from \"crypto\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport { ChaCha, BigBuffer } from \"ffjavascript\";\nimport * as misc from \"./misc.js\";\nconst sameRatio = misc.sameRatio;\n\nasync function verifyContribution(curve, cur, prev, logger) {\n    let sr;\n    if (cur.type == 1) {    // Verify the beacon.\n        const beaconKey = utils.keyFromBeacon(curve, prev.nextChallenge, cur.beaconHash, cur.numIterationsExp);\n\n        if (!curve.G1.eq(cur.key.tau.g1_s, beaconKey.tau.g1_s)) {\n            if (logger) logger.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.tau.g1_sx, beaconKey.tau.g1_sx)) {\n            if (logger) logger.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.tau.g2_spx, beaconKey.tau.g2_spx)) {\n            if (logger) logger.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.alpha.g1_s, beaconKey.alpha.g1_s)) {\n            if (logger) logger.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.alpha.g1_sx, beaconKey.alpha.g1_sx)) {\n            if (logger) logger.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.alpha.g2_spx, beaconKey.alpha.g2_spx)) {\n            if (logger) logger.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.beta.g1_s, beaconKey.beta.g1_s)) {\n            if (logger) logger.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.beta.g1_sx, beaconKey.beta.g1_sx)) {\n            if (logger) logger.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.beta.g2_spx, beaconKey.beta.g2_spx)) {\n            if (logger) logger.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n    }\n\n    cur.key.tau.g2_sp = curve.G2.toAffine(keyPair.getG2sp(curve, 0, prev.nextChallenge, cur.key.tau.g1_s, cur.key.tau.g1_sx));\n    cur.key.alpha.g2_sp = curve.G2.toAffine(keyPair.getG2sp(curve, 1, prev.nextChallenge, cur.key.alpha.g1_s, cur.key.alpha.g1_sx));\n    cur.key.beta.g2_sp = curve.G2.toAffine(keyPair.getG2sp(curve, 2, prev.nextChallenge, cur.key.beta.g1_s, cur.key.beta.g1_sx));\n\n    sr = await sameRatio(curve, cur.key.tau.g1_s, cur.key.tau.g1_sx, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (tau) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.alpha.g1_s, cur.key.alpha.g1_sx, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (alpha) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.beta.g1_s, cur.key.beta.g1_sx, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (beta) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.tauG1, cur.tauG1, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.tau.g1_s, cur.key.tau.g1_sx, prev.tauG2, cur.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G2. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.alphaG1, cur.alphaG1, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID alpha*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.betaG1, cur.betaG1, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.beta.g1_s, cur.key.beta.g1_sx, prev.betaG2, cur.betaG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G2. challenge #\"+cur.id+\"It does not follow the previous contribution\");\n        return false;\n    }\n\n    if (logger) logger.info(\"Powers Of tau file OK!\");\n    return true;\n}\n\nexport default async function verify(tauFilename, logger) {\n    let sr;\n    await Blake2b.ready();\n\n    const {fd, sections} = await binFileUtils.readBinFile(tauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fd, sections);\n    const contrs = await utils.readContributions(fd, curve, sections);\n\n    if (logger) logger.debug(\"power: 2**\" + power);\n    // Verify Last contribution\n\n    if (logger) logger.debug(\"Computing initial contribution hash\");\n    const initialContribution = {\n        tauG1: curve.G1.g,\n        tauG2: curve.G2.g,\n        alphaG1: curve.G1.g,\n        betaG1: curve.G1.g,\n        betaG2: curve.G2.g,\n        nextChallenge: utils.calculateFirstChallengeHash(curve, ceremonyPower, logger),\n        responseHash: Blake2b(64).digest()\n    };\n\n    if (contrs.length == 0) {\n        if (logger) logger.error(\"This file has no contribution! It cannot be used in production\");\n        return false;\n    }\n\n    let prevContr;\n    if (contrs.length>1) {\n        prevContr = contrs[contrs.length-2];\n    } else {\n        prevContr = initialContribution;\n    }\n    const curContr = contrs[contrs.length-1];\n    if (logger) logger.debug(\"Validating contribution #\"+contrs[contrs.length-1].id);\n    const res = await verifyContribution(curve, curContr, prevContr, logger);\n    if (!res) return false;\n\n\n    const nextContributionHasher = Blake2b(64);\n    nextContributionHasher.update(curContr.responseHash);\n\n    // Verify powers and compute nextChallengeHash\n\n    // await test();\n\n    // Verify Section tau*G1\n    if (logger) logger.debug(\"Verifying powers in tau*G1 section\");\n    const rTau1 = await processSection(2, \"G1\", \"tauG1\", (2 ** power)*2-1, [0, 1], logger);\n    sr = await sameRatio(curve, rTau1.R1, rTau1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curve.G1.g, rTau1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G1 section must be the generator\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.tauG1, rTau1.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G1 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // await test();\n\n    // Verify Section tau*G2\n    if (logger) logger.debug(\"Verifying powers in tau*G2 section\");\n    const rTau2 = await processSection(3, \"G2\", \"tauG2\", 2 ** power, [0, 1],  logger);\n    sr = await sameRatio(curve, curve.G1.g, curContr.tauG1, rTau2.R1, rTau2.R2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG2 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G2.eq(curve.G2.g, rTau2.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G2 section must be the generator\");\n        return false;\n    }\n    if (!curve.G2.eq(curContr.tauG2, rTau2.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section alpha*tau*G1\n    if (logger) logger.debug(\"Verifying powers in alpha*tau*G1 section\");\n    const rAlphaTauG1 = await processSection(4, \"G1\", \"alphatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rAlphaTauG1.R1, rAlphaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"alphaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.alphaG1, rAlphaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section beta*tau*G1\n    if (logger) logger.debug(\"Verifying powers in beta*tau*G1 section\");\n    const rBetaTauG1 = await processSection(5, \"G1\", \"betatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rBetaTauG1.R1, rBetaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"betaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.betaG1, rBetaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    //Verify Beta G2\n    const betaG2 = await processSectionBetaG2(logger);\n    if (!curve.G2.eq(curContr.betaG2, betaG2)) {\n        if (logger) logger.error(\"betaG2 element in betaG2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n\n    const nextContributionHash = nextContributionHasher.digest();\n\n    // Check the nextChallengeHash\n    if (power == ceremonyPower) {\n        if (!misc.hashIsEqual(nextContributionHash,curContr.nextChallenge)) {\n            if (logger) logger.error(\"Hash of the values does not match the next challenge of the last contributor in the contributions section\");\n            return false;\n        }\n    }\n\n    if (logger) logger.info(misc.formatHash(nextContributionHash, \"Next challenge hash: \"));\n\n    // Verify Previous contributions\n\n    printContribution(curContr, prevContr);\n    for (let i = contrs.length-2; i>=0; i--) {\n        const curContr = contrs[i];\n        const prevContr =  (i>0) ? contrs[i-1] : initialContribution;\n        const res = await verifyContribution(curve, curContr, prevContr, logger);\n        if (!res) return false;\n        printContribution(curContr, prevContr, logger);\n    }\n    if (logger) logger.info(\"-----------------------------------------------------\");\n\n    if ((!sections[12]) || (!sections[13]) || (!sections[14]) || (!sections[15])) {\n        if (logger) logger.warn(\n            \"this file does not contain phase2 precalculated values. Please run: \\n\" +\n            \"   snarkjs \\\"powersoftau preparephase2\\\" to prepare this file to be used in the phase2 ceremony.\"\n        );\n    } else {\n        let res;\n        res = await verifyLagrangeEvaluations(\"G1\", 2, 12, \"tauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G2\", 3, 13, \"tauG2\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 4, 14, \"alphaTauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 5, 15, \"betaTauG1\", logger);\n        if (!res) return false;\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"Powers of Tau Ok!\");\n\n    return true;\n\n    function printContribution(curContr, prevContr) {\n        if (!logger) return;\n        logger.info(\"-----------------------------------------------------\");\n        logger.info(`Contribution #${curContr.id}: ${curContr.name ||\"\"}`);\n\n        logger.info(misc.formatHash(curContr.nextChallenge, \"Next Challenge: \"));\n\n        const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n        utils.toPtauPubKeyRpr(buffV, 0, curve, curContr.key, false);\n\n        const responseHasher = Blake2b(64);\n        responseHasher.setPartialHash(curContr.partialHash);\n        responseHasher.update(buffV);\n        const responseHash = responseHasher.digest();\n\n        logger.info(misc.formatHash(responseHash, \"Response Hash:\"));\n\n        logger.info(misc.formatHash(prevContr.nextChallenge, \"Response Hash:\"));\n\n        if (curContr.type == 1) {\n            logger.info(`Beacon generator: ${misc.byteArray2hex(curContr.beaconHash)}`);\n            logger.info(`Beacon iterations Exp: ${curContr.numIterationsExp}`);\n        }\n\n    }\n\n    async function processSectionBetaG2(logger) {\n        const G = curve.G2;\n        const sG = G.F.n8*2;\n        const buffUv = new Uint8Array(sG);\n\n        if (!sections[6])  {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has no BetaG2 section\");\n        }\n        if (sections[6].length>1) {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has more than one GetaG2 section\");\n        }\n        fd.pos = sections[6][0].p;\n\n        const buff = await fd.read(sG);\n        const P = G.fromRprLEM(buff);\n\n        G.toRprUncompressed(buffUv, 0, P);\n        nextContributionHasher.update(buffUv);\n\n        return P;\n    }\n\n    async function processSection(idSection, groupName, sectionName, nPoints, singularPointIndexes, logger) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await binFileUtils.startReadUniqueSection(fd, sections, idSection);\n\n        const singularPoints = [];\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        let lastBase = G.zero;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`points relations: ${sectionName}: ${i}/${nPoints} `);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases = await fd.read(n*sG);\n\n            const basesU = await G.batchLEMtoU(bases);\n            nextContributionHasher.update(basesU);\n\n            const scalars = new Uint8Array(4*(n-1));\n            crypto.randomFillSync(scalars);\n\n\n            if (i>0) {\n                const firstBase = G.fromRprLEM(bases, 0);\n                const r = crypto.randomBytes(4).readUInt32BE(0, true);\n\n                R1 = G.add(R1, G.timesScalar(lastBase, r));\n                R2 = G.add(R2, G.timesScalar(firstBase, r));\n            }\n\n            const r1 = await G.multiExpAffine(bases.slice(0, (n-1)*sG), scalars);\n            const r2 = await G.multiExpAffine(bases.slice(sG), scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n\n            lastBase = G.fromRprLEM( bases, (n-1)*sG);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(bases, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n\n        }\n        await binFileUtils.endReadSection(fd);\n\n        return {\n            R1: R1,\n            R2: R2,\n            singularPoints: singularPoints\n        };\n\n    }\n\n    async function verifyLagrangeEvaluations(gName, tauSection, lagrangeSection, sectionName, logger) {\n\n        if (logger) logger.debug(`Verifying phase2 calculated values ${sectionName}...`);\n        const G = curve[gName];\n        const sG = G.F.n8*2;\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = crypto.randomBytes(4).readUInt32BE(0, true);\n        }\n\n        for (let p=0; p<= power; p ++) {\n            const res = await verifyPower(p);\n            if (!res) return false;\n        }\n\n        if (tauSection == 2) {\n            const res = await verifyPower(power+1);\n            if (!res) return false;\n        }\n\n        return true;\n\n        async function verifyPower(p) {\n            if (logger) logger.debug(`Power ${p}...`);\n            const n8r = curve.Fr.n8;\n            const nPoints = 2 ** p;\n            let buff_r = new Uint32Array(nPoints);\n            let buffG;\n\n            let rng = new ChaCha(seed);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((p == power+1)&&(i == nPoints-1)) {\n                    buff_r[i] = 0;\n                } else {\n                    buff_r[i] = rng.nextU32();\n                }\n            }\n\n            buff_r = new Uint8Array(buff_r.buffer, buff_r.byteOffset, buff_r.byteLength);\n\n            if (logger) logger.debug(`reading points Powers${p}...`);\n            await binFileUtils.startReadUniqueSection(fd, sections, tauSection);\n            buffG = new BigBuffer(nPoints*sG);\n            if (p == power+1) {\n                await fd.readToBuffer(buffG, 0, (nPoints-1)*sG);\n                buffG.set(curve.G1.zeroAffine, (nPoints-1)*sG);\n            } else {\n                await fd.readToBuffer(buffG, 0, nPoints*sG);\n            }\n            await binFileUtils.endReadSection(fd, true);\n\n            const resTau = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p);\n\n            buff_r = new BigBuffer(nPoints * n8r);\n\n            rng = new ChaCha(seed);\n\n            const buff4 = new Uint8Array(4);\n            const buff4V = new DataView(buff4.buffer);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((i != nPoints-1) || (p != power+1)) {\n                    buff4V.setUint32(0, rng.nextU32(), true);\n                    buff_r.set(buff4, i*n8r);\n                }\n            }\n\n            if (logger) logger.debug(`batchToMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchToMontgomery(buff_r);\n            if (logger) logger.debug(`fft ${p}...`);\n            buff_r = await curve.Fr.fft(buff_r);\n            if (logger) logger.debug(`batchFromMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchFromMontgomery(buff_r);\n\n            if (logger) logger.debug(`reading points Lagrange${p}...`);\n            await binFileUtils.startReadUniqueSection(fd, sections, lagrangeSection);\n            fd.pos += sG*((2 ** p)-1);\n            await fd.readToBuffer(buffG, 0, nPoints*sG);\n            await binFileUtils.endReadSection(fd, true);\n\n            const resLagrange = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p + \"_transformed\");\n\n            if (!G.eq(resTau, resLagrange)) {\n                if (logger) logger.error(\"Phase2 caclutation does not match with powers of tau\");\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\nimport * as fastFile from \"fastfile\";\nimport Blake2b from \"blake2b-wasm\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as misc from \"./misc.js\";\nimport { applyKeyToChallengeSection } from \"./mpc_applykey.js\";\nimport * as keyPair from \"./keypair.js\";\n\nexport default async function challengeContribute(curve, challengeFilename, responesFileName, entropy, logger) {\n    await Blake2b.ready();\n\n    const fdFrom = await fastFile.readExisting(challengeFilename);\n\n\n    const sG1 = curve.F1.n64*8*2;\n    const sG2 = curve.F2.n64*8*2;\n    const domainSize = (fdFrom.totalSize + sG1 - 64 - sG2) / (4*sG1 + sG2);\n    let e = domainSize;\n    let power = 0;\n    while (e>1) {\n        e = e /2;\n        power += 1;\n    }\n\n    if (2 ** power != domainSize) throw new Error(\"Invalid file size\");\n    if (logger) logger.debug(\"Power to tau size: \"+power);\n\n    const rng = await misc.getRandomRng(entropy);\n\n    const fdTo = await fastFile.createOverride(responesFileName);\n\n    // Calculate the hash\n    const challengeHasher = Blake2b(64);\n    for (let i=0; i<fdFrom.totalSize; i+= fdFrom.pageSize) {\n        if (logger) logger.debug(`Hashing challenge ${i}/${fdFrom.totalSize}`);\n        const s = Math.min(fdFrom.totalSize - i, fdFrom.pageSize);\n        const buff = await fdFrom.read(s);\n        challengeHasher.update(buff);\n    }\n\n    const claimedHash = await fdFrom.read(64, 0);\n    if (logger) logger.info(misc.formatHash(claimedHash, \"Claimed Previous Response Hash: \"));\n\n    const challengeHash = challengeHasher.digest();\n    if (logger) logger.info(misc.formatHash(challengeHash, \"Current Challenge Hash: \"));\n\n    const key = keyPair.createPTauKey(curve, challengeHash, rng);\n\n    if (logger) {\n        [\"tau\", \"alpha\", \"beta\"].forEach( (k) => {\n            logger.debug(k + \".g1_s: \" + curve.G1.toString(key[k].g1_s, 16));\n            logger.debug(k + \".g1_sx: \" + curve.G1.toString(key[k].g1_sx, 16));\n            logger.debug(k + \".g2_sp: \" + curve.G2.toString(key[k].g2_sp, 16));\n            logger.debug(k + \".g2_spx: \" + curve.G2.toString(key[k].g2_spx, 16));\n            logger.debug(\"\");\n        });\n    }\n\n    const responseHasher = Blake2b(64);\n\n    await fdTo.write(challengeHash);\n    responseHasher.update(challengeHash);\n\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)*2-1, curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG1\"     , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G2\", (2 ** power)    , curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG2\"     , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.alpha.prvKey, key.tau.prvKey, \"COMPRESSED\", \"alphaTauG1\", logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG1\" , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G2\", 1             , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG2\" , logger );\n\n    // Write and hash key\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n    utils.toPtauPubKeyRpr(buffKey, 0, curve, key, false);\n    await fdTo.write(buffKey);\n    responseHasher.update(buffKey);\n    const responseHash = responseHasher.digest();\n    if (logger) logger.info(misc.formatHash(responseHash, \"Contribution Response Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\n/*\n    This function creates a new section in the fdTo file with id idSection.\n    It multiplies the pooints in fdFrom by first, first*inc, first*inc^2, ....\n    nPoint Times.\n    It also updates the newChallengeHasher with the new points\n*/\n\nexport async function applyKeyToSection(fdOld, sections, fdNew, idSection, curve, groupName, first, inc, sectionName, logger) {\n    const MAX_CHUNK_SIZE = 1 << 16;\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const nPoints = sections[idSection][0].size / sG;\n\n    await binFileUtils.startReadUniqueSection(fdOld, sections,idSection );\n    await binFileUtils.startWriteSection(fdNew, idSection);\n\n    let t = first;\n    for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`Applying key: ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints - i, MAX_CHUNK_SIZE);\n        let buff;\n        buff = await fdOld.read(n*sG);\n        buff = await G.batchApplyKey(buff, t, inc);\n        await fdNew.write(buff);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n\n    await binFileUtils.endWriteSection(fdNew);\n    await binFileUtils.endReadSection(fdOld);\n}\n\n\n\nexport async function applyKeyToChallengeSection(fdOld, fdNew, responseHasher, curve, groupName, nPoints, first, inc, formatOut, sectionName, logger) {\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n    let t = first;\n    for (let i=0 ; i<nPoints ; i+= chunkSize) {\n        if (logger) logger.debug(`Applying key ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints-i, chunkSize );\n        const buffInU = await fdOld.read(n * sG);\n        const buffInLEM = await G.batchUtoLEM(buffInU);\n        const buffOutLEM = await G.batchApplyKey(buffInLEM, t, inc);\n        let buffOut;\n        if (formatOut == \"COMPRESSED\") {\n            buffOut = await G.batchLEMtoC(buffOutLEM);\n        } else {\n            buffOut = await G.batchLEMtoU(buffOutLEM);\n        }\n\n        if (responseHasher) responseHasher.update(buffOut);\n        await fdNew.write(buffOut);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport Blake2b from \"blake2b-wasm\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as misc from \"./misc.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\nexport default async function beacon(oldPtauFilename, newPTauFilename, name,  beaconHashStr,numIterationsExp, logger) {\n    const beaconHash = misc.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum lenght of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    await Blake2b.ready();\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        return false;\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await utils.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 1, // Beacon\n        numIterationsExp: numIterationsExp,\n        beaconHash: beaconHash\n    };\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = utils.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    curContribution.key = utils.keyFromBeacon(curve, lastChallengeHash, beaconHash, numIterationsExp);\n\n    const responseHasher = new Blake2b(64);\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\", logger );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\", logger );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\", logger );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\", logger );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\", logger );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = responseHasher.getPartialHash();\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    utils.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = new Blake2b(64);\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await utils.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName, logger) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await binFileUtils.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`applying key${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (uncompressed)\n//      2^N TauG2 Points (uncompressed)\n//      2^N AlphaTauG1 Points (uncompressed)\n//      2^N BetaTauG1 Points (uncompressed)\n\nimport Blake2b from \"blake2b-wasm\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as keyPair from \"./keypair.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as misc from \"./misc.js\";\n\nexport default async function contribute(oldPtauFilename, newPTauFilename, name, entropy, logger) {\n    await Blake2b.ready();\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        throw new Error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await utils.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 0, // Beacon\n    };\n\n    let lastChallengeHash;\n\n    const rng = await misc.getRandomRng(entropy);\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = utils.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    // Generate a random key\n\n\n    curContribution.key = keyPair.createPTauKey(curve, lastChallengeHash, rng);\n\n\n    const responseHasher = new Blake2b(64);\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\" );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\" );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\" );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\" );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\" );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = responseHasher.getPartialHash();\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    utils.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = new Blake2b(64);\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\");\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\");\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\");\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\");\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\");\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await utils.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await binFileUtils.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`processing: ${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if ((logger)&&i) logger.debug(`Hashing ${sectionName}: ` + i);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport {BigBuffer} from \"ffjavascript\";\n\nexport default async function preparePhase2(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await utils.readPTauHeader(fdOld, sections);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    await binFileUtils.copySection(fdOld, sections, fdNew, 2);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await processSection(3, 13, \"G2\", \"tauG2\" );\n    await processSection(4, 14, \"G1\", \"alphaTauG1\" );\n    await processSection(5, 15, \"G1\", \"betaTauG1\" );\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await binFileUtils.startWriteSection(fdNew, newSectionId);\n\n        for (let p=0; p<=power; p++) {\n            await processSectionPower(p);\n        }\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const Fr = curve.Fr;\n            const sGin = G.F.n8*2;\n            const sGmid = G.F.n8*3;\n\n            let buff;\n            buff = new BigBuffer(nPoints*sGin);\n\n            await binFileUtils.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await binFileUtils.endReadSection(fdOld, true);\n\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n    }\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as utils from \"./powersoftau_utils.js\";\n\nexport default async function truncate(ptauFilename, template, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(ptauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fdOld, sections);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    for (let p=1; p<power; p++) {\n        await generateTruncate(p);\n    }\n\n    await fdOld.close();\n\n    return true;\n\n    async function generateTruncate(p) {\n\n        let sP = p.toString();\n        while (sP.length<2) sP = \"0\" + sP;\n\n        if (logger) logger.debug(\"Writing Power: \"+sP);\n\n        const fdNew = await binFileUtils.createBinFile(template + sP + \".ptau\", \"ptau\", 1, 11);\n        await utils.writePTauHeader(fdNew, curve, p, ceremonyPower);\n\n        await binFileUtils.copySection(fdOld, sections, fdNew, 2, ((2 ** p)*2-1) * sG1 ); // tagG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 3, (2 ** p) * sG2); // tauG2\n        await binFileUtils.copySection(fdOld, sections, fdNew, 4, (2 ** p) * sG1); // alfaTauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 5, (2 ** p) * sG1); // betaTauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 6,  sG2); // betaTauG2\n        await binFileUtils.copySection(fdOld, sections, fdNew, 7); // contributions\n        await binFileUtils.copySection(fdOld, sections, fdNew, 12, ((2 ** (p+1))*2 -1) * sG1); // L_tauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 13, ((2 ** p)*2 -1) * sG2); // L_tauG2\n        await binFileUtils.copySection(fdOld, sections, fdNew, 14, ((2 ** p)*2 -1) * sG1); // L_alfaTauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 15, ((2 ** p)*2 -1) * sG1); // L_betaTauG1\n\n        await fdNew.close();\n    }\n\n\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as fastFile from \"fastfile\";\nimport {BigBuffer} from \"ffjavascript\";\n\nexport default async function convert(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await utils.readPTauHeader(fdOld, sections);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    // const fdTmp = await fastFile.createOverride(newPTauFilename+ \".tmp\");\n\n    await binFileUtils.copySection(fdOld, sections, fdNew, 2);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await binFileUtils.copySection(fdOld, sections, fdNew, 13);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 14);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 15);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await binFileUtils.startWriteSection(fdNew, newSectionId);\n\n        const size = sections[newSectionId][0].size;\n        const chunkSize = fdOld.pageSize;\n        await binFileUtils.startReadUniqueSection(fdOld, sections, newSectionId);\n        for (let p=0; p<size; p+=chunkSize) {\n            const l = Math.min(size -p, chunkSize);\n            const buff = await fdOld.read(l);\n            await fdNew.write(buff);\n        }\n        await binFileUtils.endReadSection(fdOld);\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const sGin = G.F.n8*2;\n\n            let buff;\n            buff = new BigBuffer(nPoints*sGin);\n\n            await binFileUtils.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await binFileUtils.endReadSection(fdOld, true);\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    if (i%10000) logger.debug(`sectionName prepare L calc: ${sectionName}, ${i}/${smallM}`);\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t1\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n\n\n    }\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport { stringifyBigIntsWithField } from \"./misc.js\";\n\nexport default async function exportJson(pTauFilename, verbose) {\n    const {fd, sections} = await binFileUtils.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await utils.readPTauHeader(fd, sections);\n\n    const pTau = {};\n    pTau.q = curve.q;\n    pTau.power = power;\n    pTau.contributions = await utils.readContributions(fd, curve, sections);\n\n    pTau.tauG1 = await exportSection(2, \"G1\", (2 ** power)*2 -1, \"tauG1\");\n    pTau.tauG2 = await exportSection(3, \"G2\", (2 ** power), \"tauG2\");\n    pTau.alphaTauG1 = await exportSection(4, \"G1\", (2 ** power), \"alphaTauG1\");\n    pTau.betaTauG1 = await exportSection(5, \"G1\", (2 ** power), \"betaTauG1\");\n    pTau.betaG2 = await exportSection(6, \"G2\", 1, \"betaG2\");\n\n    pTau.lTauG1 = await exportLagrange(12, \"G1\", \"lTauG1\");\n    pTau.lTauG2 = await exportLagrange(13, \"G2\", \"lTauG2\");\n    pTau.lAlphaTauG1 = await exportLagrange(14, \"G1\", \"lAlphaTauG2\");\n    pTau.lBetaTauG1 = await exportLagrange(15, \"G1\", \"lBetaTauG2\");\n\n    await fd.close();\n\n    return stringifyBigIntsWithField(curve.Fr, pTau);\n\n\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await binFileUtils.startReadUniqueSection(fd, sections, sectionId);\n        for (let i=0; i< nPoints; i++) {\n            if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ` + i);\n            const buff = await fd.read(sG);\n            res.push(G.fromRprLEM(buff, 0));\n        }\n        await binFileUtils.endReadSection(fd);\n\n        return res;\n    }\n\n    async function exportLagrange(sectionId, groupName, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await binFileUtils.startReadUniqueSection(fd, sections, sectionId);\n        for (let p=0; p<=power; p++) {\n            if (verbose) console.log(`${sectionName}: Power: ${p}`);\n            res[p] = [];\n            const nPoints = (2 ** p);\n            for (let i=0; i<nPoints; i++) {\n                if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ${i}/${nPoints}`);\n                const buff = await fd.read(sG);\n                res[p].push(G.fromRprLEM(buff, 0));\n            }\n        }\n        await binFileUtils.endReadSection(fd, true);\n        return res;\n    }\n\n\n}\n\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport {default as print} from \"./r1cs_print.js\";\nexport {default as info} from \"./r1cs_info.js\";\nexport {default as exportJson} from \"./r1cs_export_json.js\";\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport default function r1csPrint(r1cs, syms, logger) {\n    for (let i=0; i<r1cs.constraints.length; i++) {\n        printCostraint(r1cs.constraints[i]);\n    }\n    function printCostraint(c) {\n        const lc2str = (lc) => {\n            let S = \"\";\n            const keys = Object.keys(lc);\n            keys.forEach( (k) => {\n                let name = syms.varIdx2Name[k];\n                if (name == \"one\") name = \"\";\n\n                let vs = r1cs.curve.Fr.toString(lc[k]);\n                if (vs == \"1\") vs = \"\";  // Do not show ones\n                if (vs == \"-1\") vs = \"-\";  // Do not show ones\n                if ((S!=\"\")&&(vs[0]!=\"-\")) vs = \"+\"+vs;\n                if (S!=\"\") vs = \" \"+vs;\n                S= S + vs   + name;\n            });\n            return S;\n        };\n        const S = `[ ${lc2str(c[0])} ] * [ ${lc2str(c[1])} ] - [ ${lc2str(c[2])} ] = 0`;\n        if (logger) logger.info(S);\n    }\n\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { Scalar } from \"ffjavascript\";\nimport { readR1cs }  from \"r1csfile\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nexport default async function r1csInfo(r1csName, logger) {\n\n    const cir = await readR1cs(r1csName);\n\n    if (Scalar.eq(cir.prime, bn128r)) {\n        if (logger) logger.info(\"Curve: bn-128\");\n    } else if (Scalar.eq(cir.prime, bls12381r)) {\n        if (logger) logger.info(\"Curve: bls12-381\");\n    } else {\n        if (logger) logger.info(`Unknown Curve. Prime: ${Scalar.toString(cir.prime)}`);\n    }\n    if (logger) logger.info(`# of Wires: ${cir.nVars}`);\n    if (logger) logger.info(`# of Constraints: ${cir.nConstraints}`);\n    if (logger) logger.info(`# of Private Inputs: ${cir.nPrvInputs}`);\n    if (logger) logger.info(`# of Public Inputs: ${cir.nPubInputs}`);\n    if (logger) logger.info(`# of Labels: ${cir.nLabels}`);\n    if (logger) logger.info(`# of Outputs: ${cir.nOutputs}`);\n\n    return cir;\n}\n", "import {F1Field, getCurveFromR} from \"ffjavascript\";\nimport  BigArray from \"@iden3/bigarray\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\nexport const R1CS_FILE_HEADER_SECTION = 1;\nexport const R1CS_FILE_CONSTRAINTS_SECTION = 2;\nexport const R1CS_FILE_WIRE2LABELID_SECTION = 3;\nexport const R1CS_FILE_CUSTOM_GATES_LIST_SECTION = 4;\nexport const R1CS_FILE_CUSTOM_GATES_USES_SECTION = 5;\n\nexport async function readR1csHeader(fd,sections,singleThread) {\n    let options;\n    if (typeof singleThread === \"object\") {\n        options = singleThread;\n    } else if (typeof singleThread === \"undefined\") {\n        options= {\n            singleThread: false,\n        };\n    } else {\n        options = {\n            singleThread: singleThread,\n        };\n    }\n\n    const res = {};\n    await binFileUtils.startReadUniqueSection(fd, sections, 1);\n    // Read Header\n    res.n8 = await fd.readULE32();\n    res.prime = await binFileUtils.readBigInt(fd, res.n8);\n\n    if (options.F) {\n        if (options.F.p != res.prime) throw new Error(\"Different Prime\");\n        res.F = options.F;\n    } else if (options.getFieldFromPrime) {\n        res.F = await options.getFieldFromPrime(res.prime, options.singleThread);\n    } else if (options.getCurveFromPrime) {\n        res.curve = await options.getCurveFromPrime(res.prime, options.singleThread);\n        res.F = res.curve.Fr;\n    } else {\n        try {\n            res.curve = await getCurveFromR(res.prime, options.singleThread);\n            res.F = res.curve.Fr;\n        } catch (err) {\n            res.F = new F1Field(res.prime);\n        }\n    }\n\n    res.nVars = await fd.readULE32();\n    res.nOutputs = await fd.readULE32();\n    res.nPubInputs = await fd.readULE32();\n    res.nPrvInputs = await fd.readULE32();\n    res.nLabels = await fd.readULE64();\n    res.nConstraints = await fd.readULE32();\n    res.useCustomGates = typeof sections[R1CS_FILE_CUSTOM_GATES_LIST_SECTION] !== \"undefined\" && sections[R1CS_FILE_CUSTOM_GATES_LIST_SECTION] !== null\n        && typeof sections[R1CS_FILE_CUSTOM_GATES_USES_SECTION] !== \"undefined\" && sections[R1CS_FILE_CUSTOM_GATES_USES_SECTION] !== null;\n\n    await binFileUtils.endReadSection(fd);\n\n    return res;\n}\n\nexport async function readConstraints(fd,sections, r1cs, logger, loggerCtx) {\n    let options;\n    if (typeof logger === \"object\") {\n        options = logger;\n    } else if (typeof logger === \"undefined\") {\n        options= {};\n    } else {\n        options = {\n            logger: logger,\n            loggerCtx: loggerCtx,\n        };\n    }\n\n    const bR1cs = await binFileUtils.readSection(fd, sections, 2);\n    let bR1csPos = 0;\n    let constraints;\n    if (r1cs.nConstraints>1<<20) {\n        constraints = new BigArray();\n    } else {\n        constraints = [];\n    }\n    for (let i=0; i<r1cs.nConstraints; i++) {\n        if ((options.logger)&&(i%100000 == 0)) options.logger.info(`${options.loggerCtx}: Loading constraints: ${i}/${r1cs.nConstraints}`);\n        const c = readConstraint();\n        constraints.push(c);\n    }\n    return constraints;\n\n\n    function readConstraint() {\n        const c = [];\n        c[0] = readLC();\n        c[1] = readLC();\n        c[2] = readLC();\n        return c;\n    }\n\n    function readLC() {\n        const lc= {};\n\n        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos+4);\n        bR1csPos += 4;\n        const buffUL32V = new DataView(buffUL32.buffer);\n        const nIdx = buffUL32V.getUint32(0, true);\n\n        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4+r1cs.n8)*nIdx );\n        bR1csPos += (4+r1cs.n8)*nIdx;\n        const buffV = new DataView(buff.buffer);\n        for (let i=0; i<nIdx; i++) {\n            const idx = buffV.getUint32(i*(4+r1cs.n8), true);\n            const val = r1cs.F.fromRprLE(buff, i*(4+r1cs.n8)+4);\n            lc[idx] = val;\n        }\n        return lc;\n    }\n}\n\nexport async function readMap(fd, sections, r1cs, logger, loggerCtx) {\n    let options;\n    if (typeof logger === \"object\") {\n        options = logger;\n    } else if (typeof logger === \"undefined\") {\n        options= {};\n    } else {\n        options = {\n            logger: logger,\n            loggerCtx: loggerCtx,\n        };\n    }\n    const bMap = await binFileUtils.readSection(fd, sections, 3);\n    let bMapPos = 0;\n    let map;\n\n    if (r1cs.nVars>1<<20) {\n        map = new BigArray();\n    } else {\n        map = [];\n    }\n    for (let i=0; i<r1cs.nVars; i++) {\n        if ((options.logger)&&(i%10000 == 0)) options.logger.info(`${options.loggerCtx}: Loading map: ${i}/${r1cs.nVars}`);\n        const idx = readULE64();\n        map.push(idx);\n    }\n\n    return map;\n\n    function readULE64() {\n        const buffULE64 = bMap.slice(bMapPos, bMapPos+8);\n        bMapPos += 8;\n        const buffULE64V = new DataView(buffULE64.buffer);\n        const LSB = buffULE64V.getUint32(0, true);\n        const MSB = buffULE64V.getUint32(4, true);\n\n        return MSB * 0x100000000 + LSB;\n    }\n\n}\n\nexport async function readR1csFd(fd, sections, options) {\n    /**\n     * Options properties:\n     *  loadConstraints: <bool> true by default\n     *  loadMap:         <bool> false by default\n     *  loadCustomGates: <bool> true by default\n     */\n\n    if(typeof options !== \"object\") {\n        throw new Error(\"readR1csFd: options must be an object\");\n    }\n\n    options.loadConstraints = options.loadConstraints || true;\n    options.loadMap = options.loadMap || false;\n    options.loadCustomGates = options.loadCustomGates || true;\n\n    const res = await readR1csHeader(fd, sections, options);\n\n    if (options.loadConstraints) {\n        res.constraints = await readConstraints(fd, sections, res, options);\n    }\n\n    // Read Labels\n\n    if (options.loadMap) {\n        res.map = await readMap(fd, sections, res, options);\n    }\n\n    if (options.loadCustomGates) {\n        if (res.useCustomGates) {\n            res.customGates = await readCustomGatesListSection(fd, sections, res.F.n8);\n            res.customGatesUses = await readCustomGatesUsesSection(fd, sections, options);\n        } else {\n            res.customGates = [];\n            res.customGatesUses = [];\n        }\n    }\n    return res;\n}\n\nexport async function readR1cs(fileName, loadConstraints, loadMap, singleThread, logger, loggerCtx) {\n    let options;\n    if (typeof loadConstraints === \"object\") {\n        options = loadConstraints;\n    } else if (typeof loadConstraints === \"undefined\") {\n        options= {\n            loadConstraints: true,\n            loadMap: false,\n            loadCustomGates: true\n        };\n    } else {\n        options = {\n            loadConstraints: loadConstraints,\n            loadMap: loadMap,\n            singleThread: singleThread,\n            logger: logger,\n            loggerCtx: loggerCtx\n        };\n    }\n\n    const {fd, sections} = await binFileUtils.readBinFile(fileName, \"r1cs\", 1, 1<<25, 1<<22);\n\n    const res = await readR1csFd(fd, sections, options);\n\n    await fd.close();\n\n    return res;\n}\n\nexport async function readCustomGatesListSection(fd, sections, fieldSize) {\n    await binFileUtils.startReadUniqueSection(fd, sections, R1CS_FILE_CUSTOM_GATES_LIST_SECTION);\n\n    let num = await fd.readULE32();\n\n    let customGates = [];\n    for (let i = 0; i < num; i++) {\n        let customGate = {};\n        customGate.templateName = await fd.readString();\n        let numParameters = await fd.readULE32();\n\n        customGate.parameters = Array(numParameters);\n        let buff = await fd.read(fieldSize * numParameters);\n\n        for (let j = 0; j < numParameters; j++) {\n            customGate.parameters[j] = buff.slice(j * fieldSize, j * fieldSize + fieldSize);\n        }\n        customGates.push(customGate);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    return customGates;\n}\n\nexport async function readCustomGatesUsesSection(fd,sections, options) {\n    const bR1cs = await binFileUtils.readSection(fd, sections, R1CS_FILE_CUSTOM_GATES_USES_SECTION);\n    const bR1cs32 = new Uint32Array(bR1cs.buffer, bR1cs.byteOffset, bR1cs.byteLength/4);\n    const nCustomGateUses = bR1cs32[0];\n    let bR1csPos = 1;\n    let customGatesUses;\n    if (nCustomGateUses>1<<20) {\n        customGatesUses = new BigArray();\n    } else {\n        customGatesUses = [];\n    }\n    for (let i=0; i<nCustomGateUses; i++) {\n        if ((options.logger)&&(i%100000 == 0)) options.logger.info(`${options.loggerCtx}: Loading custom gate uses: ${i}/${nCustomGateUses}`);\n        let c = {};\n        c.id = bR1cs32[bR1csPos++];\n        let numSignals = bR1cs32[bR1csPos++];\n        c.signals = [];\n        for (let j = 0; j < numSignals; j++) {\n            const LSB = bR1cs32[bR1csPos++];\n            const MSB = bR1cs32[bR1csPos++];\n            c.signals.push(MSB * 0x100000000 + LSB);\n        }\n        customGatesUses.push(c);\n    }\n    return customGatesUses;\n}\n\nexport async function writeR1csHeader(fd, cir) {\n    await binFileUtils.startWriteSection(fd, 1);\n    await fd.writeULE32(cir.n8); // Temporally set to 0 length\n    await binFileUtils.writeBigInt(fd, cir.prime, cir.n8);\n\n    await fd.writeULE32(cir.nVars);\n    await fd.writeULE32(cir.nOutputs);\n    await fd.writeULE32(cir.nPubInputs);\n    await fd.writeULE32(cir.nPrvInputs);\n    await fd.writeULE64(cir.nLabels);\n    await fd.writeULE32(cir.constraints.length);\n\n    await binFileUtils.endWriteSection(fd);\n}\n\nexport async function writeR1csConstraints(fd, cir, logger, loggerCtx) {\n    await binFileUtils.startWriteSection(fd, 2);\n\n    for (let i=0; i<cir.constraints.length; i++) {\n        if ((logger)&&(i%10000 == 0)) logger.info(`${loggerCtx}: writing constraint: ${i}/${cir.constraints.length}`);\n        await writeConstraint(cir.constraints[i]);\n    }\n\n    await binFileUtils.endWriteSection(fd);\n\n\n    function writeConstraint(c) {\n        const n8 = cir.n8;\n        const F = cir.F || cir.curve.Fr;\n        const idxA = Object.keys(c[0]);\n        const idxB = Object.keys(c[1]);\n        const idxC = Object.keys(c[2]);\n        const buff = new Uint8Array((idxA.length+idxB.length+idxC.length)*(n8+4) + 12);\n        const buffV = new DataView(buff.buffer);\n        let o=0;\n\n        buffV.setUint32(o, idxA.length, true); o+=4;\n        for (let i=0; i<idxA.length; i++) {\n            const coef = idxA[i];\n            buffV.setUint32(o, coef, true); o+=4;\n            F.toRprLE(buff, o, c[0][coef]); o+=n8;\n        }\n\n        buffV.setUint32(o, idxB.length, true); o+=4;\n        for (let i=0; i<idxB.length; i++) {\n            const coef = idxB[i];\n            buffV.setUint32(o, coef, true); o+=4;\n            F.toRprLE(buff, o, c[1][coef]); o+=n8;\n        }\n\n        buffV.setUint32(o, idxC.length, true); o+=4;\n        for (let i=0; i<idxC.length; i++) {\n            const coef = idxC[i];\n            buffV.setUint32(o, coef, true); o+=4;\n            F.toRprLE(buff, o, c[2][coef]); o+=n8;\n        }\n\n        return fd.write(buff);\n    }\n\n}\n\n\nexport async function writeR1csMap(fd, cir, logger, loggerCtx) {\n    await binFileUtils.startWriteSection(fd, 3);\n\n    if (cir.map.length != cir.nVars) throw new Error(\"Invalid map size\");\n    for (let i=0; i<cir.nVars; i++) {\n        if ((logger)&&(i%10000 == 0)) logger.info(`${loggerCtx}: writing map: ${i}/${cir.nVars}`);\n        await fd.writeULE64(cir.map[i]);\n    }\n\n    await binFileUtils.endWriteSection(fd);\n}\n\n\n\nexport async function writeR1cs(fileName, cir, logger, loggerCtx) {\n\n    const fd = await binFileUtils.createBinFile(fileName, \"r1cs\", 1, 3, 1<<25, 1<<22);\n\n    await writeR1csHeader(fd, cir);\n\n    await writeR1csConstraints(fd, cir, logger, loggerCtx);\n\n    await writeR1csMap(fd, cir, logger, loggerCtx);\n\n    await fd.close();\n}\n", "\nimport * as _Scalar  from \"./src/scalar.js\";\nexport const Scalar=_Scalar;\n\nexport {default as PolField} from \"./src/polfield.js\";\nexport {default as F1Field} from \"./src/f1field.js\";\nexport {default as F2Field} from \"./src/f2field.js\";\nexport {default as F3Field} from \"./src/f3field.js\";\n\nexport {default as ZqField} from \"./src/f1field.js\";\n\nexport {default as EC} from \"./src/ec.js\";\n\nexport {default as buildBn128} from \"./src/bn128.js\";\nexport {default as buildBls12381} from \"./src/bls12381.js\";\n\nimport * as _utils from \"./src/utils.js\";\nexport const utils = _utils;\nexport {default as ChaCha} from \"./src/chacha.js\";\n\nexport {default as BigBuffer} from \"./src/bigbuffer.js\";\n\nexport {getCurveFromR, getCurveFromQ, getCurveFromName} from \"./src/curves.js\";\n\n", "\n/* global BigInt */\nconst hexLen = [ 0, 1, 2, 2, 3, 3, 3, 3, 4 ,4 ,4 ,4 ,4 ,4 ,4 ,4];\n\nexport function fromString(s, radix) {\n    if ((!radix)||(radix==10)) {\n        return BigInt(s);\n    } else if (radix==16) {\n        if (s.slice(0,2) == \"0x\") {\n            return BigInt(s);\n        } else {\n            return BigInt(\"0x\"+s);\n        }\n    }\n}\n\nexport const e = fromString;\n\nexport function fromArray(a, radix) {\n    let acc =BigInt(0);\n    radix = BigInt(radix);\n    for (let i=0; i<a.length; i++) {\n        acc = acc*radix + BigInt(a[i]);\n    }\n    return acc;\n}\n\nexport function bitLength(a) {\n    const aS =a.toString(16);\n    return (aS.length-1)*4 +hexLen[parseInt(aS[0], 16)];\n}\n\nexport function isNegative(a) {\n    return BigInt(a) < BigInt(0);\n}\n\nexport function isZero(a) {\n    return !a;\n}\n\nexport function shiftLeft(a, n) {\n    return BigInt(a) << BigInt(n);\n}\n\nexport function shiftRight(a, n) {\n    return BigInt(a) >> BigInt(n);\n}\n\nexport const shl = shiftLeft;\nexport const shr = shiftRight;\n\nexport function isOdd(a) {\n    return (BigInt(a) & BigInt(1)) == BigInt(1);\n}\n\n\nexport function naf(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            const z = 2 - Number(E % BigInt(4));\n            res.push( z );\n            E = E - BigInt(z);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\n\nexport function bits(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\nexport function toNumber(s) {\n    if (s>BigInt(Number.MAX_SAFE_INTEGER )) {\n        throw new Error(\"Number too big\");\n    }\n    return Number(s);\n}\n\nexport function toArray(s, radix) {\n    const res = [];\n    let rem = BigInt(s);\n    radix = BigInt(radix);\n    while (rem) {\n        res.unshift( Number(rem % radix));\n        rem = rem / radix;\n    }\n    return res;\n}\n\n\nexport function add(a, b) {\n    return BigInt(a) + BigInt(b);\n}\n\nexport function sub(a, b) {\n    return BigInt(a) - BigInt(b);\n}\n\nexport function neg(a) {\n    return -BigInt(a);\n}\n\nexport function mul(a, b) {\n    return BigInt(a) * BigInt(b);\n}\n\nexport function square(a) {\n    return BigInt(a) * BigInt(a);\n}\n\nexport function pow(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function exp(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function abs(a) {\n    return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);\n}\n\nexport function div(a, b) {\n    return BigInt(a) / BigInt(b);\n}\n\nexport function mod(a, b) {\n    return BigInt(a) % BigInt(b);\n}\n\nexport function eq(a, b) {\n    return BigInt(a) == BigInt(b);\n}\n\nexport function neq(a, b) {\n    return BigInt(a) != BigInt(b);\n}\n\nexport function lt(a, b) {\n    return BigInt(a) < BigInt(b);\n}\n\nexport function gt(a, b) {\n    return BigInt(a) > BigInt(b);\n}\n\nexport function leq(a, b) {\n    return BigInt(a) <= BigInt(b);\n}\n\nexport function geq(a, b) {\n    return BigInt(a) >= BigInt(b);\n}\n\nexport function band(a, b) {\n    return BigInt(a) & BigInt(b);\n}\n\nexport function bor(a, b) {\n    return BigInt(a) | BigInt(b);\n}\n\nexport function bxor(a, b) {\n    return BigInt(a) ^ BigInt(b);\n}\n\nexport function land(a, b) {\n    return BigInt(a) && BigInt(b);\n}\n\nexport function lor(a, b) {\n    return BigInt(a) || BigInt(b);\n}\n\nexport function lnot(a) {\n    return !BigInt(a);\n}\n\n// Returns a buffer with Little Endian Representation\nexport function toRprLE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new Uint32Array(buff.buffer, o, n8/4);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v[i] = parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16);\n    for (let i=l; i<v.length; i++) v[i] = 0;\n    for (let i=v.length*4; i<n8; i++) buff[i] = toNumber(band(shiftRight(e, i*8), 0xFF));\n}\n\n// Returns a buffer with Big Endian Representation\nexport function toRprBE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v.setUint32(n8-i*4 -4, parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16), false);\n    for (let i=0; i<n8/4-l; i++) v[i] = 0;\n}\n\n// Pases a buffer with Little Endian Representation\nexport function fromRprLE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new Uint32Array(buff.buffer, o, n8/4);\n    const a = new Array(n8/4);\n    v.forEach( (ch,i) => a[a.length-i-1] = ch.toString(16).padStart(8,\"0\") );\n    return fromString(a.join(\"\"), 16);\n}\n\n// Pases a buffer with Big Endian Representation\nexport function fromRprBE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const a = new Array(n8/4);\n    for (let i=0; i<n8/4; i++) {\n        a[i] = v.getUint32(i*4, false).toString(16).padStart(8, \"0\");\n    }\n    return fromString(a.join(\"\"), 16);\n}\n\nexport function toString(a, radix) {\n    return a.toString(radix);\n}\n\nexport function toLEBuff(a) {\n    const buff = new Uint8Array(Math.floor((bitLength(a) - 1) / 8) +1);\n    toRprLE(buff, 0, a, buff.byteLength);\n    return buff;\n}\n\nexport const zero = e(0);\nexport const one = e(1);\n\n\n\n\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class PolField {\n    constructor (F) {\n        this.F = F;\n\n        let rem = F.sqrt_t;\n        let s = F.sqrt_s;\n\n        const five = this.F.add(this.F.add(this.F.two, this.F.two), this.F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(five, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n/*        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n    */\n        this._setRoots(15);\n    }\n\n    _setRoots(n) {\n        if (n > this.F.sqrt_s) n = this.s;\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n            this.roots[i] = rootsi;\n        }\n    }\n\n    add(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.add(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.sub(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    mulScalar(p, b) {\n        if (this.F.eq(b, this.F.zero)) return [];\n        if (this.F.eq(b, this.F.one)) return p;\n        const res = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.mul(p[i], b);\n        }\n        return res;\n    }\n\n\n\n    mul(a, b) {\n        if (a.length == 0) return [];\n        if (b.length == 0) return [];\n        if (a.length == 1) return this.mulScalar(b, a[0]);\n        if (b.length == 1) return this.mulScalar(a, b[0]);\n\n        if (b.length > a.length) {\n            [b, a] = [a, b];\n        }\n\n        if ((b.length <= 2) || (b.length < log2(a.length))) {\n            return this.mulNormal(a,b);\n        } else {\n            return this.mulFFT(a,b);\n        }\n    }\n\n    mulNormal(a, b) {\n        let res = [];\n        for (let i=0; i<b.length; i++) {\n            res = this.add(res, this.scaleX(this.mulScalar(a, b[i]), i) );\n        }\n        return res;\n    }\n\n    mulFFT(a,b) {\n        const longestN = Math.max(a.length, b.length);\n        const bitsResult = log2(longestN-1)+2;\n        this._setRoots(bitsResult);\n\n        const m = 1 << bitsResult;\n        const ea = this.extend(a,m);\n        const eb = this.extend(b,m);\n\n        const ta = __fft(this, ea, bitsResult, 0, 1, false);\n        const tb = __fft(this, eb, bitsResult, 0, 1, false);\n\n        const tres = new Array(m);\n\n        for (let i=0; i<m; i++) {\n            tres[i] = this.F.mul(ta[i], tb[i]);\n        }\n\n        const res = __fft(this, tres, bitsResult, 0, 1, true);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return this.reduce(resn);\n    }\n\n\n\n    square(a) {\n        return this.mul(a,a);\n    }\n\n    scaleX(p, n) {\n        if (n==0) {\n            return p;\n        } else if (n>0) {\n            const z = new Array(n).fill(this.F.zero);\n            return z.concat(p);\n        } else {\n            if (-n >= p.length) return [];\n            return p.slice(-n);\n        }\n    }\n\n    eval2(p, x) {\n        let v = this.F.zero;\n        let ix = this.F.one;\n        for (let i=0; i<p.length; i++) {\n            v = this.F.add(v, this.F.mul(p[i], ix));\n            ix = this.F.mul(ix, x);\n        }\n        return v;\n    }\n\n    eval(p,x) {\n        const F = this.F;\n        if (p.length == 0) return F.zero;\n        const m = this._next2Power(p.length);\n        const ep = this.extend(p, m);\n\n        return _eval(ep, x, 0, 1, m);\n\n        function _eval(p, x, offset, step, n) {\n            if (n==1) return p[offset];\n            const newX = F.square(x);\n            const res= F.add(\n                _eval(p, newX, offset, step << 1, n >> 1),\n                F.mul(\n                    x,\n                    _eval(p, newX, offset+step , step << 1, n >> 1)));\n            return res;\n        }\n    }\n\n    lagrange(points) {\n        let roots = [this.F.one];\n        for (let i=0; i<points.length; i++) {\n            roots = this.mul(roots, [this.F.neg(points[i][0]), this.F.one]);\n        }\n\n        let sum = [];\n        for (let i=0; i<points.length; i++) {\n            let mpol = this.ruffini(roots, points[i][0]);\n            const factor =\n                this.F.mul(\n                    this.F.inv(this.eval(mpol, points[i][0])),\n                    points[i][1]);\n            mpol = this.mulScalar(mpol, factor);\n            sum = this.add(sum, mpol);\n        }\n        return sum;\n    }\n\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res = __fft(this, ep, bits, 0, 1);\n        return res;\n    }\n\n    fft2(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res = __fft2(this, ep, bits);\n        return res;\n    }\n\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res =  __fft(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n\n    ifft2(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res =  __fft2(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n    _fft(pall, bits, offset, step) {\n\n        const n = 1 << bits;\n        if (n==1) {\n            return [ pall[offset] ];\n        }\n\n        const ndiv2 = n >> 1;\n        const p1 = this._fft(pall, bits-1, offset, step*2);\n        const p2 = this._fft(pall, bits-1, offset+step, step*2);\n\n        const out = new Array(n);\n\n        let m= this.F.one;\n        for (let i=0; i<ndiv2; i++) {\n            out[i] = this.F.add(p1[i], this.F.mul(m, p2[i]));\n            out[i+ndiv2] = this.F.sub(p1[i], this.F.mul(m, p2[i]));\n            m = this.F.mul(m, this.w[bits]);\n        }\n\n        return out;\n    }\n\n    extend(p, e) {\n        if (e == p.length) return p;\n        const z = new Array(e-p.length).fill(this.F.zero);\n\n        return p.concat(z);\n    }\n\n    reduce(p) {\n        if (p.length == 0) return p;\n        if (! this.F.eq(p[p.length-1], this.F.zero) ) return p;\n        let i=p.length-1;\n        while( i>0 && this.F.eq(p[i], this.F.zero) ) i--;\n        return p.slice(0, i+1);\n    }\n\n    eq(a, b) {\n        const pa = this.reduce(a);\n        const pb = this.reduce(b);\n\n        if (pa.length != pb.length) return false;\n        for (let i=0; i<pb.length; i++) {\n            if (!this.F.eq(pa[i], pb[i])) return false;\n        }\n\n        return true;\n    }\n\n    ruffini(p, r) {\n        const res = new Array(p.length-1);\n        res[res.length-1] = p[p.length-1];\n        for (let i = res.length-2; i>=0; i--) {\n            res[i] = this.F.add(this.F.mul(res[i+1], r), p[i+1]);\n        }\n        return res;\n    }\n\n    _next2Power(v) {\n        v--;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v++;\n        return v;\n    }\n\n    toString(p) {\n        const ap = this.normalize(p);\n        let S = \"\";\n        for (let i=ap.length-1; i>=0; i--) {\n            if (!this.F.eq(p[i], this.F.zero)) {\n                if (S!=\"\") S += \" + \";\n                S = S + p[i].toString(10);\n                if (i>0) {\n                    S = S + \"x\";\n                    if (i>1) {\n                        S = S + \"^\" +i;\n                    }\n                }\n            }\n        }\n        return S;\n    }\n\n    normalize(p) {\n        const res  = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.normalize(p[i]);\n        }\n        return res;\n    }\n\n\n    _reciprocal(p, bits) {\n        const k = 1 << bits;\n        if (k==1) {\n            return [ this.F.inv(p[0]) ];\n        }\n        const np = this.scaleX(p, -k/2);\n        const q = this._reciprocal(np, bits-1);\n        const a = this.scaleX(this.double(q), 3*k/2-2);\n        const b = this.mul( this.square(q), p);\n\n        return this.scaleX(this.sub(a,b),   -(k-2));\n    }\n\n    // divides x^m / v\n    _div2(m, v) {\n        const kbits = log2(v.length-1)+1;\n        const k = 1 << kbits;\n\n        const scaleV = k - v.length;\n\n        // rec = x^(k - 2) / v* x^scaleV =>\n        // rec = x^(k-2-scaleV)/ v\n        //\n        // res = x^m/v = x^(m + (2*k-2 - scaleV) - (2*k-2 - scaleV)) /v =>\n        // res = rec * x^(m - (2*k-2 - scaleV)) =>\n        // res = rec * x^(m - 2*k + 2 + scaleV)\n\n        const rec = this._reciprocal(this.scaleX(v, scaleV), kbits);\n        const res = this.scaleX(rec, m - 2*k + 2 + scaleV);\n\n        return res;\n    }\n\n    div(_u, _v) {\n        if (_u.length < _v.length) return [];\n        const kbits = log2(_v.length-1)+1;\n        const k = 1 << kbits;\n\n        const u = this.scaleX(_u, k-_v.length);\n        const v = this.scaleX(_v, k-_v.length);\n\n        const n = v.length-1;\n        let m = u.length-1;\n\n        const s = this._reciprocal(v, kbits);\n        let t;\n        if (m>2*n) {\n            t = this.sub(this.scaleX([this.F.one], 2*n), this.mul(s, v));\n        }\n\n        let q = [];\n        let rem = u;\n        let us, ut;\n        let finish = false;\n\n        while (!finish) {\n            us = this.mul(rem, s);\n            q = this.add(q, this.scaleX(us, -2*n));\n\n            if ( m > 2*n ) {\n                ut = this.mul(rem, t);\n                rem = this.scaleX(ut, -2*n);\n                m = rem.length-1;\n            } else {\n                finish = true;\n            }\n        }\n\n        return q;\n    }\n\n\n    // returns the ith nth-root of one\n    oneRoot(n, i) {\n        let nbits = log2(n-1)+1;\n        let res = this.F.one;\n        let r = i;\n\n        if(i>=n) {\n            throw new Error(\"Given 'i' should be lower than 'n'\");\n        }\n        else if (1<<nbits !== n) {\n            throw new Error(`Internal errlr: ${n} should equal ${1<<nbits}`);\n        }\n\n        while (r>0) {\n            if (r & 1 == 1) {\n                res = this.F.mul(res, this.w[nbits]);\n            }\n            r = r >> 1;\n            nbits --;\n        }\n        return res;\n    }\n\n    computeVanishingPolinomial(bits, t) {\n        const m = 1 << bits;\n        return this.F.sub(this.F.pow(t, m), this.F.one);\n    }\n\n    evaluateLagrangePolynomials(bits, t) {\n        const m= 1 << bits;\n        const tm = this.F.pow(t, m);\n        const u= new Array(m).fill(this.F.zero);\n        this._setRoots(bits);\n        const omega = this.w[bits];\n\n        if (this.F.eq(tm, this.F.one)) {\n            for (let i = 0; i < m; i++) {\n                if (this.F.eq(this.roots[bits][0],t)) { // i.e., t equals omega^i\n                    u[i] = this.F.one;\n                    return u;\n                }\n            }\n        }\n\n        const z = this.F.sub(tm, this.F.one);\n        //        let l = this.F.mul(z,  this.F.pow(this.F.twoinv, m));\n        let l = this.F.mul(z,  this.F.inv(this.F.e(m)));\n        for (let i = 0; i < m; i++) {\n            u[i] = this.F.mul(l, this.F.inv(this.F.sub(t,this.roots[bits][i])));\n            l = this.F.mul(l, omega);\n        }\n\n        return u;\n    }\n\n    log2(V) {\n        return log2(V);\n    }\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.F.add(pall[offset], pall[offset + step]),\n            PF.F.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\n\nfunction __fft2(PF, pall, bits) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[0] ];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft2(PF, pall.slice(0, ndiv2), bits-1);\n    const p2 = __fft2(PF, pall.slice(ndiv2), bits-1);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction rev(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\nfunction __bitReverse(p, bits) {\n    for (let k=0; k<p.length; k++) {\n        const r = rev(k, bits);\n        if (r>k) {\n            const tmp= p[k];\n            p[k] = p[r];\n            p[r] = tmp;\n        }\n    }\n\n}\n\n\n", "/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\nimport * as futils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\nimport {getRandomBytes} from \"./random.js\";\nimport FFFT from \"./fft.js\";\n\nexport default class ZqField {\n    constructor(p) {\n        this.type=\"F1\";\n        this.one = BigInt(1);\n        this.zero = BigInt(0);\n        this.p = BigInt(p);\n        this.m = 1;\n        this.negone = this.p-this.one;\n        this.two = BigInt(2);\n        this.half = this.p >> this.one;\n        this.bitLength = Scalar.bitLength(this.p);\n        this.mask = (this.one << BigInt(this.bitLength)) - this.one;\n\n        this.n64 = Math.floor((this.bitLength - 1) / 64)+1;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n        this.R = this.e(this.one << BigInt(this.n64*64));\n        this.Ri = this.inv(this.R);\n\n        const e = this.negone >> this.one;\n        this.nqr = this.two;\n        let r = this.pow(this.nqr, e);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.nqr + this.one;\n            r = this.pow(this.nqr, e);\n        }\n\n\n        this.s = 0;\n        this.t = this.negone;\n\n        while ((this.t & this.one) == this.zero) {\n            this.s = this.s + 1;\n            this.t = this.t >> this.one;\n        }\n\n        this.nqr_to_t = this.pow(this.nqr, this.t);\n\n        buildSqrt(this);\n\n        this.FFT = new FFFT(this, this, this.mul.bind(this));\n\n        this.fft = this.FFT.fft.bind(this.FFT);\n        this.ifft = this.FFT.ifft.bind(this.FFT);\n        this.w = this.FFT.w;\n        this.wi = this.FFT.wi; \n    \n        this.shift = this.square(this.nqr);\n        this.k = this.exp(this.nqr, 2**this.s);\n    }\n\n    e(a,b) {\n        let res;\n        if (!b) {\n            res = BigInt(a);\n        } else if (b==16) {\n            res = BigInt(\"0x\"+a);\n        }\n        if (res < 0) {\n            let nres = -res;\n            if (nres >= this.p) nres = nres % this.p;\n            return this.p - nres;\n        } else {\n            return (res>= this.p) ? res%this.p : res;\n        }\n\n    }\n\n    add(a, b) {\n        const res = a + b;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    sub(a, b) {\n        return (a >= b) ? a-b : this.p-b+a;\n    }\n\n    neg(a) {\n        return a ? this.p-a : a;\n    }\n\n    mul(a, b) {\n        return (a*b)%this.p;\n    }\n\n    mulScalar(base, s) {\n        return (base * this.e(s)) % this.p;\n    }\n\n    square(a) {\n        return (a*a) % this.p;\n    }\n\n    eq(a, b) {\n        return a==b;\n    }\n\n    neq(a, b) {\n        return a!=b;\n    }\n\n    lt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa < bb;\n    }\n\n    gt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa > bb;\n    }\n\n    leq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa <= bb;\n    }\n\n    geq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa >= bb;\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    idiv(a, b) {\n        if (!b) throw new Error(\"Division by zero\");\n        return a / b;\n    }\n\n    inv(a) {\n        if (!a) throw new Error(\"Division by zero\");\n\n        let t = this.zero;\n        let r = this.p;\n        let newt = this.one;\n        let newr = a % this.p;\n        while (newr) {\n            let q = r/newr;\n            [t, newt] = [newt, t-q*newt];\n            [r, newr] = [newr, r-q*newr];\n        }\n        if (t<this.zero) t += this.p;\n        return t;\n    }\n\n    mod(a, b) {\n        return a % b;\n    }\n\n    pow(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    exp(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    band(a, b) {\n        const res =  ((a & b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bor(a, b) {\n        const res =  ((a | b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bxor(a, b) {\n        const res =  ((a ^ b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bnot(a) {\n        const res = a ^ this.mask;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    shl(a, b) {\n        if (Number(b) < this.bitLength) {\n            const res = (a << b) & this.mask;\n            return res >= this.p ? res-this.p : res;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                return a >> nb;\n            } else {\n                return this.zero;\n            }\n        }\n    }\n\n    shr(a, b) {\n        if (Number(b) < this.bitLength) {\n            return a >> b;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                const res = (a << nb) & this.mask;\n                return res >= this.p ? res-this.p : res;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    land(a, b) {\n        return (a && b) ? this.one : this.zero;\n    }\n\n    lor(a, b) {\n        return (a || b) ? this.one : this.zero;\n    }\n\n    lnot(a) {\n        return (a) ? this.zero : this.one;\n    }\n\n    sqrt_old(n) {\n\n        if (n == this.zero) return this.zero;\n\n        // Test that have solution\n        const res = this.pow(n, this.negone >> this.one);\n        if ( res != this.one ) return null;\n\n        let m = this.s;\n        let c = this.nqr_to_t;\n        let t = this.pow(n, this.t);\n        let r = this.pow(n, this.add(this.t, this.one) >> this.one );\n\n        while ( t != this.one ) {\n            let sq = this.square(t);\n            let i = 1;\n            while (sq != this.one ) {\n                i++;\n                sq = this.square(sq);\n            }\n\n            // b = c ^ m-i-1\n            let b = c;\n            for (let j=0; j< m-i-1; j ++) b = this.square(b);\n\n            m = i;\n            c = this.square(b);\n            t = this.mul(t, c);\n            r = this.mul(r, b);\n        }\n\n        if (r > (this.p >> this.one)) {\n            r = this.neg(r);\n        }\n\n        return r;\n    }\n\n    normalize(a, b) {\n        a = BigInt(a,b);\n        if (a < 0) {\n            let na = -a;\n            if (na >= this.p) na = na % this.p;\n            return this.p - na;\n        } else {\n            return (a>= this.p) ? a%this.p : a;\n        }\n    }\n\n    random() {\n        const nBytes = (this.bitLength*2 / 8);\n        let res =this.zero;\n        for (let i=0; i<nBytes; i++) {\n            res = (res << BigInt(8)) + BigInt(getRandomBytes(1)[0]);\n        }\n        return res % this.p;\n    }\n\n    toString(a, base) {\n        base = base || 10;\n        let vs;\n        if ((a > this.half)&&(base == 10)) {\n            const v = this.p-a;\n            vs = \"-\"+v.toString(base);\n        } else {\n            vs = a.toString(base);\n        }\n        return vs;\n    }\n\n    isZero(a) {\n        return a == this.zero;\n    }\n\n    fromRng(rng) {\n        let v;\n        do {\n            v=this.zero;\n            for (let i=0; i<this.n64; i++) {\n                v += rng.nextU64() << BigInt(64 *i);\n            }\n            v &= this.mask;\n        } while (v >= this.p);\n        v = (v * this.Ri) % this.p;   // Convert from montgomery\n        return v;\n    }\n\n    fft(a) {\n        return this.FFT.fft(a);\n    }\n\n    ifft(a) {\n        return this.FFT.ifft(a);\n    }\n\n    // Returns a buffer with Little Endian Representation\n    toRprLE(buff, o, e) {\n        Scalar.toRprLE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Representation\n    toRprBE(buff, o, e) {\n        Scalar.toRprBE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Montgomery Representation\n    toRprBEM(buff, o, e) {\n        return this.toRprBE(buff, o, this.mul(this.R, e));\n    }\n\n    toRprLEM(buff, o, e) {\n        return this.toRprLE(buff, o, this.mul(this.R, e));\n    }\n\n\n    // Pases a buffer with Little Endian Representation\n    fromRprLE(buff, o) {\n        return Scalar.fromRprLE(buff, o, this.n8);\n    }\n\n    // Pases a buffer with Big Endian Representation\n    fromRprBE(buff, o) {\n        return Scalar.fromRprBE(buff, o, this.n8);\n    }\n\n    fromRprLEM(buff, o) {\n        return this.mul(this.fromRprLE(buff, o), this.Ri);\n    }\n\n    fromRprBEM(buff, o) {\n        return this.mul(this.fromRprBE(buff, o), this.Ri);\n    }\n\n    toObject(a) {\n        return a;\n    }\n}", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as Scalar from \"./scalar.js\";\n\n\nexport function mulScalar(F, base, e) {\n    let res;\n\n    if (Scalar.isZero(e)) return F.zero;\n\n    const n = Scalar.naf(e);\n\n    if (n[n.length-1] == 1) {\n        res = base;\n    } else if (n[n.length-1] == -1) {\n        res = F.neg(base);\n    } else {\n        throw new Error(\"invlaud NAF\");\n    }\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.double(res);\n\n        if (n[i] == 1) {\n            res = F.add(res, base);\n        } else if (n[i] == -1) {\n            res = F.sub(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n/*\nexports.mulScalar = (F, base, e) =>{\n    let res = F.zero;\n    let rem = bigInt(e);\n    let exp = base;\n\n    while (! rem.eq(bigInt.zero)) {\n        if (rem.and(bigInt.one).eq(bigInt.one)) {\n            res = F.add(res, exp);\n        }\n        exp = F.double(exp);\n        rem = rem.shiftRight(1);\n    }\n\n    return res;\n};\n*/\n\n\nexport function exp(F, base, e) {\n\n    if (Scalar.isZero(e)) return F.one;\n\n    const n = Scalar.bits(e);\n\n    if (n.length==0) return F.one;\n\n    let res = base;\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.square(res);\n\n        if (n[i]) {\n            res = F.mul(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n", "import * as Scalar from \"./scalar.js\";\n// Check here: https://eprint.iacr.org/2012/685.pdf\n\nexport default function buildSqrt (F) {\n    if ((F.m % 2) == 1) {\n        if (Scalar.eq(Scalar.mod(F.p, 4), 1 )) {\n            if (Scalar.eq(Scalar.mod(F.p, 8), 1 )) {\n                if (Scalar.eq(Scalar.mod(F.p, 16), 1 )) {\n                    // alg7_muller(F);\n                    alg5_tonelliShanks(F);\n                } else if (Scalar.eq(Scalar.mod(F.p, 16), 9 )) {\n                    alg4_kong(F);\n                } else {\n                    throw new Error(\"Field withot sqrt\");\n                }\n            } else if (Scalar.eq(Scalar.mod(F.p, 8), 5 )) {\n                alg3_atkin(F);\n            } else {\n                throw new Error(\"Field withot sqrt\");\n            }\n        } else if (Scalar.eq(Scalar.mod(F.p, 4), 3 )) {\n            alg2_shanks(F);\n        }\n    } else {\n        const pm2mod4 = Scalar.mod(Scalar.pow(F.p, F.m/2), 4);\n        if (pm2mod4 == 1) {\n            alg10_adj(F);\n        } else if (pm2mod4 == 3) {\n            alg9_adj(F);\n        } else {\n            alg8_complex(F);\n        }\n\n    }\n}\n\n\nfunction alg5_tonelliShanks(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n\n    F.sqrt_s = 0;\n    F.sqrt_t = Scalar.sub(F.sqrt_q, 1);\n\n    while (!Scalar.isOdd(F.sqrt_t)) {\n        F.sqrt_s = F.sqrt_s + 1;\n        F.sqrt_t = Scalar.div(F.sqrt_t, 2);\n    }\n\n    let c0 = F.one;\n\n    while (F.eq(c0, F.one)) {\n        const c = F.random();\n        F.sqrt_z = F.pow(c, F.sqrt_t);\n        c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s-1) );\n    }\n\n    F.sqrt_tm1d2 = Scalar.div(Scalar.sub(F.sqrt_t, 1),2);\n\n    F.sqrt = function(a) {\n        const F=this;\n        if (F.isZero(a)) return F.zero;\n        let w = F.pow(a, F.sqrt_tm1d2);\n        const a0 = F.pow( F.mul(F.square(w), a), 2 ** (F.sqrt_s-1) );\n        if (F.eq(a0, F.negone)) return null;\n\n        let v = F.sqrt_s;\n        let x = F.mul(a, w);\n        let b = F.mul(x, w);\n        let z = F.sqrt_z;\n        while (!F.eq(b, F.one)) {\n            let b2k = F.square(b);\n            let k=1;\n            while (!F.eq(b2k, F.one)) {\n                b2k = F.square(b2k);\n                k++;\n            }\n\n            w = z;\n            for (let i=0; i<v-k-1; i++) {\n                w = F.square(w);\n            }\n            z = F.square(w);\n            b = F.mul(b, z);\n            x = F.mul(x, w);\n            v = k;\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg4_kong(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 4 not implemented\");\n    };\n}\n\nfunction alg3_atkin(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 3 not implemented\");\n    };\n}\n\nfunction alg2_shanks(F) {\n\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n    F.sqrt_e1 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n\n    F.sqrt = function(a) {\n        if (this.isZero(a)) return this.zero;\n\n        // Test that have solution\n        const a1 = this.pow(a, this.sqrt_e1);\n\n        const a0 = this.mul(this.square(a1), a);\n\n        if ( this.eq(a0, this.negone) ) return null;\n\n        const x = this.mul(a1, a);\n\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg10_adj(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 10 not implemented\");\n    };\n}\n\nfunction alg9_adj(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m/2);\n    F.sqrt_e34 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n    F.sqrt_e12 = Scalar.div( Scalar.sub(F.sqrt_q, 1) , 2);\n\n    F.frobenius = function(n, x) {\n        if ((n%2) == 1) {\n            return F.conjugate(x);\n        } else {\n            return x;\n        }\n    };\n\n    F.sqrt = function(a) {\n        const F = this;\n        const a1 = F.pow(a, F.sqrt_e34);\n        const alfa = F.mul(F.square(a1), a);\n        const a0 = F.mul(F.frobenius(1, alfa), alfa);\n        if (F.eq(a0, F.negone)) return null;\n        const x0 = F.mul(a1, a);\n        let x;\n        if (F.eq(alfa, F.negone)) {\n            x = F.mul(x0, [F.F.zero, F.F.one]);\n        } else {\n            const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n            x = F.mul(b, x0);\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\n\nfunction alg8_complex(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 8 not implemented\");\n    };\n}\n", "import ChaCha from \"./chacha.js\";\nimport crypto from \"crypto\";\n\nexport function getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (process.browser) { // Browser\n        if (typeof globalThis.crypto !== \"undefined\") { // Supported\n            globalThis.crypto.getRandomValues(array);\n        } else { // fallback\n            for (let i=0; i<n; i++) {\n                array[i] = (Math.random()*4294967296)>>>0;\n            }\n        }\n    }\n    else { // NodeJS\n        crypto.randomFillSync(array);\n    }\n    return array;\n}\n\nexport function getRandomSeed() {\n    const arr = getRandomBytes(32);\n    const arrV = new Uint32Array(arr.buffer);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed.push(arrV[i]);\n    }\n    return seed;\n}\n\nlet threadRng = null;\n\nexport function getThreadRng() {\n    if (threadRng) return threadRng;\n    threadRng = new ChaCha(getRandomSeed());\n    return threadRng;\n}\n", "\n\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction quarterRound(st, a, b, c, d) {\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 16) | ((st[d]>>>16) & 0xFFFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 12) | ((st[b]>>>20) & 0xFFF)) >>> 0;\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 8) | ((st[d]>>>24) & 0xFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 7) | ((st[b]>>>25) & 0x7F)) >>> 0;\n}\n\nfunction doubleRound(st) {\n    quarterRound(st, 0, 4, 8,12);\n    quarterRound(st, 1, 5, 9,13);\n    quarterRound(st, 2, 6,10,14);\n    quarterRound(st, 3, 7,11,15);\n\n    quarterRound(st, 0, 5,10,15);\n    quarterRound(st, 1, 6,11,12);\n    quarterRound(st, 2, 7, 8,13);\n    quarterRound(st, 3, 4, 9,14);\n}\n\nexport default class ChaCha {\n\n    constructor(seed) {\n        seed = seed || [0,0,0,0,0,0,0,0];\n        this.state = [\n            0x61707865,\n            0x3320646E,\n            0x79622D32,\n            0x6B206574,\n            seed[0],\n            seed[1],\n            seed[2],\n            seed[3],\n            seed[4],\n            seed[5],\n            seed[6],\n            seed[7],\n            0,\n            0,\n            0,\n            0\n        ];\n        this.idx = 16;\n        this.buff = new Array(16);\n    }\n\n    nextU32() {\n        if (this.idx == 16) this.update();\n        return this.buff[this.idx++];\n    }\n\n    nextU64() {\n        return Scalar.add(Scalar.mul(this.nextU32(), 0x100000000), this.nextU32());\n    }\n\n    nextBool() {\n        return (this.nextU32() & 1) == 1;\n    }\n\n    update() {\n        // Copy the state\n        for (let i=0; i<16; i++) this.buff[i] = this.state[i];\n\n        // Apply the rounds\n        for (let i=0; i<10; i++) doubleRound(this.buff);\n\n        // Add to the initial\n        for (let i=0; i<16; i++) this.buff[i] = (this.buff[i] + this.state[i]) >>> 0;\n\n        this.idx = 0;\n\n        this.state[12] = (this.state[12] + 1) >>> 0;\n        if (this.state[12] != 0) return;\n        this.state[13] = (this.state[13] + 1) >>> 0;\n        if (this.state[13] != 0) return;\n        this.state[14] = (this.state[14] + 1) >>> 0;\n        if (this.state[14] != 0) return;\n        this.state[15] = (this.state[15] + 1) >>> 0;\n    }\n}\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class FFT {\n    constructor (G, F, opMulGF) {\n        this.F = F;\n        this.G = G;\n        this.opMulGF = opMulGF;\n\n        let rem = F.sqrt_t || F.t;\n        let s = F.sqrt_s || F.s;\n\n        let nqr = F.one;\n        while (F.eq(F.pow(nqr, F.half), F.one)) nqr = F.add(nqr, F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(nqr, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n        /*\n        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n        */\n        this._setRoots(Math.min(s, 15));\n    }\n\n    _setRoots(n) {\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots[i] = rootsi;\n        }\n    }\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res = __fft(this, p, bits, 0, 1);\n        return res;\n    }\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res =  __fft(this, p, bits, 0, 1);\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.opMulGF(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n    }\n\n\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.G.add(pall[offset], pall[offset + step]),\n            PF.G.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n        out[i+ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n    }\n\n    return out;\n}\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\n\nexport default class F2Field {\n    constructor(F, nonResidue) {\n        this.type=\"F2\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*2;\n        this.p = F.p;\n        this.n64 = F.n64*2;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n\n        buildSqrt(this);\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    conjugate(a) {\n        return [\n            a[0],\n            this.F.neg(a[1])\n        ];\n    }\n\n    mul(a, b) {\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n\n        return [\n            this.F.add( aA , this._mulByNonResidue(bB)),\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]),\n                    this.F.add(b[0], b[1])),\n                this.F.add(aA, bB))];\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);\n        const t1 = this.F.square(a[1]);\n        const t2 = this.F.sub(t0, this._mulByNonResidue(t1));\n        const t3 = this.F.inv(t2);\n        return [\n            this.F.mul(a[0], t3),\n            this.F.neg(this.F.mul( a[1], t3)) ];\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const ab = this.F.mul(a[0] , a[1]);\n\n        /*\n        [\n            (a + b) * (a + non_residue * b) - ab - non_residue * ab,\n            ab + ab\n        ];\n        */\n\n        return [\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]) ,\n                    this.F.add(\n                        a[0] ,\n                        this._mulByNonResidue(a[1]))),\n                this.F.add(\n                    ab,\n                    this._mulByNonResidue(ab))),\n            this.F.add(ab, ab)\n        ];\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        return [c0, c1];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        return false;\n    }\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBE(buff, o);\n        const c0 = this.F.fromRprBE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBEM(buff, o);\n        const c0 = this.F.fromRprBEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    toObject(a) {\n        return a;\n    }\n\n}\n\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\n\nexport default class F3Field {\n    constructor(F, nonResidue) {\n        this.type=\"F3\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*3;\n        this.p = F.p;\n        this.n64 = F.n64*3;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1]), this.F.copy(a[2])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1]),\n            this.F.add(a[2], b[2])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1]),\n            this.F.sub(a[2], b[2])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    mul(a, b) {\n\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n        const cC = this.F.mul(a[2] , b[2]);\n\n        return [\n            this.F.add(\n                aA,\n                this._mulByNonResidue(\n                    this.F.sub(\n                        this.F.mul(\n                            this.F.add(a[1], a[2]),\n                            this.F.add(b[1], b[2])),\n                        this.F.add(bB, cC)))),    // aA + non_residue*((b+c)*(B+C)-bB-cC),\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[1]),\n                        this.F.add(b[0], b[1])),\n                    this.F.add(aA, bB)),\n                this._mulByNonResidue( cC)),   // (a+b)*(A+B)-aA-bB+non_residue*cC\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[2]),\n                        this.F.add(b[0], b[2])),\n                    this.F.add(aA, cC)),\n                bB)];                           // (a+c)*(A+C)-aA+bB-cC)\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);             // t0 = a^2 ;\n        const t1 = this.F.square(a[1]);             // t1 = b^2 ;\n        const t2 = this.F.square(a[2]);             // t2 = c^2;\n        const t3 = this.F.mul(a[0],a[1]);           // t3 = ab\n        const t4 = this.F.mul(a[0],a[2]);           // t4 = ac\n        const t5 = this.F.mul(a[1],a[2]);           // t5 = bc;\n        // c0 = t0 - non_residue * t5;\n        const c0 = this.F.sub(t0, this._mulByNonResidue(t5));\n        // c1 = non_residue * t2 - t3;\n        const c1 = this.F.sub(this._mulByNonResidue(t2), t3);\n        const c2 = this.F.sub(t1, t4);              // c2 = t1-t4\n\n        // t6 = (a * c0 + non_residue * (c * c1 + b * c2)).inv();\n        const t6 =\n            this.F.inv(\n                this.F.add(\n                    this.F.mul(a[0], c0),\n                    this._mulByNonResidue(\n                        this.F.add(\n                            this.F.mul(a[2], c1),\n                            this.F.mul(a[1], c2)))));\n\n        return [\n            this.F.mul(t6, c0),         // t6*c0\n            this.F.mul(t6, c1),         // t6*c1\n            this.F.mul(t6, c2)];        // t6*c2\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const s0 = this.F.square(a[0]);                   // s0 = a^2\n        const ab = this.F.mul(a[0], a[1]);                // ab = a*b\n        const s1 = this.F.add(ab, ab);                    // s1 = 2ab;\n        const s2 = this.F.square(\n            this.F.add(this.F.sub(a[0],a[1]), a[2]));     // s2 = (a - b + c)^2;\n        const bc = this.F.mul(a[1],a[2]);                 // bc = b*c\n        const s3 = this.F.add(bc, bc);                    // s3 = 2*bc\n        const s4 = this.F.square(a[2]);                   // s4 = c^2\n\n\n        return [\n            this.F.add(\n                s0,\n                this._mulByNonResidue(s3)),           // s0 + non_residue * s3,\n            this.F.add(\n                s1,\n                this._mulByNonResidue(s4)),           // s1 + non_residue * s4,\n            this.F.sub(\n                this.F.add( this.F.add(s1, s2) , s3 ),\n                this.F.add(s0, s4))];                      // s1 + s2 + s3 - s0 - s4\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]) && this.F.isZero(a[2]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]) && this.F.eq(a[2], b[2]);\n    }\n\n    affine(a) {\n        return [this.F.affine(a[0]), this.F.affine(a[1]), this.F.affine(a[2])];\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])}, ${this.F.toString(a[2])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        return [c0, c1, c2];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        if (this.F.gt(b[1], a[1])) return false;\n        if (this.F.gt(a[2], b[2])) return true;\n        return false;\n    }\n\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n        this.F.toRprLE(buff, o+this.F.n8*2, e[2]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[2]);\n        this.F.toRprBE(buff, o+this.F.n8, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8*2, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprLEM(buff, o+this.F.n8*2, e[2]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[2]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8*2, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.n8);\n        const c2 = this.F.fromRprLE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBE(buff, o);\n        const c1 = this.F.fromRprBE(buff, o+this.n8);\n        const c0 = this.F.fromRprBE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.n8);\n        const c2 = this.F.fromRprLEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBEM(buff, o);\n        const c1 = this.F.fromRprBEM(buff, o+this.n8);\n        const c0 = this.F.fromRprBEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n", "/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nimport * as fUtils from \"./futils.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction isGreatest(F, a) {\n    if (Array.isArray(a)) {\n        for (let i=a.length-1; i>=0; i--) {\n            if (!F.F.isZero(a[i])) {\n                return isGreatest(F.F, a[i]);\n            }\n        }\n        return 0;\n    } else {\n        const na = F.neg(a);\n        return Scalar.gt(a, na);\n    }\n}\n\n\nexport default class EC {\n\n    constructor(F, g) {\n        this.F = F;\n        this.g = g;\n        if (this.g.length == 2) this.g[2] = this.F.one;\n        this.zero = [this.F.zero, this.F.one, this.F.zero];\n    }\n\n    add(p1, p2) {\n\n        const F = this.F;\n\n        if (this.eq(p1, this.zero)) return p2;\n        if (this.eq(p2, this.zero)) return p1;\n\n        const res = new Array(3);\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );     // U1 = X1  * Z2Z2\n        const U2 = F.mul( p2[0] , Z1Z1 );     // U2 = X2  * Z1Z1\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);  // S1 = Y1 * Z2 * Z2Z2\n        const S2 = F.mul( p2[1] , Z1_cubed);  // S2 = Y2 * Z1 * Z1Z1\n\n        if (F.eq(U1,U2) && F.eq(S1,S2)) {\n            return this.double(p1);\n        }\n\n        const H = F.sub( U2 , U1 );                    // H = U2-U1\n\n        const S2_minus_S1 = F.sub( S2 , S1 );\n\n        const I = F.square( F.add(H,H) );         // I = (2 * H)^2\n        const J = F.mul( H , I );                      // J = H * I\n\n        const r = F.add( S2_minus_S1 , S2_minus_S1 );  // r = 2 * (S2-S1)\n        const V = F.mul( U1 , I );                     // V = U1 * I\n\n        res[0] =\n            F.sub(\n                F.sub( F.square(r) , J ),\n                F.add( V , V ));                       // X3 = r^2 - J - 2 * V\n\n        const S1_J = F.mul( S1 , J );\n\n        res[1] =\n            F.sub(\n                F.mul( r , F.sub(V,res[0])),\n                F.add( S1_J,S1_J ));                   // Y3 = r * (V-X3)-2 S1 J\n\n        res[2] =\n            F.mul(\n                H,\n                F.sub(\n                    F.square( F.add(p1[2],p2[2]) ),\n                    F.add( Z1Z1 , Z2Z2 )));            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2) * H\n\n        return res;\n    }\n\n    neg(p) {\n        return [p[0], this.F.neg(p[1]), p[2]];\n    }\n\n    sub(a, b) {\n        return this.add(a, this.neg(b));\n    }\n\n    double(p) {\n        const F = this.F;\n\n        const res = new Array(3);\n\n        if (this.eq(p, this.zero)) return p;\n\n        const A = F.square( p[0] );                    // A = X1^2\n        const B = F.square( p[1] );                    // B = Y1^2\n        const C = F.square( B );                       // C = B^2\n\n        let D =\n            F.sub(\n                F.square( F.add(p[0] , B )),\n                F.add( A , C));\n        D = F.add(D,D);                    // D = 2 * ((X1 + B)^2 - A - C)\n\n        const E = F.add( F.add(A,A), A);          // E = 3 * A\n        const FF =F.square( E );                       // F = E^2\n\n        res[0] = F.sub( FF , F.add(D,D) );         // X3 = F - 2 D\n\n        let eightC = F.add( C , C );\n        eightC = F.add( eightC , eightC );\n        eightC = F.add( eightC , eightC );\n\n        res[1] =\n            F.sub(\n                F.mul(\n                    E,\n                    F.sub( D, res[0] )),\n                eightC);                                    // Y3 = E * (D - X3) - 8 * C\n\n        const Y1Z1 = F.mul( p[1] , p[2] );\n        res[2] = F.add( Y1Z1 , Y1Z1 );                 // Z3 = 2 * Y1 * Z1\n\n        return res;\n    }\n\n    timesScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    affine(p) {\n        const F = this.F;\n        if (this.isZero(p)) {\n            return this.zero;\n        } else if (F.eq(p[2], F.one)) {\n            return p;\n        } else {\n            const Z_inv = F.inv(p[2]);\n            const Z2_inv = F.square(Z_inv);\n            const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n            const res = new Array(3);\n            res[0] = F.mul(p[0],Z2_inv);\n            res[1] = F.mul(p[1],Z3_inv);\n            res[2] = F.one;\n\n            return res;\n        }\n    }\n\n    multiAffine(arr) {\n        const keys = Object.keys(arr);\n        const F = this.F;\n        const accMul = new Array(keys.length+1);\n        accMul[0] = F.one;\n        for (let i = 0; i< keys.length; i++) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i+1] = accMul[i];\n            } else {\n                accMul[i+1] = F.mul(accMul[i], arr[keys[i]][2]);\n            }\n        }\n\n        accMul[keys.length] = F.inv(accMul[keys.length]);\n\n        for (let i = keys.length-1; i>=0; i--) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i] = accMul[i+1];\n                arr[keys[i]] = this.zero;\n            } else {\n                const Z_inv = F.mul(accMul[i], accMul[i+1]);\n                accMul[i] = F.mul(arr[keys[i]][2], accMul[i+1]);\n\n                const Z2_inv = F.square(Z_inv);\n                const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n                arr[keys[i]][0] = F.mul(arr[keys[i]][0],Z2_inv);\n                arr[keys[i]][1] = F.mul(arr[keys[i]][1],Z3_inv);\n                arr[keys[i]][2] = F.one;\n            }\n        }\n\n    }\n\n    eq(p1, p2) {\n        const F = this.F;\n\n        if (this.F.eq(p1[2], this.F.zero)) return this.F.eq(p2[2], this.F.zero);\n        if (this.F.eq(p2[2], this.F.zero)) return false;\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );\n        const U2 = F.mul( p2[0] , Z1Z1 );\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);\n        const S2 = F.mul( p2[1] , Z1_cubed);\n\n        return (F.eq(U1,U2) && F.eq(S1,S2));\n    }\n\n    isZero(p) {\n        return this.F.isZero(p[2]);\n    }\n\n    toString(p) {\n        const cp = this.affine(p);\n        return `[ ${this.F.toString(cp[0])} , ${this.F.toString(cp[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n            P[1] = F.sqrt(x3b);\n        } while ((P[1] == null)||(F.isZero[P]));\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        if (this.cofactor) {\n            P = this.mulScalar(P, this.cofactor);\n        }\n\n        P = this.affine(P);\n\n        return P;\n\n    }\n\n    toRprLE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLE(buff, o, p[0]);\n        this.F.toRprLE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprBE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n        this.F.toRprBE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEJM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n        this.F.toRprLEM(buff, o+2*this.F.n8, p[2]);\n    }\n\n\n    toRprBEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBEM(buff, o, p[0]);\n        this.F.toRprBEM(buff, o+this.F.n8, p[1]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLE(buff, o);\n        const y = this.F.fromRprLE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBE(buff, o);\n        const y = this.F.fromRprBE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEJM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        const z = this.F.fromRprLEM(buff, o+this.F.n8*2);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, z];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBEM(buff, o);\n        const y = this.F.fromRprBEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprCompressed(buff, o) {\n        const F = this.F;\n        const v = new Uint8Array(buff.buffer, o, F.n8);\n        if (v[0] & 0x40) return this.zero;\n        const P = new Array(3);\n\n        const greatest = ((v[0] & 0x80) != 0);\n        v[0] = v[0] & 0x7F;\n        P[0] = F.fromRprBE(buff, o);\n        if (greatest) v[0] = v[0] | 0x80;  // set back again the old value\n\n        const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        P[1] = F.sqrt(x3b);\n\n        if (P[1] === null) {\n            throw new Error(\"Invalid Point!\");\n        }\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        return P;\n    }\n\n    toRprCompressed(buff, o, p) {\n        p = this.affine(p);\n        const v = new Uint8Array(buff.buffer, o, this.F.n8);\n        if (this.isZero(p)) {\n            v.fill(0);\n            v[0] = 0x40;\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n\n        if (isGreatest(this.F, p[1])) {\n            v[0] = v[0] | 0x80;\n        }\n    }\n\n\n    fromRprUncompressed(buff, o) {\n        if (buff[0] & 0x40) return this.zero;\n\n        return this.fromRprBE(buff, o);\n    }\n\n    toRprUncompressed(buff, o, p) {\n        this.toRprBE(buff, o, p);\n\n        if (this.isZero(p)) {\n            buff[o] = buff[o] | 0x40;\n        }\n    }\n\n\n}\n\n\n", "import { buildBn128 as buildBn128wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bn128 = null;\n\nexport default async function buildBn128(singleThread, plugins) {\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBn128wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bn128wasm = {};\n\n    bn128wasm.code = moduleBuilder.build();\n    bn128wasm.pq = moduleBuilder.modules.f1m.pq;\n    bn128wasm.pr = moduleBuilder.modules.frm.pq;\n    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;\n    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;\n    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;\n    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;\n    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;\n    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;\n    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;\n    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;\n    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;\n    bn128wasm.n8q = 32;\n    bn128wasm.n8r = 32;\n    bn128wasm.q = moduleBuilder.modules.bn128.q;\n    bn128wasm.r = moduleBuilder.modules.bn128.r;\n\n    if ((!singleThread) && (globalThis.curve_bn128)) return globalThis.curve_bn128;\n    const params = {\n        name: \"bn128\",\n        wasm: bn128wasm,\n        q: Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\"),\n        r: Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\"),\n        n8q: 32,\n        n8r: 32,\n        cofactorG2: Scalar.e(\"30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bn128 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bn128 = curve;\n    }\n\n    return curve;\n}\n\n", "import WasmField1 from \"./wasm_field1.js\";\nimport WasmField2 from \"./wasm_field2.js\";\nimport WasmField3 from \"./wasm_field3.js\";\nimport WasmCurve from \"./wasm_curve.js\";\nimport buildThreadManager from \"./threadman.js\";\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchApplyKey from \"./engine_applykey.js\";\nimport buildPairing from \"./engine_pairing.js\";\nimport buildMultiExp from \"./engine_multiexp.js\";\nimport buildFFT from \"./engine_fft.js\";\n\nexport default async function buildEngine(params) {\n\n    const tm = await buildThreadManager(params.wasm, params.singleThread);\n\n\n    const curve = {};\n\n    curve.q = Scalar.e(params.wasm.q.toString());\n    curve.r = Scalar.e(params.wasm.r.toString());\n    curve.name = params.name;\n    curve.tm = tm;\n    curve.prePSize = params.wasm.prePSize;\n    curve.preQSize = params.wasm.preQSize;\n    curve.Fr = new WasmField1(tm, \"frm\", params.n8r, params.r);\n    curve.F1 = new WasmField1(tm, \"f1m\", params.n8q, params.q);\n    curve.F2 = new WasmField2(tm, \"f2m\", curve.F1);\n    curve.G1 = new WasmCurve(tm, \"g1m\", curve.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);\n    curve.G2 = new WasmCurve(tm, \"g2m\", curve.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);\n    curve.F6 = new WasmField3(tm, \"f6m\", curve.F2);\n    curve.F12 = new WasmField2(tm, \"ftm\", curve.F6);\n\n    curve.Gt = curve.F12;\n\n    buildBatchApplyKey(curve, \"G1\");\n    buildBatchApplyKey(curve, \"G2\");\n    buildBatchApplyKey(curve, \"Fr\");\n\n    buildMultiExp(curve, \"G1\");\n    buildMultiExp(curve, \"G2\");\n\n    buildFFT(curve, \"G1\");\n    buildFFT(curve, \"G2\");\n    buildFFT(curve, \"Fr\");\n\n    buildPairing(curve);\n\n    curve.array2buffer = function(arr, sG) {\n        const buff = new Uint8Array(sG*arr.length);\n\n        for (let i=0; i<arr.length; i++) {\n            buff.set(arr[i], i*sG);\n        }\n\n        return buff;\n    };\n\n    curve.buffer2array = function(buff , sG) {\n        const n= buff.byteLength / sG;\n        const arr = new Array(n);\n        for (let i=0; i<n; i++) {\n            arr[i] = buff.slice(i*sG, i*sG+sG);\n        }\n        return arr;\n    };\n\n    return curve;\n}\n\n\n", "import * as Scalar from \"./scalar.js\";\nimport * as utils from \"./utils.js\";\nimport { getThreadRng } from \"./random.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default class WasmField1 {\n\n    constructor(tm, prefix, n8, p) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.p = p;\n        this.n8 = n8;\n        this.type = \"F1\";\n        this.m = 1;\n\n        this.half = Scalar.shiftRight(p, Scalar.one);\n        this.bitLength = Scalar.bitLength(p);\n        this.mask = Scalar.sub(Scalar.shiftLeft(Scalar.one, this.bitLength), Scalar.one);\n\n        this.pOp1 = tm.alloc(n8);\n        this.pOp2 = tm.alloc(n8);\n        this.pOp3 = tm.alloc(n8);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = this.tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.n64 = Math.floor(n8/8);\n        this.n32 = Math.floor(n8/4);\n\n        if(this.n64*8 != this.n8) {\n            throw new Error(\"n8 must be a multiple of 8\");\n        }\n\n        this.half = Scalar.shiftRight(this.p, Scalar.one);\n        this.nqr = this.two;\n        let r = this.exp(this.nqr, this.half);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.add(this.nqr, this.one);\n            r = this.exp(this.nqr, this.half);\n        }\n\n        this.shift = this.mul(this.nqr, this.nqr);\n        this.shiftInv = this.inv(this.shift);\n\n        this.s = 0;\n        let t = Scalar.sub(this.p, Scalar.one);\n\n        while ( !Scalar.isOdd(t) ) {\n            this.s = this.s + 1;\n            t = Scalar.shiftRight(t, Scalar.one);\n        }\n\n        this.w = [];\n        this.w[this.s] = this.exp(this.nqr, t);\n\n        for (let i= this.s-1; i>=0; i--) {\n            this.w[i] = this.square(this.w[i+1]);\n        }\n\n        if (!this.eq(this.w[0], this.one)) {\n            throw new Error(\"Error calculating roots of unity\");\n        }\n\n        this.batchToMontgomery = buildBatchConvert(tm, prefix + \"_batchToMontgomery\", this.n8, this.n8);\n        this.batchFromMontgomery = buildBatchConvert(tm, prefix + \"_batchFromMontgomery\", this.n8, this.n8);\n    }\n\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        let ra = Scalar.e(a, b);\n        if (Scalar.isNegative(ra)) {\n            ra = Scalar.neg(ra);\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n            ra = Scalar.sub(this.p, ra);\n        } else {\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n        }\n        const buff = utils.leInt2Buff(ra, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toString(a, radix) {\n        const an = this.fromMontgomery(a);\n        const s = Scalar.fromRprLE(an, 0);\n        return Scalar.toString(s, radix);\n    }\n\n    fromRng(rng) {\n        let v;\n        const buff = new Uint8Array(this.n8);\n        do {\n            v = Scalar.zero;\n            for (let i=0; i<this.n64; i++) {\n                v = Scalar.add(v,  Scalar.shiftLeft(rng.nextU64(), 64*i));\n            }\n            v = Scalar.band(v, this.mask);\n        } while (Scalar.geq(v, this.p));\n        Scalar.toRprLE(buff, 0, v, this.n8);\n        return buff;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const an = this.fromMontgomery(a);\n        return Scalar.fromRprLE(an, 0);\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.n8);\n        Scalar.toRprLE(buff, 0, a, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toRprLE(buff, offset, a) {\n        buff.set(this.fromMontgomery(a), offset);\n    }\n\n    toRprBE(buff, offset, a) {\n        const buff2 = this.fromMontgomery(a);\n        for (let i=0; i<this.n8/2; i++) {\n            const aux = buff2[i];\n            buff2[i] = buff2[this.n8-1-i];\n            buff2[this.n8-1-i] = aux;\n        }\n        buff.set(buff2, offset);\n    }\n\n    fromRprLE(buff, offset) {\n        offset = offset || 0;\n        const res = buff.slice(offset, offset + this.n8);\n        return this.toMontgomery(res);\n    }\n\n    async batchInverse(buffIn) {\n        let returnArray = false;\n        const sIn = this.n8;\n        const sOut = this.n8;\n\n        if (Array.isArray(buffIn)) {\n            buffIn = utils.array2buffer(buffIn, sIn );\n            returnArray = true;\n        } else {\n            buffIn = buffIn.slice(0, buffIn.byteLength);\n        }\n\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/this.tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<this.tm.concurrency; i++) {\n            let n;\n            if (i< this.tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: this.prefix + \"_batchInverse\", params: [\n                    {var: 0},\n                    {val: sIn},\n                    {val: n},\n                    {var: 1},\n                    {val: sOut},\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                this.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        if (returnArray) {\n            return utils.buffer2array(fullBuffOut, sOut);\n        } else {\n            return fullBuffOut;\n        }\n\n    }\n\n}\n\n\n", "/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\n\nexport function stringifyBigInts(o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return Scalar.fromRprLE(o, 0);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigInts);\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyBigInts(o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return BigInt(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return BigInt(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyBigInts);\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function beBuff2int(buff) {\n    let res = BigInt(0);\n    let i = buff.length;\n    let offset = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i > 0) {\n        if (i >= 4) {\n            i -= 4;\n            res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);\n            offset += 4;\n        } else if (i >= 2) {\n            i -= 2;\n            res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);\n            offset += 2;\n        } else {\n            i -= 1;\n            res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);\n            offset += 1;\n        }\n    }\n    return res;\n}\n\nexport function beInt2Buff(n, len) {\n    let r = n;\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = len;\n    while (o > 0) {\n        if (o - 4 >= 0) {\n            o -= 4;\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)));\n            r = r >> BigInt(32);\n        } else if (o - 2 >= 0) {\n            o -= 2;\n            buffV.setUint16(o, Number(r & BigInt(0xffff)));\n            r = r >> BigInt(16);\n        } else {\n            o -= 1;\n            buffV.setUint8(o, Number(r & BigInt(0xff)));\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function leBuff2int(buff) {\n    let res = BigInt(0);\n    let i = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i < buff.length) {\n        if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);\n            i += 4;\n        } else if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);\n            i += 2;\n        } else {\n            res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);\n            i += 1;\n        }\n    }\n    return res;\n}\n\nexport function leInt2Buff(n, len) {\n    let r = n;\n    if (typeof len === \"undefined\") {\n        len = Math.floor((Scalar.bitLength(n) - 1) / 8) + 1;\n        if (len == 0) len = 1;\n    }\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = 0;\n    while (o < len) {\n        if (o + 4 <= len) {\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)), true);\n            o += 4;\n            r = r >> BigInt(32);\n        } else if (o + 2 <= len) {\n            buffV.setUint16(Number(o, r & BigInt(0xffff)), true);\n            o += 2;\n            r = r >> BigInt(16);\n        } else {\n            buffV.setUint8(Number(o, r & BigInt(0xff)), true);\n            o += 1;\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function stringifyFElements(F, o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return F.toString(F.e(o));\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyFElements(F, o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return F.e(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return F.e(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nconst _revTable = [];\nfor (let i = 0; i < 256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res = 0;\n    let a = idx;\n    for (let i = 0; i < bits; i++) {\n        res <<= 1;\n        res = res | (a & 1);\n        a >>= 1;\n    }\n    return res;\n}\n\nexport function bitReverse(idx, bits) {\n    return (\n        (_revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xff] << 8) |\n        (_revTable[(idx >>> 8) & 0xff] << 16) |\n        (_revTable[idx & 0xff] << 24)) >>>\n        (32 - bits)\n    );\n}\n\nexport function log2(V) {\n    return (\n        ((V & 0xffff0000) !== 0 ? ((V &= 0xffff0000), 16) : 0) |\n        ((V & 0xff00ff00) !== 0 ? ((V &= 0xff00ff00), 8) : 0) |\n        ((V & 0xf0f0f0f0) !== 0 ? ((V &= 0xf0f0f0f0), 4) : 0) |\n        ((V & 0xcccccccc) !== 0 ? ((V &= 0xcccccccc), 2) : 0) |\n        ((V & 0xaaaaaaaa) !== 0)\n    );\n}\n\nexport function buffReverseBits(buff, eSize) {\n    const n = buff.byteLength / eSize;\n    const bits = log2(n);\n    if (n != 1 << bits) {\n        throw new Error(\"Invalid number of pointers\");\n    }\n    for (let i = 0; i < n; i++) {\n        const r = bitReverse(i, bits);\n        if (i > r) {\n            const tmp = buff.slice(i * eSize, (i + 1) * eSize);\n            buff.set(buff.slice(r * eSize, (r + 1) * eSize), i * eSize);\n            buff.set(tmp, r * eSize);\n        }\n    }\n}\n\nexport function array2buffer(arr, sG) {\n    const buff = new Uint8Array(sG * arr.length);\n\n    for (let i = 0; i < arr.length; i++) {\n        buff.set(arr[i], i * sG);\n    }\n\n    return buff;\n}\n\nexport function buffer2array(buff, sG) {\n    const n = buff.byteLength / sG;\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = buff.slice(i * sG, i * sG + sG);\n    }\n    return arr;\n}\n", "import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchConvert(tm, fnName, sIn, sOut) {\n    return async function batchConvert(buffIn) {\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1}\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n", "\nconst PAGE_SIZE = 1<<30;\n\nexport default class BigBuffer {\n\n    constructor(size) {\n        this.buffers = [];\n        this.byteLength = size;\n        for (let i=0; i<size; i+= PAGE_SIZE) {\n            const n = Math.min(size-i, PAGE_SIZE);\n            this.buffers.push(new Uint8Array(n));\n        }\n\n    }\n\n    slice(fr, to) {\n        if ( to === undefined ) to = this.byteLength;\n        if ( fr === undefined ) fr = 0;\n        const len = to-fr;\n\n        const firstPage = Math.floor(fr / PAGE_SIZE);\n        const lastPage = Math.floor((fr+len-1) / PAGE_SIZE);\n\n        if ((firstPage == lastPage)||(len==0))\n            return this.buffers[firstPage].slice(fr%PAGE_SIZE, fr%PAGE_SIZE + len);\n\n        let buff;\n\n        let p = firstPage;\n        let o = fr % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset+o, l);\n            if (l == len) return srcView.slice();\n            if (!buff) {\n                if (len <= PAGE_SIZE) {\n                    buff = new Uint8Array(len);\n                } else {\n                    buff = new BigBuffer(len);\n                }\n            }\n            buff.set(srcView, len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        return buff;\n    }\n\n    set(buff, offset) {\n        if (offset === undefined) offset = 0;\n\n        const len = buff.byteLength;\n\n        if (len==0) return;\n\n        const firstPage = Math.floor(offset / PAGE_SIZE);\n        const lastPage = Math.floor((offset+len-1) / PAGE_SIZE);\n\n        if (firstPage == lastPage) {\n            if ((buff instanceof BigBuffer)&&(buff.buffers.length==1)) {\n                return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);\n            } else {\n                return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);\n            }\n\n        }\n\n\n        let p = firstPage;\n        let o = offset % PAGE_SIZE;\n        let r = len;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice( len -r, len -r+l);\n            const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n    }\n}\n", "import { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField2 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F2\";\n        this.m = F.m * 2;\n        this.n8 = this.F.n8*2;\n        this.n32 = this.F.n32*2;\n        this.n64 = this.F.n64*2;\n\n        this.pOp1 = tm.alloc(F.n8*2);\n        this.pOp2 = tm.alloc(F.n8*2);\n        this.pOp3 = tm.alloc(F.n8*2);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    mul1(a,b) {\n        return this.op2(\"_mul1\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 2)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const res = new Uint8Array(this.F.n8*2);\n            res.set(c1);\n            res.set(c2, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F2\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8), radix);\n        return `[${s1}, ${s2}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*2);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        return [c1, c2];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8);\n    }\n\n}\n\n", "\n\nimport { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField3 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F3\";\n        this.m = F.m * 3;\n        this.n8 = this.F.n8*3;\n        this.n32 = this.F.n32*3;\n        this.n64 = this.F.n64*3;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 3)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const c3 = this.F.e(a[2], b);\n            const res = new Uint8Array(this.F.n8*3);\n            res.set(c1);\n            res.set(c2, this.F.n8);\n            res.set(c3, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F3\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n        const s3 = this.F.toString(a.slice(this.F.n8*2), radix);\n        return `[${s1}, ${s2}, ${s3}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const c3 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*3);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        res.set(c3, this.F.n8*2);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        const c3 = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        return [c1, c2, c3];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*3);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        const b3 = this.F.fromObject(a[2]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        buff.set(b3, this.F.n8*2);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8, this.F.n8*2);\n    }\n\n    c3(a) {\n        return a.slice(this.F.n8*2);\n    }\n\n}\n\n\n", "\n\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\n\nexport default class WasmCurve {\n\n    constructor(tm, prefix, F, pGen, pGb, cofactor) {\n        this.tm = tm;\n        this.prefix = prefix;\n        this.F = F;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, F.n8*3);\n        this.tm.instance.exports[prefix + \"_zeroAffine\"](this.pOp1);\n        this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8*2);\n        this.one = this.tm.getBuff(pGen, F.n8*3);\n        this.g = this.one;\n        this.oneAffine = this.tm.getBuff(pGen, F.n8*2);\n        this.gAffine = this.oneAffine;\n        this.b = this.tm.getBuff(pGb, F.n8);\n\n        if (cofactor) {\n            this.cofactor = Scalar.toLEBuff(cofactor);\n        }\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.batchLEMtoC = buildBatchConvert(tm, prefix + \"_batchLEMtoC\", F.n8*2, F.n8);\n        this.batchLEMtoU = buildBatchConvert(tm, prefix + \"_batchLEMtoU\", F.n8*2, F.n8*2);\n        this.batchCtoLEM = buildBatchConvert(tm, prefix + \"_batchCtoLEM\", F.n8, F.n8*2);\n        this.batchUtoLEM = buildBatchConvert(tm, prefix + \"_batchUtoLEM\", F.n8*2, F.n8*2);\n        this.batchToJacobian = buildBatchConvert(tm, prefix + \"_batchToJacobian\", F.n8*2, F.n8*3);\n        this.batchToAffine = buildBatchConvert(tm, prefix + \"_batchToAffine\", F.n8*3, F.n8*2);\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op2bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op1Affine(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*2);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_add\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_addMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    sub(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_sub\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_subMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    neg(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_neg\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Affine(\"_negAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    double(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_double\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_doubleAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isZero(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Bool(\"_isZero\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Bool(\"_isZeroAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    timesScalar(a, s) {\n        if (!(s instanceof Uint8Array)) {\n            s = Scalar.toLEBuff(Scalar.e(s));\n        }\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesScalar\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesScalarAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    timesFr(a, s) {\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesFr\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesFrAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    eq(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eq\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eqMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toAffine(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Affine(\"_toAffine\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return a;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toJacobian(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return a;\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_toJacobian\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toRprUncompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoU\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n        arr.set(res, offset);\n    }\n\n    fromRprUncompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8*2);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_UtoLEM\"](this.pOp1, this.pOp1);\n        return this.tm.getBuff(this.pOp1, this.F.n8*2);\n    }\n\n    toRprCompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoC\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8);\n        arr.set(res, offset);\n    }\n\n    fromRprCompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_CtoLEM\"](this.pOp1, this.pOp2);\n        return this.tm.getBuff(this.pOp2, this.F.n8*2);\n    }\n\n    toUncompressed(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        this.toRprUncompressed(buff, 0, a);\n        return buff;\n    }\n\n    toRprLEM(arr, offset, a) {\n        if (a.byteLength == this.F.n8*2) {\n            arr.set(a, offset);\n            return;\n        } else if (a.byteLength == this.F.n8*3) {\n            this.tm.setBuff(this.pOp1, a);\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n            const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n            arr.set(res, offset);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    fromRprLEM(arr, offset) {\n        offset = offset || 0;\n        return arr.slice(offset, offset+this.F.n8*2);\n    }\n\n    toString(a, radix) {\n        if (a.byteLength == this.F.n8*3) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n            const z = this.F.toString(a.slice(this.F.n8*2), radix);\n            return `[ ${x}, ${y}, ${z} ]`;\n        } else if (a.byteLength == this.F.n8*2) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8), radix);\n            return `[ ${x}, ${y} ]`;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isValid(a) {\n        if (this.isZero(a)) return true;\n        const F = this.F;\n        const aa = this.toAffine(a);\n        const x = aa.slice(0, this.F.n8);\n        const y = aa.slice(this.F.n8, this.F.n8*2);\n        const x3b = F.add(F.mul(F.square(x),x), this.b);\n        const y2 = F.square(y);\n        return F.eq(x3b, y2);\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        let x3b;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        } while (!F.isSquare(x3b));\n\n        P[1] = F.sqrt(x3b);\n\n        const s = F.isNegative(P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n\n        let Pbuff = new Uint8Array(this.F.n8*2);\n        Pbuff.set(P[0]);\n        Pbuff.set(P[1], this.F.n8);\n\n        if (this.cofactor) {\n            Pbuff = this.timesScalar(Pbuff, this.cofactor);\n        }\n\n        return Pbuff;\n    }\n\n\n\n    toObject(a) {\n        if (this.isZero(a)) {\n            return [\n                this.F.toObject(this.F.zero),\n                this.F.toObject(this.F.one),\n                this.F.toObject(this.F.zero),\n            ];\n        }\n        const x = this.F.toObject(a.slice(0, this.F.n8));\n        const y = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        let z;\n        if (a.byteLength == this.F.n8*3) {\n            z = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        } else {\n            z = this.F.toObject(this.F.one);\n        }\n        return [x, y, z];\n    }\n\n    fromObject(a) {\n        const x = this.F.fromObject(a[0]);\n        const y = this.F.fromObject(a[1]);\n        let z;\n        if (a.length==3) {\n            z = this.F.fromObject(a[2]);\n        } else {\n            z = this.F.one;\n        }\n        if (this.F.isZero(z, this.F.one)) {\n            return this.zeroAffine;\n        } else if (this.F.eq(z, this.F.one)) {\n            const buff = new Uint8Array(this.F.n8*2);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            return buff;\n        } else {\n            const buff = new Uint8Array(this.F.n8*3);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            buff.set(z, this.F.n8*2);\n            return buff;\n        }\n    }\n\n    e(a) {\n        if (a instanceof Uint8Array) return a;\n        return this.fromObject(a);\n    }\n\n    x(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(0, this.F.n8);\n    }\n\n    y(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(this.F.n8);\n    }\n\n}\n\n\n", "/* global navigator, WebAssembly */\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// const MEM_SIZE = 1000;  // Memory size in 64K Pakes (512Mb)\nconst MEM_SIZE = 25;  // Memory size in 64K Pakes (1600Kb)\n\n\nimport thread from \"./threadman_thread.js\";\nimport os from \"os\";\nimport Worker from \"web-worker\";\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject)=> {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction stringToBase64(str) {\n    if (process.browser) {\n        return globalThis.btoa(str);\n    } else {\n        return Buffer.from(str).toString(\"base64\");\n    }\n}\n\nconst threadSource = stringToBase64(\"(\" + thread.toString() + \")(self)\");\nconst workerSource = \"data:application/javascript;base64,\" + threadSource;\n\n\n\nexport default async function buildThreadManager(wasm, singleThread) {\n    const tm = new ThreadManager();\n\n    tm.memory = new WebAssembly.Memory({initial:MEM_SIZE});\n    tm.u8 = new Uint8Array(tm.memory.buffer);\n    tm.u32 = new Uint32Array(tm.memory.buffer);\n\n    const wasmModule = await WebAssembly.compile(wasm.code);\n\n    tm.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": tm.memory\n        }\n    });\n\n    tm.singleThread = singleThread;\n    tm.initalPFree = tm.u32[0];   // Save the Pointer to free space.\n    tm.pq = wasm.pq;\n    tm.pr = wasm.pr;\n    tm.pG1gen = wasm.pG1gen;\n    tm.pG1zero = wasm.pG1zero;\n    tm.pG2gen = wasm.pG2gen;\n    tm.pG2zero = wasm.pG2zero;\n    tm.pOneT = wasm.pOneT;\n\n    //    tm.pTmp0 = tm.alloc(curve.G2.F.n8*3);\n    //    tm.pTmp1 = tm.alloc(curve.G2.F.n8*3);\n\n\n    if (singleThread) {\n        tm.code = wasm.code;\n        tm.taskManager = thread();\n        await tm.taskManager([{\n            cmd: \"INIT\",\n            init: MEM_SIZE,\n            code: tm.code.slice()\n        }]);\n        tm.concurrency  = 1;\n    } else {\n        tm.workers = [];\n        tm.pendingDeferreds = [];\n        tm.working = [];\n\n        let concurrency;\n\n        if ((typeof(navigator) === \"object\") && navigator.hardwareConcurrency) {\n            concurrency = navigator.hardwareConcurrency;\n        } else {\n            concurrency = os.cpus().length;\n        }\n\n        if(concurrency == 0){\n            concurrency = 2;\n        }\n\n        // Limit to 64 threads for memory reasons.\n        if (concurrency>64) concurrency=64;\n        tm.concurrency = concurrency;\n\n        for (let i = 0; i<concurrency; i++) {\n\n            tm.workers[i] = new Worker(workerSource);\n\n            tm.workers[i].addEventListener(\"message\", getOnMsg(i));\n\n            tm.working[i]=false;\n        }\n\n        const initPromises = [];\n        for (let i=0; i<tm.workers.length;i++) {\n            const copyCode = wasm.code.slice();\n            initPromises.push(tm.postAction(i, [{\n                cmd: \"INIT\",\n                init: MEM_SIZE,\n                code: copyCode\n            }], [copyCode.buffer]));\n        }\n\n        await Promise.all(initPromises);\n\n    }\n    return tm;\n\n    function getOnMsg(i) {\n        return function(e) {\n            let data;\n            if ((e)&&(e.data)) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            tm.working[i]=false;\n            tm.pendingDeferreds[i].resolve(data);\n            tm.processWorks();\n        };\n    }\n\n}\n\nclass ThreadManager {\n    constructor() {\n        this.actionQueue = [];\n        this.oldPFree = 0;\n    }\n\n    startSyncOp() {\n        if (this.oldPFree != 0) throw new Error(\"Sync operation in progress\");\n        this.oldPFree = this.u32[0];\n    }\n\n    endSyncOp() {\n        if (this.oldPFree == 0) throw new Error(\"No sync operation in progress\");\n        this.u32[0] = this.oldPFree;\n        this.oldPFree = 0;\n    }\n\n    postAction(workerId, e, transfers, _deferred) {\n        if (this.working[workerId]) {\n            throw new Error(\"Posting a job t a working worker\");\n        }\n        this.working[workerId] = true;\n\n        this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();\n        this.workers[workerId].postMessage(e, transfers);\n\n        return this.pendingDeferreds[workerId].promise;\n    }\n\n    processWorks() {\n        for (let i=0; (i<this.workers.length)&&(this.actionQueue.length > 0); i++) {\n            if (this.working[i] == false) {\n                const work = this.actionQueue.shift();\n                this.postAction(i, work.data, work.transfers, work.deferred);\n            }\n        }\n    }\n\n    queueAction(actionData, transfers) {\n        const d = new Deferred();\n\n        if (this.singleThread) {\n            const res = this.taskManager(actionData);\n            d.resolve(res);\n        } else {\n            this.actionQueue.push({\n                data: actionData,\n                transfers: transfers,\n                deferred: d\n            });\n            this.processWorks();\n        }\n        return d.promise;\n    }\n\n    resetMemory() {\n        this.u32[0] = this.initalPFree;\n    }\n\n    allocBuff(buff) {\n        const pointer = this.alloc(buff.byteLength);\n        this.setBuff(pointer, buff);\n        return pointer;\n    }\n\n    getBuff(pointer, length) {\n        return this.u8.slice(pointer, pointer+ length);\n    }\n\n    setBuff(pointer, buffer) {\n        this.u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    alloc(length) {\n        while (this.u32[0] & 3) this.u32[0]++;  // Return always aligned pointers\n        const res = this.u32[0];\n        this.u32[0] += length;\n        return res;\n    }\n\n    async terminate() {\n        for (let i=0; i<this.workers.length; i++) {\n            this.workers[i].postMessage([{cmd: \"TERMINATE\"}]);\n        }\n        await sleep(200);\n    }\n\n}\n", "/* global WebAssembly */\n\nexport default function thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == \"INIT\") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == \"TERMINATE\") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == \"INIT\") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case \"ALLOCSET\":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case \"ALLOC\":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case \"SET\":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case \"CALL\": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== \"undefined\") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != \"undefined\") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case \"GET\":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error(\"Invalid cmd\");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}\n", "import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchApplyKey(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = curve.tm;\n\n    curve[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        let fnName, fnAffine;\n        let sGin, sGmid, sGout;\n        if (groupName == \"G1\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g1m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g1m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g1m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g2m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g2m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g2m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_batchApplyKey\";\n            sGin = G.n8;\n            sGmid = G.n8;\n            sGout = G.n8;\n        } else {\n            throw new Error(\"Invalid group: \" + groupName);\n        }\n        const nPoints = Math.floor(buff.byteLength / sGin);\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        inc = Fr.e(inc);\n        let t = Fr.e(first);\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({\n                cmd: \"ALLOCSET\",\n                var: 0,\n                buff: buff.slice(i*pointsPerChunk*sGin, i*pointsPerChunk*sGin + n*sGin)\n            });\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: t});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: inc});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*Math.max(sGmid, sGout)});\n            task.push({\n                cmd: \"CALL\",\n                fnName: fnName,\n                params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1},\n                    {var: 2},\n                    {var:3}\n                ]\n            });\n            if (fnAffine) {\n                task.push({\n                    cmd: \"CALL\",\n                    fnName: fnAffine,\n                    params: [\n                        {var: 3},\n                        {val: n},\n                        {var: 3},\n                    ]\n                });\n            }\n            task.push({cmd: \"GET\", out: 0, var: 3, len: n*sGout});\n\n            opPromises.push(tm.queueAction(task));\n            t = Fr.mul(t, Fr.exp(inc, n));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let outBuff;\n        if (buff instanceof BigBuffer) {\n            outBuff = new BigBuffer(nPoints*sGout);\n        } else {\n            outBuff = new Uint8Array(nPoints*sGout);\n        }\n\n        let p=0;\n        for (let i=0; i<result.length; i++) {\n            outBuff.set(result[i][0], p);\n            p += result[i][0].byteLength;\n        }\n\n        return outBuff;\n    };\n}\n", "\nexport default function buildPairing(curve) {\n    const tm = curve.tm;\n    curve.pairing = function pairing(a, b) {\n\n        tm.startSyncOp();\n        const pA = tm.allocBuff(curve.G1.toJacobian(a));\n        const pB = tm.allocBuff(curve.G2.toJacobian(b));\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports[curve.name + \"_pairing\"](pA, pB, pRes);\n\n        const res = tm.getBuff(pRes, curve.Gt.n8);\n\n        tm.endSyncOp();\n        return res;\n    };\n\n    curve.pairingEq = async function pairingEq() {\n        let  buffCt;\n        let nEqs;\n        if ((arguments.length % 2) == 1) {\n            buffCt = arguments[arguments.length-1];\n            nEqs = (arguments.length -1) /2;\n        } else {\n            buffCt = curve.Gt.one;\n            nEqs = arguments.length /2;\n        }\n\n        const opPromises = [];\n        for (let i=0; i<nEqs; i++) {\n\n            const task = [];\n\n            const g1Buff = curve.G1.toJacobian(arguments[i*2]);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: g1Buff});\n            task.push({cmd: \"ALLOC\", var: 1, len: curve.prePSize});\n\n            const g2Buff = curve.G2.toJacobian(arguments[i*2 +1]);\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: g2Buff});\n            task.push({cmd: \"ALLOC\", var: 3, len: curve.preQSize});\n\n            task.push({cmd: \"ALLOC\", var: 4, len: curve.Gt.n8});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG1\", params: [\n                {var: 0},\n                {var: 1}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG2\", params: [\n                {var: 2},\n                {var: 3}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_millerLoop\", params: [\n                {var: 1},\n                {var: 3},\n                {var: 4}\n            ]});\n\n            task.push({cmd: \"GET\", out: 0, var: 4, len: curve.Gt.n8});\n\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        tm.startSyncOp();\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports.ftm_one(pRes);\n\n        for (let i=0; i<result.length; i++) {\n            const pMR = tm.allocBuff(result[i][0]);\n            tm.instance.exports.ftm_mul(pRes, pMR, pRes);\n        }\n        tm.instance.exports[curve.name + \"_finalExponentiation\"](pRes, pRes);\n\n        const pCt = tm.allocBuff(buffCt);\n\n        const r = !!tm.instance.exports.ftm_eq(pRes, pCt);\n\n        tm.endSyncOp();\n\n        return r;\n    };\n\n    curve.prepareG1 = function(p) {\n        this.tm.startSyncOp();\n        const pP = this.tm.allocBuff(p);\n        const pPrepP = this.tm.alloc(this.prePSize);\n        this.tm.instance.exports[this.name + \"_prepareG1\"](pP, pPrepP);\n        const res = this.tm.getBuff(pPrepP, this.prePSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.prepareG2 = function(q) {\n        this.tm.startSyncOp();\n        const pQ = this.tm.allocBuff(q);\n        const pPrepQ = this.tm.alloc(this.preQSize);\n        this.tm.instance.exports[this.name + \"_prepareG2\"](pQ, pPrepQ);\n        const res = this.tm.getBuff(pPrepQ, this.preQSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.millerLoop = function(preP, preQ) {\n        this.tm.startSyncOp();\n        const pPreP = this.tm.allocBuff(preP);\n        const pPreQ = this.tm.allocBuff(preQ);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_millerLoop\"](pPreP, pPreQ, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.finalExponentiation = function(a) {\n        this.tm.startSyncOp();\n        const pA = this.tm.allocBuff(a);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_finalExponentiation\"](pA, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n}\n", "import { log2 } from \"./utils.js\";\n\nconst pTSizes = [\n    1 ,  1,  1,  1,    2,  3,  4,  5,\n    6 ,  7,  7,  8,    9, 10, 11, 12,\n    13, 13, 14, 15,   16, 16, 17, 17,\n    17, 17, 17, 17,   17, 17, 17, 17\n];\n\nexport default function buildMultiexp(curve, groupName) {\n    const G = curve[groupName];\n    const tm = G.tm;\n    async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {\n        if ( ! (buffBases instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n        }\n        if ( ! (buffScalars instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n        }\n        inType = inType || \"affine\";\n\n        let sGIn;\n        let fnName;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                fnName = \"g1m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g1m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                fnName = \"g2m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g2m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff: buffBases},\n                {cmd: \"ALLOCSET\", var: 1, buff: buffScalars},\n                {cmd: \"ALLOC\", var: 2, len: G.F.n8*3},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {var: 1},\n                    {val: sScalar},\n                    {val: nPoints},\n                    {val: i*bitChunkSize},\n                    {val: Math.min(sScalar*8 - i*bitChunkSize, bitChunkSize)},\n                    {var: 2}\n                ]},\n                {cmd: \"GET\", out: 0, var: 2, len: G.F.n8*3}\n            ];\n            opPromises.push(\n                G.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            if (!G.isZero(res)) {\n                for (let j=0; j<bitChunkSize; j++) res = G.double(res);\n            }\n            res = G.add(res, result[i][0]);\n        }\n\n        return res;\n    }\n\n    async function _multiExp(buffBases, buffScalars, inType, logger, logText) {\n        const MAX_CHUNK_SIZE = 1 << 22;\n        const MIN_CHUNK_SIZE = 1 << 10;\n        let sGIn;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        let chunkSize;\n        chunkSize = Math.floor(nPoints / (tm.concurrency /nChunks));\n        if (chunkSize>MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n        if (chunkSize<MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n\n        const opPromises = [];\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n            const buffBasesChunk = buffBases.slice(i*sGIn, (i+n)*sGIn);\n            const buffScalarsChunk = buffScalars.slice(i*sScalar, (i+n)*sScalar);\n            opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then( (r) => {\n                if (logger) logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);\n                return r;\n            }));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            res = G.add(res, result[i]);\n        }\n\n        return res;\n    }\n\n    G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"jacobian\", logger, logText);\n    };\n    G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"affine\", logger, logText);\n    };\n}\n", "import {log2, buffReverseBits, array2buffer, buffer2array} from \"./utils.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default function buildFFT(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = G.tm;\n    async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {\n\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        const MAX_BITS_THREAD = 14;\n\n        let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g1m_fftFinal\";\n            }\n            fnFFTJoin = \"g1m_fftJoin\";\n            fnFFTMix = \"g1m_fftMix\";\n\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g1m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g2m_fftFinal\";\n            }\n            fnFFTJoin = \"g2m_fftJoin\";\n            fnFFTMix = \"g2m_fftMix\";\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g2m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = G.n8;\n            sMid = G.n8;\n            sOut = G.n8;\n            if (inverse) {\n                fnFFTFinal = \"frm_fftFinal\";\n            }\n            fnFFTMix = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        }\n\n\n        let returnArray = false;\n        if (Array.isArray(buff)) {\n            buff = array2buffer(buff, sIn);\n            returnArray = true;\n        } else {\n            buff = buff.slice(0, buff.byteLength);\n        }\n\n        const nPoints = buff.byteLength / sIn;\n        const bits = log2(nPoints);\n\n        if  ((1 << bits) != nPoints) {\n            throw new Error(\"fft must be multiple of 2\" );\n        }\n\n        if (bits == Fr.s +1) {\n            let buffOut;\n\n            if (inverse) {\n                buffOut =  await _fftExtInv(buff, inType, outType, logger, loggerTxt);\n            } else {\n                buffOut =  await _fftExt(buff, inType, outType, logger, loggerTxt);\n            }\n\n            if (returnArray) {\n                return buffer2array(buffOut, sOut);\n            } else {\n                return buffOut;\n            }\n        }\n\n        let inv;\n        if (inverse) {\n            inv = Fr.inv(Fr.e(nPoints));\n        }\n\n        let buffOut;\n\n        buffReverseBits(buff, sIn);\n\n        let chunks;\n        let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);\n        let nChunks = nPoints / pointsInChunk;\n\n        while ((nChunks < tm.concurrency)&&(pointsInChunk>=16)) {\n            nChunks *= 2;\n            pointsInChunk /= 2;\n        }\n\n        const l2Chunk = log2(pointsInChunk);\n\n        const promises = [];\n        for (let i = 0; i< nChunks; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix start: ${i}/${nChunks}`);\n            const task = [];\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*pointsInChunk});\n            const buffChunk = buff.slice( (pointsInChunk * i)*sIn, (pointsInChunk * (i+1))*sIn);\n            task.push({cmd: \"SET\", var: 0, buff: buffChunk});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n            }\n            for (let j=1; j<=l2Chunk;j++) {\n                task.push({cmd: \"CALL\", fnName:fnFFTMix, params: [{var:0}, {val: pointsInChunk}, {val: j}]});\n            }\n\n            if (l2Chunk==bits) {\n                if (fnFFTFinal) {\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: inv});\n                    task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                        {var: 0},\n                        {val: pointsInChunk},\n                        {var: 1},\n                    ]});\n                }\n                if (fnMid2Out) {\n                    task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                }\n                task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n            } else {\n                task.push({cmd: \"GET\", out:0, var: 0, len: sMid*pointsInChunk});\n            }\n            promises.push(tm.queueAction(task).then( (r) => {\n                if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix end: ${i}/${nChunks}`);\n                return r;\n            }));\n        }\n\n        chunks = await Promise.all(promises);\n        for (let i = 0; i< nChunks; i++) chunks[i] = chunks[i][0];\n\n        for (let i = l2Chunk+1;   i<=bits; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft  ${bits}  join: ${i}/${bits}`);\n            const nGroups = 1 << (bits - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsInChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsInChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    if (i==bits) {\n                        if (fnFFTFinal) {\n                            task.push({cmd: \"ALLOCSET\", var: 4, buff: inv});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 0},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 1},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                        }\n                        if (fnMid2Out) {\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: pointsInChunk}, {var: 1}]});\n                        }\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sOut});\n                    } else {\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sMid});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sMid});\n                    }\n                    opPromises.push(tm.queueAction(task).then( (r) => {\n                        if (logger) logger.debug(`${loggerTxt}: fft ${bits} join  ${i}/${bits}  ${j+1}/${nGroups} ${k}/${nChunksPerGroup/2}`);\n                        return r;\n                    }));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        if (buff instanceof BigBuffer) {\n            buffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            buffOut = new Uint8Array(nPoints*sOut);\n        }\n        if (inverse) {\n            buffOut.set(chunks[0].slice((pointsInChunk-1)*sOut));\n            let p= sOut;\n            for (let i=nChunks-1; i>0; i--) {\n                buffOut.set(chunks[i], p);\n                p += pointsInChunk*sOut;\n                delete chunks[i];  // Liberate mem\n            }\n            buffOut.set(chunks[0].slice(0, (pointsInChunk-1)*sOut), p);\n            delete chunks[0];\n        } else {\n            for (let i=0; i<nChunks; i++) {\n                buffOut.set(chunks[i], pointsInChunk*sOut*i);\n                delete chunks[i];\n            }\n        }\n\n        if (returnArray) {\n            return buffer2array(buffOut, sOut);\n        } else {\n            return buffOut;\n        }\n    }\n\n    async function _fftExt(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        [b1, b2] = await _fftJoinExt(b1, b2, \"fftJoinExt\", Fr.one, Fr.shift, inType, \"jacobian\", logger, loggerTxt);\n\n        promises.push( _fft(b1, false, \"jacobian\", outType, logger, loggerTxt));\n        promises.push( _fft(b2, false, \"jacobian\", outType, logger, loggerTxt));\n\n        const res1 = await Promise.all(promises);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n    async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        promises.push( _fft(b1, true, inType, \"jacobian\", logger, loggerTxt));\n        promises.push( _fft(b2, true, inType, \"jacobian\", logger, loggerTxt));\n\n        [b1, b2] = await Promise.all(promises);\n\n        const res1 = await _fftJoinExt(b1, b2, \"fftJoinExtInv\", Fr.one, Fr.shiftInv, \"jacobian\", outType, logger, loggerTxt);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n\n    async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const MIN_CHUNK_SIZE = 1<<4;\n\n        let fnName;\n        let fnIn2Mid, fnMid2Out;\n        let sOut, sIn, sMid;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            fnName = \"g1m_\"+fn;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g1m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            fnName = \"g2m_\"+fn;\n            sMid = G.F.n8*3;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g2m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n            sOut = Fr.n8;\n            sMid = Fr.n8;\n            fnName = \"frm_\" + fn;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sIn);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let chunkSize = Math.floor(nPoints /tm.concurrency);\n        if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n        if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n\n        const opPromises = [];\n\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n\n            const firstChunk = Fr.mul(first, Fr.exp( inc, i));\n            const task = [];\n\n            const b1 = buff1.slice(i*sIn, (i+n)*sIn);\n            const b2 = buff2.slice(i*sIn, (i+n)*sIn);\n\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*n});\n            task.push({cmd: \"SET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOC\", var: 1, len: sMid*n});\n            task.push({cmd: \"SET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: n},\n                {var: 2},\n                {var: 3},\n                {val: Fr.s},\n            ]});\n            if (fnMid2Out) {\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sOut});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: n*sOut});\n            opPromises.push(\n                tm.queueAction(task).then( (r) => {\n                    if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);\n                    return r;\n                })\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (nPoints * sOut > 1<<28) {\n            fullBuffOut1 = new BigBuffer(nPoints*sOut);\n            fullBuffOut2 = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sOut);\n            fullBuffOut2 = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    }\n\n\n    G.fft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, false, inType, outType, logger, loggerTxt);\n    };\n\n    G.ifft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, true, inType, outType, logger, loggerTxt);\n    };\n\n    G.lagrangeEvaluations = async function (buff, inType, outType, logger, loggerTxt) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n\n        let sIn;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = buff.byteLength /sIn;\n        const bits = log2(nPoints);\n\n        if ((2 ** bits)*sIn != buff.byteLength) {\n            if (logger) logger.error(\"lagrangeEvaluations iinvalid input size\");\n            throw new Error(\"lagrangeEvaluations invalid Input size\");\n        }\n\n        if (bits <= Fr.s) {\n            return await G.ifft(buff, inType, outType, logger, loggerTxt);\n        }\n\n        if (bits > Fr.s+1) {\n            if (logger) logger.error(\"lagrangeEvaluations input too big\");\n            throw new Error(\"lagrangeEvaluations input too big\");\n        }\n\n        let t0 = buff.slice(0, buff.byteLength/2);\n        let t1 = buff.slice(buff.byteLength/2, buff.byteLength);\n\n\n        const shiftToSmallM = Fr.exp(Fr.shift, nPoints/2);\n        const sConst = Fr.inv( Fr.sub(Fr.one, shiftToSmallM));\n\n        [t0, t1] = await _fftJoinExt(t0, t1, \"prepareLagrangeEvaluation\", sConst, Fr.shiftInv, inType, \"jacobian\", logger, loggerTxt + \" prep\");\n\n        const promises = [];\n\n        promises.push( _fft(t0, true, \"jacobian\", outType, logger, loggerTxt + \" t0\"));\n        promises.push( _fft(t1, true, \"jacobian\", outType, logger, loggerTxt + \" t1\"));\n\n        [t0, t1] = await Promise.all(promises);\n\n        let buffOut;\n        if (t0.byteLength > (1<<28)) {\n            buffOut = new BigBuffer(t0.byteLength*2);\n        } else {\n            buffOut = new Uint8Array(t0.byteLength*2);\n        }\n\n        buffOut.set(t0);\n        buffOut.set(t1, t0.byteLength);\n\n        return buffOut;\n    };\n\n    G.fftMix = async function fftMix(buff) {\n        const sG = G.F.n8*3;\n        let fnName, fnFFTJoin;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftMix\";\n            fnFFTJoin = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftMix\";\n            fnFFTJoin = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        const power = log2(nPoints);\n\n        let nChunks = 1 << log2(tm.concurrency);\n\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n        const powerChunk = log2(pointsPerChunk);\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            for (let j=1; j<=powerChunk; j++) {\n                task.push({cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: pointsPerChunk},\n                    {val: j}\n                ]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        const chunks = [];\n        for (let i=0; i<result.length; i++) chunks[i] = result[i][0];\n\n\n        for (let i = powerChunk+1; i<=power; i++) {\n            const nGroups = 1 << (power - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsPerChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsPerChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n                    task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n                    opPromises.push(tm.queueAction(task));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sG);\n        }\n        let p =0;\n        for (let i=0; i<nChunks; i++) {\n            fullBuffOut.set(chunks[i], p);\n            p+=chunks[i].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n\n    G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {\n        const sG = G.F.n8*3;\n        let fnName;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let nChunks = 1 << log2(tm.concurrency);\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n\n            const firstChunk = Fr.mul(first, Fr.exp(inc, i*pointsPerChunk));\n            const b1 = buff1.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            const b2 = buff2.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: pointsPerChunk},\n                {var: 2},\n                {var: 3}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (buff1 instanceof BigBuffer) {\n            fullBuffOut1 = new BigBuffer(nPoints*sG);\n            fullBuffOut2 = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sG);\n            fullBuffOut2 = new Uint8Array(nPoints*sG);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    };\n\n\n\n    G.fftFinal =  async function fftFinal(buff, factor) {\n        const sG = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnName, fnToAffine;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftFinal\";\n            fnToAffine = \"g1m_batchToAffine\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftFinal\";\n            fnToAffine = \"g2m_batchToAffine\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        const pointsPerChunk = Math.floor(nPoints / tm.concurrency);\n\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, (i*pointsPerChunk+n)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: factor});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {val: n},\n                {var: 1},\n            ]});\n            task.push({cmd: \"CALL\", fnName: fnToAffine, params: [\n                {var: 0},\n                {val: n},\n                {var: 0},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sGout});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sGout);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sGout);\n        }\n\n        let p =0;\n        for (let i=result.length-1; i>=0; i--) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n", "import { buildBls12381 as buildBls12381wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bls12381 = null;\n\nexport default async function buildBls12381(singleThread, plugins) {\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBls12381wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bls12381wasm = {};\n\n    bls12381wasm.code = moduleBuilder.build();\n    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;\n    bls12381wasm.pr = moduleBuilder.modules.frm.pq;\n    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;\n    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;\n    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;\n    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;\n    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;\n    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;\n    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;\n    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;\n    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;\n    bls12381wasm.n8q = 48;\n    bls12381wasm.n8r = 32;\n    bls12381wasm.q = moduleBuilder.modules.bls12381.q;\n    bls12381wasm.r = moduleBuilder.modules.bls12381.r;\n\n\n    if ((!singleThread) && (globalThis.curve_bls12381)) return globalThis.curve_bls12381;\n    const params = {\n        name: \"bls12381\",\n        wasm: bls12381wasm,\n        q: Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16),\n        r: Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16),\n        n8q: 48,\n        n8r: 32,\n        cofactorG1: Scalar.e(\"0x396c8c005555e1568c00aaab0000aaab\", 16),\n        cofactorG2: Scalar.e(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bls12381 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bls12381 = curve;\n    }\n\n    return curve;\n}\n\n", "import * as Scalar from \"./scalar.js\";\nimport {default as buildBn128} from \"./bn128.js\";\nimport {default as buildBls12381} from \"./bls12381.js\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nexport async function getCurveFromR(r, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(r, bn128r)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(r, bls12381r)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromQ(q, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(q, bn128q)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(q, bls12381q)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(q, 16)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromName(name, singleThread, plugins) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n", "const SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\nexport default BigArray;\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {readR1cs}  from \"r1csfile\";\nimport { stringifyBigIntsWithField } from \"./misc.js\";\n\n\nexport default async function r1csExportJson(r1csFileName, logger) {\n\n    const cir = await readR1cs(r1csFileName, true, true, true, logger);\n    const Fr=cir.curve.Fr;\n    delete cir.curve;\n    delete cir.F;\n\n    return stringifyBigIntsWithField(Fr, cir);\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport {default as calculate} from \"./wtns_calculate.js\";\nexport {default as debug} from \"./wtns_debug.js\";\nexport {default as exportJson} from \"./wtns_export_json.js\";\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\nimport { WitnessCalculatorBuilder } from \"circom_runtime\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport loadSyms from \"./loadsyms.js\";\nimport {  utils }   from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\n\nexport default async function wtnsDebug(_input, wasmFileName, wtnsFileName, symName, options, logger) {\n\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastFile.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n\n    let wcOps = {\n        sanityCheck: true\n    };\n    let sym = await loadSyms(symName);\n    if (options.set) {\n        if (!sym) sym = await loadSyms(symName);\n        wcOps.logSetSignal= function(labelIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"SET \" + sym.labelIdx2Name[labelIdx] + \" <\" + \"-- \" + value.toString());\n        };\n    }\n    if (options.get) {\n        if (!sym) sym = await loadSyms(symName);\n        wcOps.logGetSignal= function(varIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"GET \" + sym.labelIdx2Name[varIdx] + \" --\" + \"> \" + value.toString());\n        };\n    }\n    if (options.trigger) {\n        if (!sym) sym = await loadSyms(symName);\n        wcOps.logStartComponent= function(cIdx) {\n            if (logger) logger.info(\"START: \" + sym.componentIdx2Name[cIdx]);\n        };\n        wcOps.logFinishComponent= function(cIdx) {\n            if (logger) logger.info(\"FINISH: \" + sym.componentIdx2Name[cIdx]);\n        };\n    }\n    wcOps.sym = sym;\n\n    const wc = await WitnessCalculatorBuilder(wasm, wcOps);\n    const w = await wc.calculateWitness(input);\n\n    const fdWtns = await binFileUtils.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n    await wtnsUtils.write(fdWtns, w, wc.prime);\n\n    await fdWtns.close();\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\n\nexport default async function loadSymbols(symFileName) {\n    const sym = {\n        labelIdx2Name: [ \"one\" ],\n        varIdx2Name: [ \"one\" ],\n        componentIdx2Name: []\n    };\n    const fd = await fastFile.readExisting(symFileName);\n    const buff = await fd.read(fd.totalSize);\n    const symsStr = new TextDecoder(\"utf-8\").decode(buff);\n    const lines = symsStr.split(\"\\n\");\n    for (let i=0; i<lines.length; i++) {\n        const arr = lines[i].split(\",\");\n        if (arr.length!=4) continue;\n        if (sym.varIdx2Name[arr[1]]) {\n            sym.varIdx2Name[arr[1]] += \"|\" + arr[3];\n        } else {\n            sym.varIdx2Name[arr[1]] = arr[3];\n        }\n        sym.labelIdx2Name[arr[0]] = arr[3];\n        if (!sym.componentIdx2Name[arr[2]]) {\n            sym.componentIdx2Name[arr[2]] = extractComponent(arr[3]);\n        }\n    }\n\n    await fd.close();\n\n    return sym;\n\n    function extractComponent(name) {\n        const arr = name.split(\".\");\n        arr.pop(); // Remove the lasr element\n        return arr.join(\".\");\n    }\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {read} from \"./wtns_utils.js\";\n\nexport default async function wtnsExportJson(wtnsFileName) {\n\n    const w = await read(wtnsFileName);\n\n    return w;\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport {default as newZKey} from \"./zkey_new.js\";\nexport {default as exportBellman} from \"./zkey_export_bellman.js\";\nexport {default as importBellman} from \"./zkey_import_bellman.js\";\nexport {default as verifyFromR1cs} from \"./zkey_verify_fromr1cs.js\";\nexport {default as verifyFromInit} from \"./zkey_verify_frominit.js\";\nexport {default as contribute} from \"./zkey_contribute.js\";\nexport {default as beacon} from \"./zkey_beacon.js\";\nexport {default as exportJson} from \"./zkey_export_json.js\";\nexport {default as bellmanContribute} from \"./zkey_bellman_contribute.js\";\nexport {default as exportVerificationKey} from \"./zkey_export_verificationkey.js\";\nexport {default as exportSolidityVerifier} from \"./zkey_export_solidityverifier.js\";\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {readR1csHeader} from \"r1csfile\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport {\n    readBinFile,\n    createBinFile,\n    readSection,\n    writeBigInt,\n    startWriteSection,\n    endWriteSection,\n} from \"@iden3/binfileutils\";\nimport { log2, formatHash } from \"./misc.js\";\nimport { Scalar, BigBuffer } from \"ffjavascript\";\nimport Blake2b from \"blake2b-wasm\";\nimport BigArray from \"./bigarray.js\";\n\n\nexport default async function newZKey(r1csName, ptauName, zkeyName, logger) {\n\n    const TAU_G1 = 0;\n    const TAU_G2 = 1;\n    const ALPHATAU_G1 = 2;\n    const BETATAU_G1 = 3;\n    await Blake2b.ready();\n    const csHasher = Blake2b(64);\n\n    const {fd: fdPTau, sections: sectionsPTau} = await readBinFile(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await utils.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await readBinFile(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n    const r1cs = await readR1csHeader(fdR1cs, sectionsR1cs, false);\n\n    const fdZKey = await createBinFile(zkeyName, \"zkey\", 1, 10, 1<<22, 1<<24);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    const cirPower = log2(r1cs.nConstraints + r1cs.nPubInputs + r1cs.nOutputs +1 -1) +1;\n\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${r1cs.nConstraints}*2 > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n    const domainSize = 2 ** cirPower;\n\n    // Write the header\n    ///////////\n    await startWriteSection(fdZKey, 1);\n    await fdZKey.writeULE32(1); // Groth\n    await endWriteSection(fdZKey);\n\n    // Write the Groth header section\n    ///////////\n\n    await startWriteSection(fdZKey, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n    const Rr = Scalar.mod(Scalar.shl(1, n8r*8), primeR);\n    const R2r = curve.Fr.e(Scalar.mod(Scalar.mul(Rr,Rr), primeR));\n\n    await fdZKey.writeULE32(n8q);\n    await writeBigInt(fdZKey, primeQ, n8q);\n    await fdZKey.writeULE32(n8r);\n    await writeBigInt(fdZKey, primeR, n8r);\n    await fdZKey.writeULE32(r1cs.nVars);                         // Total number of bars\n    await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n    await fdZKey.writeULE32(domainSize);                  // domainSize\n\n    let bAlpha1;\n    bAlpha1 = await fdPTau.read(sG1, sectionsPTau[4][0].p);\n    await fdZKey.write(bAlpha1);\n    bAlpha1 = await curve.G1.batchLEMtoU(bAlpha1);\n    csHasher.update(bAlpha1);\n\n    let bBeta1;\n    bBeta1 = await fdPTau.read(sG1, sectionsPTau[5][0].p);\n    await fdZKey.write(bBeta1);\n    bBeta1 = await curve.G1.batchLEMtoU(bBeta1);\n    csHasher.update(bBeta1);\n\n    let bBeta2;\n    bBeta2 = await fdPTau.read(sG2, sectionsPTau[6][0].p);\n    await fdZKey.write(bBeta2);\n    bBeta2 = await curve.G2.batchLEMtoU(bBeta2);\n    csHasher.update(bBeta2);\n\n    const bg1 = new Uint8Array(sG1);\n    curve.G1.toRprLEM(bg1, 0, curve.G1.g);\n    const bg2 = new Uint8Array(sG2);\n    curve.G2.toRprLEM(bg2, 0, curve.G2.g);\n    const bg1U = new Uint8Array(sG1);\n    curve.G1.toRprUncompressed(bg1U, 0, curve.G1.g);\n    const bg2U = new Uint8Array(sG2);\n    curve.G2.toRprUncompressed(bg2U, 0, curve.G2.g);\n\n    await fdZKey.write(bg2);        // gamma2\n    await fdZKey.write(bg1);        // delta1\n    await fdZKey.write(bg2);        // delta2\n    csHasher.update(bg2U);      // gamma2\n    csHasher.update(bg1U);      // delta1\n    csHasher.update(bg2U);      // delta2\n    await endWriteSection(fdZKey);\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await readSection(fdR1cs, sectionsR1cs, 2);\n\n    const A = new BigArray(r1cs.nVars);\n    const B1 = new BigArray(r1cs.nVars);\n    const B2 = new BigArray(r1cs.nVars);\n    const C = new BigArray(r1cs.nVars- nPublic -1);\n    const IC = new Array(nPublic+1);\n\n    if (logger) logger.info(\"Reading tauG1\");\n    let sTauG1 = await readSection(fdPTau, sectionsPTau, 12, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading tauG2\");\n    let sTauG2 = await readSection(fdPTau, sectionsPTau, 13, (domainSize -1)*sG2, domainSize*sG2);\n    if (logger) logger.info(\"Reading alphatauG1\");\n    let sAlphaTauG1 = await readSection(fdPTau, sectionsPTau, 14, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading betatauG1\");\n    let sBetaTauG1 = await readSection(fdPTau, sectionsPTau, 15, (domainSize -1)*sG1, domainSize*sG1);\n\n    await processConstraints();\n\n    await composeAndWritePoints(3, \"G1\", IC, \"IC\");\n\n    await writeHs();\n\n    await hashHPoints();\n\n    await composeAndWritePoints(8, \"G1\", C, \"C\");\n    await composeAndWritePoints(5, \"G1\", A, \"A\");\n    await composeAndWritePoints(6, \"G1\", B1, \"B1\");\n    await composeAndWritePoints(7, \"G2\", B2, \"B2\");\n\n    const csHash = csHasher.digest();\n    // Contributions section\n    await startWriteSection(fdZKey, 10);\n    await fdZKey.write(csHash);\n    await fdZKey.writeULE32(0);\n    await endWriteSection(fdZKey);\n\n    if (logger) logger.info(formatHash(csHash, \"Circuit hash: \"));\n\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    return csHash;\n\n    async function writeHs() {\n        await startWriteSection(fdZKey, 9);\n        const buffOut = new BigBuffer(domainSize*sG1);\n        if (cirPower < curve.Fr.s) {\n            let sTauG1 = await readSection(fdPTau, sectionsPTau, 12, (domainSize*2-1)*sG1, domainSize*2*sG1);\n            for (let i=0; i< domainSize; i++) {\n                if ((logger)&&(i%10000 == 0)) logger.debug(`spliting buffer: ${i}/${domainSize}`);\n                const buff = sTauG1.slice( (i*2+1)*sG1, (i*2+1)*sG1 + sG1 );\n                buffOut.set(buff, i*sG1);\n            }\n        } else if (cirPower == curve.Fr.s) {\n            const o = sectionsPTau[12][0].p + ((2 ** (cirPower+1)) -1)*sG1;\n            await fdPTau.readToBuffer(buffOut, 0, domainSize*sG1, o + domainSize*sG1);\n        } else {\n            if (logger) logger.error(\"Circuit too big\");\n            throw new Error(\"Circuit too big for this curve\");\n        }\n        await fdZKey.write(buffOut);\n        await endWriteSection(fdZKey);\n    }\n\n    async function processConstraints() {\n        const buffCoeff = new Uint8Array(12 + curve.Fr.n8);\n        const buffCoeffV = new DataView(buffCoeff.buffer);\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let r1csPos = 0;\n\n        function r1cs_readULE32() {\n            const buff = sR1cs.slice(r1csPos, r1csPos+4);\n            r1csPos += 4;\n            const buffV = new DataView(buff.buffer);\n            return buffV.getUint32(0, true);\n        }\n\n        const coefs = new BigArray();\n        for (let c=0; c<r1cs.nConstraints; c++) {\n            if ((logger)&&(c%10000 == 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            const nA = r1cs_readULE32();\n            for (let i=0; i<nA; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = BETATAU_G1;\n                const l2 = sG1*c;\n                if (typeof A[s] === \"undefined\") A[s] = [];\n                A[s].push([l1t, l1, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l2t, l2, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s - nPublic -1].push([l2t, l2, coefp]);\n                }\n                coefs.push([0, c, s, coefp]);\n            }\n\n            const nB = r1cs_readULE32();\n            for (let i=0; i<nB; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = TAU_G2;\n                const l2 = sG2*c;\n                const l3t = ALPHATAU_G1;\n                const l3 = sG1*c;\n                if (typeof B1[s] === \"undefined\") B1[s] = [];\n                B1[s].push([l1t, l1, coefp]);\n                if (typeof B2[s] === \"undefined\") B2[s] = [];\n                B2[s].push([l2t, l2, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l3t, l3, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l3t, l3, coefp]);\n                }\n\n                coefs.push([1, c, s, coefp]);\n            }\n\n            const nC = r1cs_readULE32();\n            for (let i=0; i<nC; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l1t, l1, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l1t, l1, coefp]);\n                }\n            }\n        }\n\n        for (let s = 0; s <= nPublic ; s++) {\n            const l1t = TAU_G1;\n            const l1 = sG1*(r1cs.nConstraints + s);\n            const l2t = BETATAU_G1;\n            const l2 = sG1*(r1cs.nConstraints + s);\n            if (typeof A[s] === \"undefined\") A[s] = [];\n            A[s].push([l1t, l1, -1]);\n            if (typeof IC[s] === \"undefined\") IC[s] = [];\n            IC[s].push([l2t, l2, -1]);\n            coefs.push([0, r1cs.nConstraints + s, s, -1]);\n        }\n\n\n        await startWriteSection(fdZKey, 4);\n\n        const buffSection = new BigBuffer(coefs.length*(12+curve.Fr.n8) + 4);\n\n        const buff4 = new Uint8Array(4);\n        const buff4V = new DataView(buff4.buffer);\n        buff4V.setUint32(0, coefs.length, true);\n        buffSection.set(buff4);\n        let coefsPos = 4;\n        for (let i=0; i<coefs.length; i++) {\n            if ((logger)&&(i%100000 == 0)) logger.debug(`writing coeffs: ${i}/${coefs.length}`);\n            writeCoef(coefs[i]);\n        }\n\n        await fdZKey.write(buffSection);\n        await endWriteSection(fdZKey);\n\n        function writeCoef(c) {\n            buffCoeffV.setUint32(0, c[0], true);\n            buffCoeffV.setUint32(4, c[1], true);\n            buffCoeffV.setUint32(8, c[2], true);\n            let n;\n            if (c[3]>=0) {\n                n = curve.Fr.fromRprLE(sR1cs.slice(c[3], c[3] + curve.Fr.n8), 0);\n            } else {\n                n = curve.Fr.fromRprLE(bOne, 0);\n            }\n            const nR2 = curve.Fr.mul(n, R2r);\n            curve.Fr.toRprLE(buffCoeff, 12, nR2);\n            buffSection.set(buffCoeff, coefsPos);\n            coefsPos += buffCoeff.length;\n        }\n\n    }\n\n    async function composeAndWritePoints(idSection, groupName, arr, sectionName) {\n        const CHUNK_SIZE= 1<<15;\n        const G = curve[groupName];\n\n        hashU32(arr.length);\n        await startWriteSection(fdZKey, idSection);\n\n        let opPromises = [];\n\n        let i=0;\n        while (i<arr.length) {\n\n            let t=0;\n            while ((i<arr.length)&&(t<curve.tm.concurrency)) {\n                if (logger)  logger.debug(`Writing points start ${sectionName}: ${i}/${arr.length}`);\n                let n = 1;\n                let nP = (arr[i] ? arr[i].length : 0);\n                while ((i + n < arr.length) && (nP + (arr[i+n] ? arr[i+n].length : 0) < CHUNK_SIZE) && (n<CHUNK_SIZE)) {\n                    nP += (arr[i+n] ? arr[i+n].length : 0);\n                    n ++;\n                }\n                const subArr = arr.slice(i, i + n);\n                const _i = i;\n                opPromises.push(composeAndWritePointsThread(groupName, subArr, logger, sectionName).then( (r) => {\n                    if (logger)  logger.debug(`Writing points end ${sectionName}: ${_i}/${arr.length}`);\n                    return r;\n                }));\n                i += n;\n                t++;\n            }\n\n            const result = await Promise.all(opPromises);\n\n            for (let k=0; k<result.length; k++) {\n                await fdZKey.write(result[k][0]);\n                const buff = await G.batchLEMtoU(result[k][0]);\n                csHasher.update(buff);\n            }\n            opPromises = [];\n\n        }\n        await endWriteSection(fdZKey);\n\n    }\n\n    async function composeAndWritePointsThread(groupName, arr, logger, sectionName) {\n        const G = curve[groupName];\n        const sGin = G.F.n8*2;\n        const sGmid = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnExp, fnMultiExp, fnBatchToAffine, fnZero;\n        if (groupName == \"G1\") {\n            fnExp = \"g1m_timesScalarAffine\";\n            fnMultiExp = \"g1m_multiexpAffine\";\n            fnBatchToAffine = \"g1m_batchToAffine\";\n            fnZero = \"g1m_zero\";\n        } else if (groupName == \"G2\") {\n            fnExp = \"g2m_timesScalarAffine\";\n            fnMultiExp = \"g2m_multiexpAffine\";\n            fnBatchToAffine = \"g2m_batchToAffine\";\n            fnZero = \"g2m_zero\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        let acc =0;\n        for (let i=0; i<arr.length; i++) acc += arr[i] ? arr[i].length : 0;\n        let bBases, bScalars;\n        if (acc> 2<<14) {\n            bBases = new BigBuffer(acc*sGin);\n            bScalars = new BigBuffer(acc*curve.Fr.n8);\n        } else {\n            bBases = new Uint8Array(acc*sGin);\n            bScalars = new Uint8Array(acc*curve.Fr.n8);\n        }\n        let pB =0;\n        let pS =0;\n\n        const sBuffs = [\n            sTauG1,\n            sTauG2,\n            sAlphaTauG1,\n            sBetaTauG1\n        ];\n\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let offset = 0;\n        for (let i=0; i<arr.length; i++) {\n            if (!arr[i]) continue;\n            for (let j=0; j<arr[i].length; j++) {\n                if ((logger)&&(j)&&(j%10000 == 0))  logger.debug(`Configuring big array ${sectionName}: ${j}/${arr[i].length}`);\n                bBases.set(\n                    sBuffs[arr[i][j][0]].slice(\n                        arr[i][j][1],\n                        arr[i][j][1] + sGin\n                    ), offset*sGin\n                );\n                if (arr[i][j][2]>=0) {\n                    bScalars.set(\n                        sR1cs.slice(\n                            arr[i][j][2],\n                            arr[i][j][2] + curve.Fr.n8\n                        ),\n                        offset*curve.Fr.n8\n                    );\n                } else {\n                    bScalars.set(bOne, offset*curve.Fr.n8);\n                }\n                offset ++;\n            }\n        }\n\n        if (arr.length>1) {\n            const task = [];\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: bBases});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: bScalars});\n            task.push({cmd: \"ALLOC\", var: 2, len: arr.length*sGmid});\n            pB = 0;\n            pS = 0;\n            let pD =0;\n            for (let i=0; i<arr.length; i++) {\n                if (!arr[i]) {\n                    task.push({cmd: \"CALL\", fnName: fnZero, params: [\n                        {var: 2, offset: pD}\n                    ]});\n                    pD += sGmid;\n                    continue;\n                }\n                if (arr[i].length == 1) {\n                    task.push({cmd: \"CALL\", fnName: fnExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {var: 2, offset: pD}\n                    ]});\n                } else {\n                    task.push({cmd: \"CALL\", fnName: fnMultiExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {val: arr[i].length},\n                        {var: 2, offset: pD}\n                    ]});\n                }\n                pB += sGin*arr[i].length;\n                pS += curve.Fr.n8*arr[i].length;\n                pD += sGmid;\n            }\n            task.push({cmd: \"CALL\", fnName: fnBatchToAffine, params: [\n                {var: 2},\n                {val: arr.length},\n                {var: 2},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: arr.length*sGout});\n\n            const res = await curve.tm.queueAction(task);\n            return res;\n        } else {\n            let res = await G.multiExpAffine(bBases, bScalars, logger, sectionName);\n            res = [ G.toAffine(res) ];\n            return res;\n        }\n    }\n\n\n    async function hashHPoints() {\n        const CHUNK_SIZE = 1<<14;\n\n        hashU32(domainSize-1);\n\n        for (let i=0; i<domainSize-1; i+= CHUNK_SIZE) {\n            if (logger)  logger.debug(`HashingHPoints: ${i}/${domainSize}`);\n            const n = Math.min(domainSize-1, CHUNK_SIZE);\n            await hashHPointsChunk(i, n);\n        }\n    }\n\n    async function hashHPointsChunk(offset, nPoints) {\n        const buff1 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + (offset + domainSize)*sG1);\n        const buff2 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + offset*sG1);\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(hashHPointsThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        for (let i=0; i<result.length; i++) {\n            csHasher.update(result[i][0]);\n        }\n    }\n\n    async function hashHPointsThread(buff1, buff2) {\n        const nPoints = buff1.byteLength/sG1;\n        const sGmid = curve.G1.F.n8*3;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchLEMtoU\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n    function hashU32(n) {\n        const buff = new Uint8Array(4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        buffV.setUint32(0, n, false);\n        csHasher.update(buff);\n    }\n\n}\n\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\nexport default BigArray;\n", "\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as fastFile from \"fastfile\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\n\nexport default async function phase2exportMPCParams(zkeyName, mpcparamsName, logger) {\n\n    const {fd: fdZKey, sections: sectionsZKey} = await binFileUtils.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fdZKey, sectionsZKey);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const mpcParams = await zkeyUtils.readMPCParams(fdZKey, curve, sectionsZKey);\n\n    const fdMPCParams = await fastFile.createOverride(mpcparamsName);\n\n    /////////////////////\n    // Verification Key Section\n    /////////////////////\n    await writeG1(zkey.vk_alpha_1);\n    await writeG1(zkey.vk_beta_1);\n    await writeG2(zkey.vk_beta_2);\n    await writeG2(zkey.vk_gamma_2);\n    await writeG1(zkey.vk_delta_1);\n    await writeG2(zkey.vk_delta_2);\n\n    // IC\n    let buffBasesIC;\n    buffBasesIC = await binFileUtils.readSection(fdZKey, sectionsZKey, 3);\n    buffBasesIC = await curve.G1.batchLEMtoU(buffBasesIC);\n\n    await writePointArray(\"G1\", buffBasesIC);\n\n    /////////////////////\n    // h Section\n    /////////////////////\n    const buffBasesH_Lodd = await binFileUtils.readSection(fdZKey, sectionsZKey, 9);\n\n    let buffBasesH_Tau;\n    buffBasesH_Tau = await curve.G1.fft(buffBasesH_Lodd, \"affine\", \"jacobian\", logger);\n    buffBasesH_Tau = await curve.G1.batchApplyKey(buffBasesH_Tau, curve.Fr.neg(curve.Fr.e(2)), curve.Fr.w[zkey.power+1], \"jacobian\", \"affine\", logger);\n\n    // Remove last element.  (The degree of H will be allways m-2)\n    buffBasesH_Tau = buffBasesH_Tau.slice(0, buffBasesH_Tau.byteLength - sG1);\n    buffBasesH_Tau = await curve.G1.batchLEMtoU(buffBasesH_Tau);\n    await writePointArray(\"G1\", buffBasesH_Tau);\n\n    /////////////////////\n    // L section\n    /////////////////////\n    let buffBasesC;\n    buffBasesC = await binFileUtils.readSection(fdZKey, sectionsZKey, 8);\n    buffBasesC = await curve.G1.batchLEMtoU(buffBasesC);\n    await writePointArray(\"G1\", buffBasesC);\n\n    /////////////////////\n    // A Section (C section)\n    /////////////////////\n    let buffBasesA;\n    buffBasesA = await binFileUtils.readSection(fdZKey, sectionsZKey, 5);\n    buffBasesA = await curve.G1.batchLEMtoU(buffBasesA);\n    await writePointArray(\"G1\", buffBasesA);\n\n    /////////////////////\n    // B1 Section\n    /////////////////////\n    let buffBasesB1;\n    buffBasesB1 = await binFileUtils.readSection(fdZKey, sectionsZKey, 6);\n    buffBasesB1 = await curve.G1.batchLEMtoU(buffBasesB1);\n    await writePointArray(\"G1\", buffBasesB1);\n\n    /////////////////////\n    // B2 Section\n    /////////////////////\n    let buffBasesB2;\n    buffBasesB2 = await binFileUtils.readSection(fdZKey, sectionsZKey, 7);\n    buffBasesB2 = await curve.G2.batchLEMtoU(buffBasesB2);\n    await writePointArray(\"G2\", buffBasesB2);\n\n    await fdMPCParams.write(mpcParams.csHash);\n    await writeU32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdMPCParams.write(c.transcript);\n    }\n\n    await fdZKey.close();\n    await fdMPCParams.close();\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writePointArray(groupName, buff) {\n        let sG;\n        if (groupName == \"G1\") {\n            sG = sG1;\n        } else {\n            sG = sG2;\n        }\n\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, buff.byteLength / sG, false);\n\n        await fdMPCParams.write(buffSize);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeU32(n) {\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, n, false);\n\n        await fdMPCParams.write(buffSize);\n    }\n\n\n\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as fastFile from \"fastfile\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport * as misc from \"./misc.js\";\n\nexport default async function phase2importMPCParams(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger) {\n\n    const {fd: fdZKeyOld, sections: sectionsZKeyOld} = await binFileUtils.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkeyHeader = await zkeyUtils.readHeader(fdZKeyOld, sectionsZKeyOld, false);\n    if (zkeyHeader.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkeyHeader.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const oldMPCParams = await zkeyUtils.readMPCParams(fdZKeyOld, curve, sectionsZKeyOld);\n    const newMPCParams = {};\n\n    const fdMPCParams = await fastFile.readExisting(mpcparamsName);\n\n    fdMPCParams.pos =\n        sG1*3 + sG2*3 +                     // vKey\n        8 + sG1*zkeyHeader.nVars +              // IC + C\n        4 + sG1*(zkeyHeader.domainSize-1) +     // H\n        4 + sG1*zkeyHeader.nVars +              // A\n        4 + sG1*zkeyHeader.nVars +              // B1\n        4 + sG2*zkeyHeader.nVars;               // B2\n\n    // csHash\n    newMPCParams.csHash =  await fdMPCParams.read(64);\n\n    const nConttributions = await fdMPCParams.readUBE32();\n    newMPCParams.contributions = [];\n    for (let i=0; i<nConttributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1(fdMPCParams);\n        c.delta.g1_s = await readG1(fdMPCParams);\n        c.delta.g1_sx = await readG1(fdMPCParams);\n        c.delta.g2_spx = await readG2(fdMPCParams);\n        c.transcript = await fdMPCParams.read(64);\n        if (i<oldMPCParams.contributions.length) {\n            c.type = oldMPCParams.contributions[i].type;\n            if (c.type==1) {\n                c.beaconHash = oldMPCParams.contributions[i].beaconHash;\n                c.numIterationsExp = oldMPCParams.contributions[i].numIterationsExp;\n            }\n            if (oldMPCParams.contributions[i].name) {\n                c.name = oldMPCParams.contributions[i].name;\n            }\n        }\n        newMPCParams.contributions.push(c);\n    }\n\n    if (!misc.hashIsEqual(newMPCParams.csHash, oldMPCParams.csHash)) {\n        if (logger) logger.error(\"Hash of the original circuit does not match with the MPC one\");\n        return false;\n    }\n\n    if (oldMPCParams.contributions.length > newMPCParams.contributions.length) {\n        if (logger) logger.error(\"The impoerted file does not include new contributions\");\n        return false;\n    }\n\n    for (let i=0; i<oldMPCParams.contributions.length; i++) {\n        if (!contributionIsEqual(oldMPCParams.contributions[i], newMPCParams.contributions[i])) {\n            if (logger) logger.error(`Previos contribution ${i} does not match`);\n            return false;\n        }\n    }\n\n\n    // Set the same name to all new controbutions\n    if (name) {\n        for (let i=oldMPCParams.contributions.length; i<newMPCParams.contributions.length; i++) {\n            newMPCParams.contributions[i].name = name;\n        }\n    }\n\n    const fdZKeyNew = await binFileUtils.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n    fdMPCParams.pos = 0;\n\n    // Header\n    fdMPCParams.pos += sG1;  // ignore alpha1 (keep original)\n    fdMPCParams.pos += sG1;  // ignore beta1\n    fdMPCParams.pos += sG2;  // ignore beta2\n    fdMPCParams.pos += sG2;  // ignore gamma2\n    zkeyHeader.vk_delta_1 = await readG1(fdMPCParams);\n    zkeyHeader.vk_delta_2 = await readG2(fdMPCParams);\n    await zkeyUtils.writeHeader(fdZKeyNew, zkeyHeader);\n\n    // IC (Keep original)\n    const nIC = await fdMPCParams.readUBE32();\n    if (nIC != zkeyHeader.nPublic +1) {\n        if (logger) logger.error(\"Invalid number of points in IC\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nPublic+1);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 4);\n\n    // H Section\n    const nH = await fdMPCParams.readUBE32();\n    if (nH != zkeyHeader.domainSize-1) {\n        if (logger) logger.error(\"Invalid number of points in H\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffH;\n    const buffTauU = await fdMPCParams.read(sG1*(zkeyHeader.domainSize-1));\n    const buffTauLEM = await curve.G1.batchUtoLEM(buffTauU);\n    buffH = new Uint8Array(zkeyHeader.domainSize*sG1);\n    buffH.set(buffTauLEM);   // Let the last one to zero.\n    curve.G1.toRprLEM(buffH, sG1*(zkeyHeader.domainSize-1), curve.G1.zeroAffine);\n    const n2Inv = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n    const wInv = curve.Fr.inv(curve.Fr.w[zkeyHeader.power+1]);\n    buffH = await curve.G1.batchApplyKey(buffH, n2Inv, wInv, \"affine\", \"jacobian\", logger);\n    buffH = await curve.G1.ifft(buffH, \"jacobian\", \"affine\", logger);\n    await binFileUtils.startWriteSection(fdZKeyNew, 9);\n    await fdZKeyNew.write(buffH);\n    await binFileUtils.endWriteSection(fdZKeyNew);\n\n    // C Secion (L section)\n    const nL = await fdMPCParams.readUBE32();\n    if (nL != (zkeyHeader.nVars-zkeyHeader.nPublic-1)) {\n        if (logger) logger.error(\"Invalid number of points in L\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffL;\n    buffL = await fdMPCParams.read(sG1*(zkeyHeader.nVars-zkeyHeader.nPublic-1));\n    buffL = await curve.G1.batchUtoLEM(buffL);\n    await binFileUtils.startWriteSection(fdZKeyNew, 8);\n    await fdZKeyNew.write(buffL);\n    await binFileUtils.endWriteSection(fdZKeyNew);\n\n    // A Section\n    const nA = await fdMPCParams.readUBE32();\n    if (nA != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in A\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 5);\n\n    // B1 Section\n    const nB1 = await fdMPCParams.readUBE32();\n    if (nB1 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B1\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 6);\n\n    // B2 Section\n    const nB2 = await fdMPCParams.readUBE32();\n    if (nB2 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B2\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG2*(zkeyHeader.nVars);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 7);\n\n    await zkeyUtils.writeMPCParams(fdZKeyNew, curve, newMPCParams);\n\n    await fdMPCParams.close();\n    await fdZKeyNew.close();\n    await fdZKeyOld.close();\n\n    return true;\n\n    async function readG1(fd) {\n        const buff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2(fd) {\n        const buff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n\n    function contributionIsEqual(c1, c2) {\n        if (!curve.G1.eq(c1.deltaAfter   , c2.deltaAfter)) return false;\n        if (!curve.G1.eq(c1.delta.g1_s   , c2.delta.g1_s)) return false;\n        if (!curve.G1.eq(c1.delta.g1_sx  , c2.delta.g1_sx)) return false;\n        if (!curve.G2.eq(c1.delta.g2_spx , c2.delta.g2_spx)) return false;\n        if (!misc.hashIsEqual(c1.transcript, c2.transcript)) return false;\n        return true;\n    }\n\n\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport newZKey from \"./zkey_new.js\";\nimport phase2verifyFromInit from \"./zkey_verify_frominit.js\";\n\nexport default async function phase2verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger) {\n\n    // const initFileName = \"~\" + zkeyFileName + \".init\";\n    const initFileName = {type: \"bigMem\"};\n    await newZKey(r1csFileName, pTauFileName, initFileName, logger);\n\n    return await phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger);\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport Blake2b from \"blake2b-wasm\";\nimport * as misc from \"./misc.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\nconst sameRatio = misc.sameRatio;\nimport crypto from \"crypto\";\nimport {hashG1, hashPubKey} from \"./zkey_utils.js\";\nimport { Scalar, ChaCha, BigBuffer } from \"ffjavascript\";\n\n\n\nexport default async function phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger) {\n\n    let sr;\n    await Blake2b.ready();\n\n    const {fd, sections} = await binFileUtils.readBinFile(zkeyFileName, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fd, sections, false);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n\n    const mpcParams = await zkeyUtils.readMPCParams(fd, curve, sections);\n\n    const accumulatedHasher = Blake2b(64);\n    accumulatedHasher.update(mpcParams.csHash);\n    let curDelta = curve.G1.g;\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        const ourHasher = misc.cloneHasher(accumulatedHasher);\n\n        hashG1(ourHasher, curve, c.delta.g1_s);\n        hashG1(ourHasher, curve, c.delta.g1_sx);\n\n        if (!misc.hashIsEqual(ourHasher.digest(), c.transcript)) {\n            console.log(`INVALID(${i}): Inconsistent transcript `);\n            return false;\n        }\n\n        const delta_g2_sp = hashToG2(curve, c.transcript);\n\n        sr = await sameRatio(curve, c.delta.g1_s, c.delta.g1_sx, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): public key G1 and G2 do not have the same ration `);\n            return false;\n        }\n\n        sr = await sameRatio(curve, curDelta, c.deltaAfter, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): deltaAfter does not fillow the public key `);\n            return false;\n        }\n\n        if (c.type == 1) {\n            const rng = misc.rngFromBeaconParams(c.beaconHash, c.numIterationsExp);\n            const expected_prvKey = curve.Fr.fromRng(rng);\n            const expected_g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n            const expected_g1_sx = curve.G1.toAffine(curve.G1.timesFr(expected_g1_s, expected_prvKey));\n            if (curve.G1.eq(expected_g1_s, c.delta.g1_s) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_s `);\n                return false;\n            }\n            if (curve.G1.eq(expected_g1_sx, c.delta.g1_sx) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_sx `);\n                return false;\n            }\n        }\n\n        hashPubKey(accumulatedHasher, curve, c);\n\n        const contributionHasher = Blake2b(64);\n        hashPubKey(contributionHasher, curve, c);\n\n        c.contributionHash = contributionHasher.digest();\n\n        curDelta = c.deltaAfter;\n    }\n\n\n    const {fd: fdInit, sections: sectionsInit} = await binFileUtils.readBinFile(initFileName, \"zkey\", 2);\n    const zkeyInit = await zkeyUtils.readHeader(fdInit, sectionsInit, false);\n\n    if (zkeyInit.protocol != \"groth16\") {\n        throw new Error(\"zkeyinit file is not groth16\");\n    }\n\n    if (  (!Scalar.eq(zkeyInit.q, zkey.q))\n        ||(!Scalar.eq(zkeyInit.r, zkey.r))\n        ||(zkeyInit.n8q != zkey.n8q)\n        ||(zkeyInit.n8r != zkey.n8r))\n    {\n        if (logger) logger.error(\"INVALID:  Different curves\");\n        return false;\n    }\n\n    if (  (zkeyInit.nVars != zkey.nVars)\n        ||(zkeyInit.nPublic !=  zkey.nPublic)\n        ||(zkeyInit.domainSize != zkey.domainSize))\n    {\n        if (logger) logger.error(\"INVALID:  Different circuit parameters\");\n        return false;\n    }\n\n    if (!curve.G1.eq(zkey.vk_alpha_1, zkeyInit.vk_alpha_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid alpha1\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_beta_1, zkeyInit.vk_beta_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta1\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_beta_2, zkeyInit.vk_beta_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta2\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_gamma_2, zkeyInit.vk_gamma_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid gamma2\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_delta_1, curDelta)) {\n        if (logger) logger.error(\"INVALID:  Invalid delta1\");\n        return false;\n    }\n    sr = await sameRatio(curve, curve.G1.g, curDelta, curve.G2.g, zkey.vk_delta_2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID:  Invalid delta2\");\n        return false;\n    }\n\n    const mpcParamsInit = await zkeyUtils.readMPCParams(fdInit, curve, sectionsInit);\n    if (!misc.hashIsEqual(mpcParams.csHash, mpcParamsInit.csHash)) {\n        if (logger) logger.error(\"INVALID:  Circuit does not match\");\n        return false;\n    }\n\n    // Check sizes of sections\n    if (sections[8][0].size != sG1*(zkey.nVars-zkey.nPublic-1)) {\n        if (logger) logger.error(\"INVALID:  Invalid L section size\");\n        return false;\n    }\n\n    if (sections[9][0].size != sG1*(zkey.domainSize)) {\n        if (logger) logger.error(\"INVALID:  Invalid H section size\");\n        return false;\n    }\n\n    let ss;\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 3);\n    if (!ss) {\n        if (logger) logger.error(\"INVALID:  IC section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 4);\n    if (!ss) {\n        if (logger) logger.error(\"Coeffs section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 5);\n    if (!ss) {\n        if (logger) logger.error(\"A section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 6);\n    if (!ss) {\n        if (logger) logger.error(\"B1 section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 7);\n    if (!ss) {\n        if (logger) logger.error(\"B2 section is not identical\");\n        return false;\n    }\n\n    // Check L\n    sr = await sectionHasSameRatio(\"G1\", fdInit, sectionsInit, fd, sections, 8, zkey.vk_delta_2, zkeyInit.vk_delta_2, \"L section\");\n    if (sr!==true) {\n        if (logger) logger.error(\"L section does not match\");\n        return false;\n    }\n\n    // Check H\n    sr = await sameRatioH();\n    if (sr!==true) {\n        if (logger) logger.error(\"H section does not match\");\n        return false;\n    }\n\n    if (logger) logger.info(misc.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n\n    await fd.close();\n    await fdInit.close();\n\n    for (let i=mpcParams.contributions.length-1; i>=0; i--) {\n        const c = mpcParams.contributions[i];\n        if (logger) logger.info(\"-------------------------\");\n        if (logger) logger.info(misc.formatHash(c.contributionHash, `contribution #${i+1} ${c.name ? c.name : \"\"}:`));\n        if (c.type == 1) {\n            if (logger) logger.info(`Beacon generator: ${misc.byteArray2hex(c.beaconHash)}`);\n            if (logger) logger.info(`Beacon iterations Exp: ${c.numIterationsExp}`);\n        }\n    }\n    if (logger) logger.info(\"-------------------------\");\n\n    if (logger) logger.info(\"ZKey Ok!\");\n\n    return true;\n\n\n    async function sectionHasSameRatio(groupName, fd1, sections1, fd2, sections2, idSection, g2sp, g2spx, sectionName) {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await binFileUtils.startReadUniqueSection(fd1, sections1, idSection);\n        await binFileUtils.startReadUniqueSection(fd2, sections2, idSection);\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        const nPoints = sections1[idSection][0].size / sG;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`Same ratio check ${sectionName}:  ${i}/${nPoints}`);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases1 = await fd1.read(n*sG);\n            const bases2 = await fd2.read(n*sG);\n\n            const scalars = new Uint8Array(4*n);\n            crypto.randomFillSync(scalars);\n\n\n            const r1 = await G.multiExpAffine(bases1, scalars);\n            const r2 = await G.multiExpAffine(bases2, scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n        }\n        await binFileUtils.endReadSection(fd1);\n        await binFileUtils.endReadSection(fd2);\n\n        if (nPoints == 0) return true;\n\n        sr = await sameRatio(curve, R1, R2, g2sp, g2spx);\n        if (sr !== true) return false;\n\n        return true;\n    }\n\n    async function sameRatioH() {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve.G1;\n        const Fr = curve.Fr;\n        const sG = G.F.n8*2;\n\n        const {fd: fdPTau, sections: sectionsPTau} = await binFileUtils.readBinFile(pTauFileName, \"ptau\", 1);\n\n        let buff_r = new BigBuffer(zkey.domainSize * zkey.n8r);\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = crypto.randomBytes(4).readUInt32BE(0, true);\n        }\n        const rng = new ChaCha(seed);\n        for (let i=0; i<zkey.domainSize-1; i++) {   // Note that last one is zero\n            const e = Fr.fromRng(rng);\n            Fr.toRprLE(buff_r, i*zkey.n8r, e);\n        }\n        Fr.toRprLE(buff_r, (zkey.domainSize-1)*zkey.n8r, Fr.zero);\n\n        let R1 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verificaition(tau):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff1 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + zkey.domainSize*sG + i*sG);\n            const buff2 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + i*sG);\n\n            const buffB = await batchSubstract(buff1, buff2);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buffB, buffS);\n\n            R1 = G.add(R1, r);\n        }\n\n        // Caluclate odd coeficients in transformed domain\n\n        buff_r = await Fr.batchToMontgomery(buff_r);\n        // const first = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n        // Works*2   const first = curve.Fr.neg(curve.Fr.e(2));\n\n\n        let first;\n\n        if (zkey.power < Fr.s) {\n            first = Fr.neg(Fr.e(2));\n        } else {\n            const small_m  = 2 ** Fr.s;\n            const shift_to_small_m = Fr.exp(Fr.shift, small_m);\n            first = Fr.sub( shift_to_small_m, Fr.one);\n        }\n\n        // const inc = curve.Fr.inv(curve.PFr.w[zkey.power+1]);\n        const inc = zkey.power < Fr.s ? Fr.w[zkey.power+1] : Fr.shift;\n        buff_r = await Fr.batchApplyKey(buff_r, first, inc);\n        buff_r = await Fr.fft(buff_r);\n        buff_r = await Fr.batchFromMontgomery(buff_r);\n\n        await binFileUtils.startReadUniqueSection(fd, sections, 9);\n        let R2 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verificaition(lagrange):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff = await fd.read(sG*n);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buff, buffS);\n\n            R2 = G.add(R2, r);\n        }\n        await binFileUtils.endReadSection(fd);\n\n        sr = await sameRatio(curve, R1, R2, zkey.vk_delta_2, zkeyInit.vk_delta_2);\n        if (sr !== true) return false;\n\n\n        return true;\n\n    }\n\n    async function batchSubstract(buff1, buff2) {\n        const sG = curve.G1.F.n8*2;\n        const nPoints = buff1.byteLength / sG;\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(batchSubstractThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        const fullBuffOut = new Uint8Array(nPoints*sG);\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    }\n\n\n    async function batchSubstractThread(buff1, buff2) {\n        const sG1 = curve.G1.F.n8*2;\n        const sGmid = curve.G1.F.n8*3;\n        const nPoints = buff1.byteLength/sG1;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n}\n\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport * as misc from \"./misc.js\";\nimport Blake2b from \"blake2b-wasm\";\nimport * as utils from \"./zkey_utils.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\nimport { applyKeyToSection } from \"./mpc_applykey.js\";\n\nexport default async function phase2contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger) {\n    await Blake2b.ready();\n\n    const {fd: fdOld, sections: sections} = await binFileUtils.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fdOld, sections);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkey.q);\n\n    const mpcParams = await zkeyUtils.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await binFileUtils.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n\n    const rng = await misc.getRandomRng(entropy);\n\n    const transcriptHasher = Blake2b(64);\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        utils.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 0;\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await zkeyUtils.writeHeader(fdNew, zkey);\n\n    // IC\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await applyKeyToSection(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await applyKeyToSection(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await zkeyUtils.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = Blake2b(64);\n    utils.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contribuionHash = contributionHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n    if (logger) logger.info(misc.formatHash(contribuionHash, \"Contribution Hash: \"));\n\n    return contribuionHash;\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport * as misc from \"./misc.js\";\nimport Blake2b from \"blake2b-wasm\";\nimport * as utils from \"./zkey_utils.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\nimport { applyKeyToSection } from \"./mpc_applykey.js\";\n\n\nexport default async function beacon(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger) {\n    await Blake2b.ready();\n\n    const beaconHash = misc.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum lenght of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections: sections} = await binFileUtils.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fdOld, sections);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n\n    const curve = await getCurve(zkey.q);\n\n    const mpcParams = await zkeyUtils.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await binFileUtils.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n    const rng = await misc.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const transcriptHasher = Blake2b(64);\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        utils.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 1;\n    curContribution.numIterationsExp = numIterationsExp;\n    curContribution.beaconHash = beaconHash;\n\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await zkeyUtils.writeHeader(fdNew, zkey);\n\n    // IC\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await applyKeyToSection(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await applyKeyToSection(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await zkeyUtils.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = Blake2b(64);\n    utils.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contribuionHash = contributionHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(contribuionHash, \"Contribution Hash: \"));\n\n    return contribuionHash;\n}\n", "import { readZKey as readZKey } from \"./zkey_utils.js\";\nimport { utils } from \"ffjavascript\";\n\nexport default async function zkeyExportJson(zkeyFileName) {\n\n    const zKey = await readZKey(zkeyFileName, true);\n    delete zKey.curve;\n    delete zKey.F;\n\n    return utils.stringifyBigInts(zKey);\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\nimport * as fastFile from \"fastfile\";\nimport Blake2b from \"blake2b-wasm\";\nimport * as utils from \"./zkey_utils.js\";\nimport * as misc from \"./misc.js\";\nimport { applyKeyToChallengeSection } from \"./mpc_applykey.js\";\nimport { hashPubKey } from \"./zkey_utils.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\n\nexport default async function bellmanContribute(curve, challengeFilename, responesFileName, entropy, logger) {\n    await Blake2b.ready();\n\n    const rng = await misc.getRandomRng(entropy);\n\n    const delta = curve.Fr.fromRng(rng);\n    const invDelta = curve.Fr.inv(delta);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const fdFrom = await fastFile.readExisting(challengeFilename);\n    const fdTo = await fastFile.createOverride(responesFileName);\n\n\n    await copy(sG1); // alpha1\n    await copy(sG1); // beta1\n    await copy(sG2); // beta2\n    await copy(sG2); // gamma2\n    const oldDelta1 = await readG1();\n    const delta1 = curve.G1.timesFr(oldDelta1, delta);\n    await writeG1(delta1);\n    const oldDelta2 = await readG2();\n    const delta2 = curve.G2.timesFr(oldDelta2, delta);\n    await writeG2(delta2);\n\n    // IC\n    const nIC = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nIC);\n    await copy(nIC*sG1);\n\n    // H\n    const nH = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nH);\n    await applyKeyToChallengeSection(fdFrom, fdTo, null, curve, \"G1\", nH, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"H\", logger);\n\n    // L\n    const nL = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nL);\n    await applyKeyToChallengeSection(fdFrom, fdTo, null, curve, \"G1\", nL, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"L\", logger);\n\n    // A\n    const nA = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nA);\n    await copy(nA*sG1);\n\n    // B1\n    const nB1 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB1);\n    await copy(nB1*sG1);\n\n    // B2\n    const nB2 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB2);\n    await copy(nB2*sG2);\n\n\n    //////////\n    /// Read contributions\n    //////////\n    const transcriptHasher = Blake2b(64);\n\n    const mpcParams = {};\n    // csHash\n    mpcParams.csHash =  await fdFrom.read(64);\n    transcriptHasher.update(mpcParams.csHash);\n\n    const nConttributions = await fdFrom.readUBE32();\n    mpcParams.contributions = [];\n    for (let i=0; i<nConttributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1();\n        c.delta.g1_s = await readG1();\n        c.delta.g1_sx = await readG1();\n        c.delta.g2_spx = await readG2();\n        c.transcript = await fdFrom.read(64);\n        mpcParams.contributions.push(c);\n        hashPubKey(transcriptHasher, curve, c);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = delta;\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, delta));\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, delta));\n    curContribution.deltaAfter = delta1;\n    curContribution.type = 0;\n    mpcParams.contributions.push(curContribution);\n\n\n    //////////\n    /// Write COntribution\n    //////////\n\n    await fdTo.write(mpcParams.csHash);\n    await fdTo.writeUBE32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdTo.write(c.transcript);\n    }\n\n    const contributionHasher = Blake2b(64);\n    hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n\n    return contributionHash;\n\n    async function copy(nBytes) {\n        const CHUNK_SIZE = fdFrom.pageSize*2;\n        for (let i=0; i<nBytes; i+= CHUNK_SIZE) {\n            const n = Math.min(nBytes -i, CHUNK_SIZE);\n            const buff = await fdFrom.read(n);\n            await fdTo.write(buff);\n        }\n    }\n\n    async function readG1() {\n        const buff = await fdFrom.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2() {\n        const buff = await fdFrom.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport { utils } from \"ffjavascript\";\nconst {stringifyBigInts} = utils;\n\nexport default async function zkeyExportVerificationKey(zkeyName, /* logger */ ) {\n\n    const {fd, sections} = await binFileUtils.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fd, sections);\n\n    let res;\n    if (zkey.protocol == \"groth16\") {\n        res = await groth16Vk(zkey, fd, sections);\n    } else if (zkey.protocol == \"plonk\") {\n        res = await plonkVk(zkey);\n    } else {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    await fd.close();\n\n    return res;\n}\n\n\nasync function groth16Vk(zkey, fd, sections) {\n    const curve = await getCurve(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n\n    const alphaBeta = await curve.pairing( zkey.vk_alpha_1 , zkey.vk_beta_2 );\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n\n        vk_alpha_1: curve.G1.toObject(zkey.vk_alpha_1),\n\n        vk_beta_2: curve.G2.toObject(zkey.vk_beta_2),\n        vk_gamma_2:  curve.G2.toObject(zkey.vk_gamma_2),\n        vk_delta_2:  curve.G2.toObject(zkey.vk_delta_2),\n\n        vk_alphabeta_12: curve.Gt.toObject(alphaBeta)\n    };\n\n    // Read IC Section\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 3);\n    vKey.IC = [];\n    for (let i=0; i<= zkey.nPublic; i++) {\n        const buff = await fd.read(sG1);\n        const P = curve.G1.toObject(buff);\n        vKey.IC.push(P);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\n\nasync function plonkVk(zkey) {\n    const curve = await getCurve(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        Qm: curve.G1.toObject(zkey.Qm),\n        Ql: curve.G1.toObject(zkey.Ql),\n        Qr: curve.G1.toObject(zkey.Qr),\n        Qo: curve.G1.toObject(zkey.Qo),\n        Qc: curve.G1.toObject(zkey.Qc),\n        S1: curve.G1.toObject(zkey.S1),\n        S2: curve.G1.toObject(zkey.S2),\n        S3: curve.G1.toObject(zkey.S3),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power])\n    };\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n", "import * as fastFile from \"fastfile\";\nimport ejs from \"ejs\";\n\nimport exportVerificationKey from \"./zkey_export_verificationkey.js\";\n// Not ready yet\n// module.exports.generateVerifier_kimleeoh = generateVerifier_kimleeoh;\n\n\n\nexport default async function exportSolidityVerifier(zKeyName, templates, logger) {\n\n    const verificationKey = await exportVerificationKey(zKeyName, logger);\n\n    let template = templates[verificationKey.protocol];\n\n    return ejs.render(template ,  verificationKey);\n}\n", "/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport {default as setup} from \"./plonk_setup.js\";\nexport {default as fullProve} from \"./plonk_fullprove.js\";\nexport {default as prove} from \"./plonk_prove.js\";\nexport {default as verify} from \"./plonk_verify.js\";\nexport {default as exportSolidityCallData} from \"./plonk_exportsoliditycalldata.js\";\n", "/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\nimport {readR1csFd} from \"r1csfile\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport {\n    readBinFile,\n    createBinFile,\n    readSection,\n    writeBigInt,\n    startWriteSection,\n    endWriteSection,\n} from \"@iden3/binfileutils\";\nimport { log2  } from \"./misc.js\";\nimport { Scalar, BigBuffer } from \"ffjavascript\";\nimport Blake2b from \"blake2b-wasm\";\nimport BigArray from \"./bigarray.js\";\n\n\nexport default async function plonkSetup(r1csName, ptauName, zkeyName, logger) {\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    await Blake2b.ready();\n\n    const {fd: fdPTau, sections: sectionsPTau} = await readBinFile(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await utils.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await readBinFile(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n\n    const r1cs = await readR1csFd(fdR1cs, sectionsR1cs, {loadConstraints: true, loadCustomGates: true});\n\n    const sG1 = curve.G1.F.n8*2;\n    const G1 = curve.G1;\n    const sG2 = curve.G2.F.n8*2;\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await readSection(fdR1cs, sectionsR1cs, 2);\n\n    const plonkConstraints = new BigArray();\n    const plonkAdditions = new BigArray();\n    let plonkNVars = r1cs.nVars;\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n\n    await processConstraints(curve.Fr, r1cs, logger);\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const fdZKey = await createBinFile(zkeyName, \"zkey\", 1, 14, 1<<22, 1<<24);\n\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    let cirPower = log2(plonkConstraints.length -1) +1;\n    if (cirPower < 3) cirPower = 3;   // As the t polinomal is n+5 whe need at least a power of 4\n    const domainSize = 2 ** cirPower;\n\n    if (logger) logger.info(\"Plonk constraints: \" + plonkConstraints.length);\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${plonkConstraints.length} > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n\n    const LPoints = new BigBuffer(domainSize*sG1);\n    const o = sectionsPTau[12][0].p + ((2 ** (cirPower)) -1)*sG1;\n    await fdPTau.readToBuffer(LPoints, 0, domainSize*sG1, o);\n\n    const [k1, k2] = getK1K2();\n\n    const vk = {};\n\n\n    await writeAdditions(3, \"Additions\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(4, 0, \"Amap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(5, 1, \"Bmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(6, 2, \"Cmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(7, 3, \"Qm\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(8, 4, \"Ql\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(9, 5, \"Qr\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(10, 6, \"Qo\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(11, 7, \"Qc\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeSigma(12, \"sigma\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeLs(13, \"lagrange polynomials\");\n    if (globalThis.gc) {globalThis.gc();}\n\n    // Write PTau points\n    ////////////\n\n    await startWriteSection(fdZKey, 14);\n    const buffOut = new BigBuffer((domainSize+6)*sG1);\n    await fdPTau.readToBuffer(buffOut, 0, (domainSize+6)*sG1, sectionsPTau[2][0].p);\n    await fdZKey.write(buffOut);\n    await endWriteSection(fdZKey);\n    if (globalThis.gc) {globalThis.gc();}\n\n\n    await writeHeaders();\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"Setup Finished\");\n\n    return ;\n\n    async function processConstraints(Fr, r1cs, logger) {\n\n        function normalize(linearComb) {\n            const ss = Object.keys(linearComb);\n            for (let i = 0; i < ss.length; i++) {\n                if (linearComb[ss[i]] == 0n) delete linearComb[ss[i]];\n            }\n        }\n\n        function join(linearComb1, k, linearComb2) {\n            const res = {};\n\n            for (let s in linearComb1) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = Fr.mul(k, linearComb1[s]);\n                } else {\n                    res[s] = Fr.add(res[s], Fr.mul(k, linearComb1[s]));\n                }\n            }\n\n            for (let s in linearComb2) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = linearComb2[s];\n                } else {\n                    res[s] = Fr.add(res[s], linearComb2[s]);\n                }\n            }\n            normalize(res);\n            return res;\n        }\n\n        function reduceCoefs(linearComb, maxC) {\n            const res = {\n                k: Fr.zero,\n                s: [],\n                coefs: []\n            };\n            const cs = [];\n\n            for (let s in linearComb) {\n                if (s == 0) {\n                    res.k = Fr.add(res.k, linearComb[s]);\n                } else if (linearComb[s] != 0n) {\n                    cs.push([Number(s), linearComb[s]])\n                }\n            }\n            while (cs.length > maxC) {\n                const c1 = cs.shift();\n                const c2 = cs.shift();\n\n                const sl = c1[0];\n                const sr = c2[0];\n                const so = plonkNVars++;\n                const qm = Fr.zero;\n                const ql = Fr.neg(c1[1]);\n                const qr = Fr.neg(c2[1]);\n                const qo = Fr.one;\n                const qc = Fr.zero;\n\n                plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n\n                plonkAdditions.push([sl, sr, c1[1], c2[1]]);\n\n                cs.push([so, Fr.one]);\n            }\n            for (let i = 0; i < cs.length; i++) {\n                res.s[i] = cs[i][0];\n                res.coefs[i] = cs[i][1];\n            }\n            while (res.coefs.length < maxC) {\n                res.s.push(0);\n                res.coefs.push(Fr.zero);\n            }\n            return res;\n        }\n\n        function addConstraintSum(lc) {\n            const C = reduceCoefs(lc, 3);\n            const sl = C.s[0];\n            const sr = C.s[1];\n            const so = C.s[2];\n            const qm = Fr.zero;\n            const ql = C.coefs[0];\n            const qr = C.coefs[1];\n            const qo = C.coefs[2];\n            const qc = C.k;\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function addConstraintMul(lcA, lcB, lcC) {\n            const A = reduceCoefs(lcA, 1);\n            const B = reduceCoefs(lcB, 1);\n            const C = reduceCoefs(lcC, 1);\n\n\n            const sl = A.s[0];\n            const sr = B.s[0];\n            const so = C.s[0];\n            const qm = Fr.mul(A.coefs[0], B.coefs[0]);\n            const ql = Fr.mul(A.coefs[0], B.k);\n            const qr = Fr.mul(A.k, B.coefs[0]);\n            const qo = Fr.neg(C.coefs[0]);\n            const qc = Fr.sub(Fr.mul(A.k, B.k), C.k);\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function getLinearCombinationType(lc) {\n            let k = Fr.zero;\n            let n = 0;\n            const ss = Object.keys(lc);\n            for (let i = 0; i < ss.length; i++) {\n                if (lc[ss[i]] == 0n) {\n                    delete lc[ss[i]];\n                } else if (ss[i] == 0) {\n                    k = Fr.add(k, lc[ss[i]]);\n                } else {\n                    n++;\n                }\n            }\n            if (n > 0) return n.toString();\n            if (k != Fr.zero) return \"k\";\n            return \"0\";\n        }\n\n        function process(lcA, lcB, lcC) {\n            const lctA = getLinearCombinationType(lcA);\n            const lctB = getLinearCombinationType(lcB);\n            if ((lctA === \"0\") || (lctB === \"0\")) {\n                normalize(lcC);\n                addConstraintSum(lcC);\n            } else if (lctA === \"k\") {\n                const lcCC = join(lcB, lcA[0], lcC);\n                addConstraintSum(lcCC);\n            } else if (lctB === \"k\") {\n                const lcCC = join(lcA, lcB[0], lcC);\n                addConstraintSum(lcCC);\n            } else {\n                addConstraintMul(lcA, lcB, lcC);\n            }\n        }\n\n        for (let s = 1; s <= nPublic; s++) {\n            const sl = s;\n            const sr = 0;\n            const so = 0;\n            const qm = Fr.zero;\n            const ql = Fr.one;\n            const qr = Fr.zero;\n            const qo = Fr.zero;\n            const qc = Fr.zero;\n\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        for (let c = 0; c < r1cs.constraints.length; c++) {\n            if ((logger) && (c % 10000 === 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            process(...r1cs.constraints[c]);\n        }\n    }\n\n    async function writeWitnessMap(sectionNum, posConstraint, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeQMap(sectionNum, posConstraint, name) {\n        let Q = new BigBuffer(domainSize*n8r);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i*n8r);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await startWriteSection(fdZKey, sectionNum);\n        await writeP4(Q);\n        await endWriteSection(fdZKey);\n        Q = await Fr.batchFromMontgomery(Q);\n        vk[name]= await curve.G1.multiExpAffine(LPoints, Q, logger, \"multiexp \"+name);\n    }\n\n    async function writeP4(buff) {\n        const q = await Fr.ifft(buff);\n        const q4 = new BigBuffer(domainSize*n8r*4);\n        q4.set(q, 0);\n        const Q4 = await Fr.fft(q4);\n        await fdZKey.write(q);\n        await fdZKey.write(Q4);\n    }\n\n    async function writeAdditions(sectionNum, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        const buffOut = new Uint8Array((2*4+2*n8r));\n        const buffOutV = new DataView(buffOut.buffer);\n        for (let i=0; i<plonkAdditions.length; i++) {\n            const addition=plonkAdditions[i];\n            let o=0;\n            buffOutV.setUint32(o, addition[0], true); o+=4;\n            buffOutV.setUint32(o, addition[1], true); o+=4;\n            // The value is storen in  Montgomery. stored = v*R\n            // so when montgomery multiplicated by the witness  it result = v*R*w/R = v*w \n            buffOut.set(addition[2], o); o+= n8r;\n            buffOut.set(addition[3], o); o+= n8r;\n            await fdZKey.write(buffOut);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkAdditions.length}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeSigma(sectionNum, name) {\n        const sigma = new BigBuffer(n8r*domainSize*3);\n        const lastAparence =  new BigArray(plonkNVars);\n        const firstPos = new BigArray(plonkNVars);\n        let w = Fr.one;\n        for (let i=0; i<domainSize;i++) {\n            if (i<plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], domainSize + i);\n                buildSigma(plonkConstraints[i][2], domainSize*2 + i);\n            } else {\n                buildSigma(0, i);\n                buildSigma(0, domainSize + i);\n                buildSigma(0, domainSize*2 + i);\n            }\n            w = Fr.mul(w, Fr.w[cirPower]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name} phase1: ${i}/${plonkConstraints.length}`);\n        }\n        for (let s=0; s<plonkNVars; s++) {\n            if (typeof firstPos[s] !== \"undefined\") {\n                sigma.set(lastAparence[s], firstPos[s]*n8r);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger)&&(s%1000000 == 0)) logger.debug(`writing ${name} phase2: ${s}/${plonkNVars}`);\n        }\n\n        if (globalThis.gc) {globalThis.gc();}\n        await startWriteSection(fdZKey, sectionNum);\n        let S1 = sigma.slice(0, domainSize*n8r);\n        await writeP4(S1);\n        if (globalThis.gc) {globalThis.gc();}\n        let S2 = sigma.slice(domainSize*n8r, domainSize*n8r*2);\n        await writeP4(S2);\n        if (globalThis.gc) {globalThis.gc();}\n        let S3 = sigma.slice(domainSize*n8r*2, domainSize*n8r*3);\n        await writeP4(S3);\n        if (globalThis.gc) {globalThis.gc();}\n        await endWriteSection(fdZKey);\n\n        S1 = await Fr.batchFromMontgomery(S1);\n        S2 = await Fr.batchFromMontgomery(S2);\n        S3 = await Fr.batchFromMontgomery(S3);\n\n        vk.S1= await curve.G1.multiExpAffine(LPoints, S1, logger, \"multiexp S1\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S2= await curve.G1.multiExpAffine(LPoints, S2, logger, \"multiexp S2\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S3= await curve.G1.multiExpAffine(LPoints, S3, logger, \"multiexp S3\");\n        if (globalThis.gc) {globalThis.gc();}\n\n        function buildSigma(s, p) {\n            if (typeof lastAparence[s] === \"undefined\") {\n                firstPos[s] = p;\n            } else {\n                sigma.set(lastAparence[s], p*n8r);\n            }\n            let v;\n            if (p<domainSize) {\n                v = w;\n            } else if (p<2*domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n            lastAparence[s]=v;\n        }\n    }\n\n    async function writeLs(sectionNum, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        const l=Math.max(nPublic, 1);\n        for (let i=0; i<l; i++) {\n            let buff = new BigBuffer(domainSize*n8r);\n            buff.set(Fr.one, i*n8r);\n            await writeP4(buff);\n            if (logger) logger.debug(`writing ${name} ${i}/${l}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeHeaders() {\n\n        // Write the header\n        ///////////\n        await startWriteSection(fdZKey, 1);\n        await fdZKey.writeULE32(2); // Plonk\n        await endWriteSection(fdZKey);\n\n        // Write the Plonk header section\n        ///////////\n\n        await startWriteSection(fdZKey, 2);\n        const primeQ = curve.q;\n        const n8q = (Math.floor( (Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n        const primeR = curve.r;\n        const n8r = (Math.floor( (Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n        await fdZKey.writeULE32(n8q);\n        await writeBigInt(fdZKey, primeQ, n8q);\n        await fdZKey.writeULE32(n8r);\n        await writeBigInt(fdZKey, primeR, n8r);\n        await fdZKey.writeULE32(plonkNVars);                         // Total number of bars\n        await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n        await fdZKey.writeULE32(domainSize);                  // domainSize\n        await fdZKey.writeULE32(plonkAdditions.length);                  // domainSize\n        await fdZKey.writeULE32(plonkConstraints.length); \n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(G1.toAffine(vk.Qm));\n        await fdZKey.write(G1.toAffine(vk.Ql));\n        await fdZKey.write(G1.toAffine(vk.Qr));\n        await fdZKey.write(G1.toAffine(vk.Qo));\n        await fdZKey.write(G1.toAffine(vk.Qc));\n\n        await fdZKey.write(G1.toAffine(vk.S1));\n        await fdZKey.write(G1.toAffine(vk.S2));\n        await fdZKey.write(G1.toAffine(vk.S3));\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, sectionsPTau[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        await endWriteSection(fdZKey);\n    }\n\n    function getK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize= 2**pow;\n            let w = Fr.one;\n            for (let i=0; i<domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j=0; j<kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n}\n\n\n", "/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport plonk_prove from \"./plonk_prove.js\";\nimport wtns_calculate from \"./wtns_calculate.js\";\nimport {utils} from 'ffjavascript';\nconst {unstringifyBigInts} = utils;\n\nexport default async function plonkFullProve(_input, wasmFile, zkeyFileName, logger) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await wtns_calculate(input, wasmFile, wtns);\n    return await plonk_prove(zkeyFileName, wtns, logger);\n}\n", "/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf section 8.4 */\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport { Scalar, utils, BigBuffer } from \"ffjavascript\";\nconst {stringifyBigInts} = utils;\nimport jsSha3 from \"js-sha3\";\nconst { keccak256 } = jsSha3;\n\nexport default async function plonk16Prove(zkeyFileName, witnessFileName, logger) {\n    const {fd: fdWtns, sections: sectionsWtns} = await binFileUtils.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    const wtns = await wtnsUtils.readHeader(fdWtns, sectionsWtns);\n\n    const {fd: fdZKey, sections: sectionsZKey} = await binFileUtils.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await zkeyUtils.readHeader(fdZKey, sectionsZKey);\n    if (zkey.protocol != \"plonk\") {\n        throw new Error(\"zkey file is not plonk\");\n    }\n\n    if (!Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars -zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n    const n8r = curve.Fr.n8;\n\n    if (logger) logger.debug(\"Reading Wtns\");\n    const buffWitness = await binFileUtils.readSection(fdWtns, sectionsWtns, 2);\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new BigBuffer(n8r*zkey.nAdditions);\n\n    await calculateAdditions();\n\n    let A,B,C,Z;\n    let A4, B4, C4, Z4;\n    let pol_a,pol_b,pol_c, pol_z, pol_t, pol_r;\n    let proof = {};\n\n    const sigmaBuff = new BigBuffer(zkey.domainSize*n8r*4*3);\n    let o = sectionsZKey[12][0].p + zkey.domainSize*n8r;\n    await fdZKey.readToBuffer(sigmaBuff, 0 , zkey.domainSize*n8r*4, o);\n    o += zkey.domainSize*n8r*5;\n    await fdZKey.readToBuffer(sigmaBuff, zkey.domainSize*n8r*4 , zkey.domainSize*n8r*4, o);\n    o += zkey.domainSize*n8r*5;\n    await fdZKey.readToBuffer(sigmaBuff, zkey.domainSize*n8r*8 , zkey.domainSize*n8r*4, o);\n\n    const pol_s1 = new BigBuffer(zkey.domainSize*n8r);\n    await fdZKey.readToBuffer(pol_s1, 0 , zkey.domainSize*n8r, sectionsZKey[12][0].p);\n\n    const pol_s2 = new BigBuffer(zkey.domainSize*n8r);\n    await fdZKey.readToBuffer(pol_s2, 0 , zkey.domainSize*n8r, sectionsZKey[12][0].p + 5*zkey.domainSize*n8r);\n\n    const PTau = await binFileUtils.readSection(fdZKey, sectionsZKey, 14);\n\n\n    const ch = {};\n\n    await round1();\n    await round2();\n    await round3();\n    await round4();\n    await round5();\n\n\n    ///////////////////////\n    // Final adjustments //\n    ///////////////////////\n\n    proof.protocol = \"plonk\";\n    proof.curve = curve.name;\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const pub = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(Scalar.fromRprLE(pub));\n    }\n\n    proof.A = G1.toObject(proof.A);\n    proof.B = G1.toObject(proof.B);\n    proof.C = G1.toObject(proof.C);\n    proof.Z = G1.toObject(proof.Z);\n\n    proof.T1 = G1.toObject(proof.T1);\n    proof.T2 = G1.toObject(proof.T2);\n    proof.T3 = G1.toObject(proof.T3);\n\n    proof.eval_a = Fr.toObject(proof.eval_a);\n    proof.eval_b = Fr.toObject(proof.eval_b);\n    proof.eval_c = Fr.toObject(proof.eval_c);\n    proof.eval_s1 = Fr.toObject(proof.eval_s1);\n    proof.eval_s2 = Fr.toObject(proof.eval_s2);\n    proof.eval_zw = Fr.toObject(proof.eval_zw);\n    proof.eval_t = Fr.toObject(proof.eval_t);\n    proof.eval_r = Fr.toObject(proof.eval_r);\n\n    proof.Wxi = G1.toObject(proof.Wxi);\n    proof.Wxiw = G1.toObject(proof.Wxiw);\n\n    delete proof.eval_t;\n\n    proof = stringifyBigInts(proof);\n    publicSignals = stringifyBigInts(publicSignals);\n\n    return {proof, publicSignals};\n\n    async function calculateAdditions() {\n        const additionsBuff = await binFileUtils.readSection(fdZKey, sectionsZKey, 3);\n\n        const sSum = 8+curve.Fr.n8*2;\n\n        for (let i=0; i<zkey.nAdditions; i++) {\n            const ai= readUInt32(additionsBuff, i*sSum);\n            const bi= readUInt32(additionsBuff, i*sSum+4);\n            const ac= additionsBuff.slice(i*sSum+8, i*sSum+8+n8r);\n            const bc= additionsBuff.slice(i*sSum+8+n8r, i*sSum+8+n8r*2);\n            const aw= getWitness(ai);\n            const bw= getWitness(bi);\n\n            const r = curve.Fr.add(\n                curve.Fr.mul(ac, aw),\n                curve.Fr.mul(bc, bw)\n            );\n            buffInternalWitness.set(r, n8r*i);\n        }\n\n    }\n\n    async function buildABC() {\n        let A = new BigBuffer(zkey.domainSize * n8r);\n        let B = new BigBuffer(zkey.domainSize * n8r);\n        let C = new BigBuffer(zkey.domainSize * n8r);\n\n        const aMap = await binFileUtils.readSection(fdZKey, sectionsZKey, 4);\n        const bMap = await binFileUtils.readSection(fdZKey, sectionsZKey, 5);\n        const cMap = await binFileUtils.readSection(fdZKey, sectionsZKey, 6);\n\n        for (let i=0; i<zkey.nConstrains; i++) {\n            const iA = readUInt32(aMap, i*4);\n            A.set(getWitness(iA), i*n8r);\n            const iB = readUInt32(bMap, i*4);\n            B.set(getWitness(iB), i*n8r);\n            const iC = readUInt32(cMap, i*4);\n            C.set(getWitness(iC), i*n8r);\n        }\n\n        A = await Fr.batchToMontgomery(A);\n        B = await Fr.batchToMontgomery(B);\n        C = await Fr.batchToMontgomery(C);\n\n        return [A,B,C];\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o+4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        if (idx < zkey.nVars-zkey.nAdditions) {\n            return buffWitness.slice(idx*n8r, idx*n8r+n8r);\n        } else if (idx < zkey.nVars) {\n            return buffInternalWitness.slice((idx - (zkey.nVars-zkey.nAdditions))*n8r, (idx-(zkey.nVars-zkey.nAdditions))*n8r + n8r);\n        } else {\n            return curve.Fr.zero;\n        }\n    }\n\n    async function round1() {\n        ch.b = [];\n        for (let i=1; i<=11; i++) {\n            ch.b[i] = curve.Fr.random();\n        }\n    \n        [A, B, C] = await buildABC();\n\n        [pol_a, A4] = await to4T(A, [ch.b[2], ch.b[1]]);\n        [pol_b, B4] = await to4T(B, [ch.b[4], ch.b[3]]);\n        [pol_c, C4] = await to4T(C, [ch.b[6], ch.b[5]]);\n\n                \n        proof.A = await expTau(pol_a, \"multiexp A\");\n        proof.B = await expTau(pol_b, \"multiexp B\");\n        proof.C = await expTau(pol_c, \"multiexp C\");\n    }\n\n    async function round2() {\n\n        const transcript1 = new Uint8Array(zkey.nPublic*n8r + G1.F.n8*2*3);\n        for (let i=0; i<zkey.nPublic; i++) {\n            Fr.toRprBE(transcript1, i*n8r, A.slice((i)*n8r, (i+1)*n8r));\n        }\n        G1.toRprUncompressed(transcript1, zkey.nPublic*n8r + 0, proof.A);\n        G1.toRprUncompressed(transcript1, zkey.nPublic*n8r + G1.F.n8*2, proof.B);\n        G1.toRprUncompressed(transcript1, zkey.nPublic*n8r + G1.F.n8*4, proof.C);\n\n        ch.beta = hashToFr(transcript1);\n        if (logger) logger.debug(\"beta: \" + Fr.toString(ch.beta));\n    \n        const transcript2 = new Uint8Array(n8r);\n        Fr.toRprBE(transcript2, 0, ch.beta);\n        ch.gamma = hashToFr(transcript2);\n        if (logger) logger.debug(\"gamma: \" + Fr.toString(ch.gamma));\n    \n        let numArr = new BigBuffer(Fr.n8*zkey.domainSize);\n        let denArr = new BigBuffer(Fr.n8*zkey.domainSize);\n\n        numArr.set(Fr.one, 0);\n        denArr.set(Fr.one, 0);\n\n        let w = Fr.one;\n        for (let i=0; i<zkey.domainSize; i++) {\n            let n1 = A.slice(i*n8r, (i+1)*n8r);\n            n1 = Fr.add( n1, Fr.mul(ch.beta, w) );\n            n1 = Fr.add( n1, ch.gamma );\n\n            let n2 = B.slice(i*n8r, (i+1)*n8r);\n            n2 = Fr.add( n2, Fr.mul(zkey.k1, Fr.mul(ch.beta, w) ));\n            n2 = Fr.add( n2, ch.gamma );\n\n            let n3 = C.slice(i*n8r, (i+1)*n8r);\n            n3 = Fr.add( n3, Fr.mul(zkey.k2, Fr.mul(ch.beta, w) ));\n            n3 = Fr.add( n3, ch.gamma );\n\n            const num = Fr.mul(n1, Fr.mul(n2, n3));\n\n            let d1 = A.slice(i*n8r, (i+1)*n8r);\n            d1 = Fr.add(d1, Fr.mul( sigmaBuff.slice(i*n8r*4, i*n8r*4 + n8r) , ch.beta));\n            d1 = Fr.add(d1, ch.gamma);\n\n            let d2 = B.slice(i*n8r, (i+1)*n8r);\n            d2 = Fr.add(d2, Fr.mul( sigmaBuff.slice((zkey.domainSize + i)*4*n8r, (zkey.domainSize + i)*4*n8r+n8r) , ch.beta));\n            d2 = Fr.add(d2, ch.gamma);\n\n            let d3 = C.slice(i*n8r, (i+1)*n8r);\n            d3 = Fr.add(d3, Fr.mul( sigmaBuff.slice((zkey.domainSize*2 + i)*4*n8r, (zkey.domainSize*2 + i)*4*n8r + n8r) , ch.beta));\n            d3 = Fr.add(d3, ch.gamma);\n\n            const den = Fr.mul(d1, Fr.mul(d2, d3));\n\n            numArr.set(  \n                Fr.mul( \n                    numArr.slice(i*n8r,(i+1)*n8r) , \n                    num\n                ),\n                ((i+1)%zkey.domainSize)*n8r\n            );\n\n            denArr.set(  \n                Fr.mul( \n                    denArr.slice(i*n8r,(i+1)*n8r) , \n                    den\n                ),\n                ((i+1)%zkey.domainSize)*n8r\n            );\n\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        denArr = await Fr.batchInverse(denArr);\n\n        // TODO: Do it in assembly and in parallel\n        for (let i=0; i<zkey.domainSize; i++) {\n            numArr.set(   Fr.mul( numArr.slice(i*n8r, (i+1)*n8r), denArr.slice(i*n8r, (i+1)*n8r) )      ,i*n8r);\n        }\n\n        if (!Fr.eq(numArr.slice(0, n8r), Fr.one)) {\n            throw new Error(\"Copy constraints does not match\");\n        }\n\n        Z = numArr;\n\n        [pol_z, Z4] = await to4T(Z, [ch.b[9], ch.b[8], ch.b[7]]);\n\n        proof.Z = await expTau( pol_z, \"multiexp Z\");\n    }\n\n    async function round3() {\n\n        /*\n        async function checkDegree(P) {\n            const p = await curve.Fr.ifft(P);\n            let deg = (P.byteLength/n8r)-1;\n            while ((deg>0)&&(Fr.isZero(p.slice(deg*n8r, deg*n8r+n8r)))) deg--;\n            return deg;\n        }\n\n        function printPol(P) {\n            const n=(P.byteLength/n8r);\n            console.log(\"[\");\n            for (let i=0; i<n; i++) {\n                console.log(Fr.toString(P.slice(i*n8r, i*n8r+n8r)));\n            }\n            console.log(\"]\");\n        }\n        */\n\n        if (logger) logger.debug(\"phse3: Reading QM4\");    \n        const QM4 = new BigBuffer(zkey.domainSize*4*n8r);\n        await fdZKey.readToBuffer(QM4, 0 , zkey.domainSize*n8r*4, sectionsZKey[7][0].p + zkey.domainSize*n8r);\n\n        if (logger) logger.debug(\"phse3: Reading QL4\");    \n        const QL4 = new BigBuffer(zkey.domainSize*4*n8r);\n        await fdZKey.readToBuffer(QL4, 0 , zkey.domainSize*n8r*4, sectionsZKey[8][0].p + zkey.domainSize*n8r);\n\n        if (logger) logger.debug(\"phse3: Reading QR4\");    \n        const QR4 = new BigBuffer(zkey.domainSize*4*n8r);\n        await fdZKey.readToBuffer(QR4, 0 , zkey.domainSize*n8r*4, sectionsZKey[9][0].p + zkey.domainSize*n8r);\n\n        if (logger) logger.debug(\"phse3: Reading QO4\");    \n        const QO4 = new BigBuffer(zkey.domainSize*4*n8r);\n        await fdZKey.readToBuffer(QO4, 0 , zkey.domainSize*n8r*4, sectionsZKey[10][0].p + zkey.domainSize*n8r);\n\n        if (logger) logger.debug(\"phse3: Reading QC4\");    \n        const QC4 = new BigBuffer(zkey.domainSize*4*n8r);\n        await fdZKey.readToBuffer(QC4, 0 , zkey.domainSize*n8r*4, sectionsZKey[11][0].p + zkey.domainSize*n8r);\n\n        const lPols = await binFileUtils.readSection(fdZKey, sectionsZKey, 13);\n\n        const transcript3 = new Uint8Array(G1.F.n8*2);\n        G1.toRprUncompressed(transcript3, 0, proof.Z);\n\n        ch.alpha = hashToFr(transcript3);\n\n        if (logger) logger.debug(\"alpha: \" + Fr.toString(ch.alpha));    \n\n\n        const Z1 = [\n            Fr.zero,\n            Fr.add(Fr.e(-1), Fr.w[2]),\n            Fr.e(-2),\n            Fr.sub(Fr.e(-1), Fr.w[2]),\n        ];\n\n        const Z2 = [\n            Fr.zero,\n            Fr.add(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n            Fr.e(4),\n            Fr.sub(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n        ];\n\n        const Z3 = [\n            Fr.zero,\n            Fr.add(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n            Fr.e(-8),\n            Fr.sub(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n        ];\n\n        const T = new BigBuffer(zkey.domainSize*4*n8r);\n        const Tz = new BigBuffer(zkey.domainSize*4*n8r);\n\n        let w = Fr.one;\n        for (let i=0; i<zkey.domainSize*4; i++) {\n            if ((i%4096 == 0)&&(logger)) logger.debug(`calculating t ${i}/${zkey.domainSize*4}`);\n\n            const a = A4.slice(i*n8r, i*n8r+n8r);\n            const b = B4.slice(i*n8r, i*n8r+n8r);\n            const c = C4.slice(i*n8r, i*n8r+n8r);\n            const z = Z4.slice(i*n8r, i*n8r+n8r);\n            const zw = Z4.slice(((i+zkey.domainSize*4+4)%(zkey.domainSize*4)) *n8r, ((i+zkey.domainSize*4+4)%(zkey.domainSize*4)) *n8r +n8r);\n            const qm = QM4.slice(i*n8r, i*n8r+n8r);\n            const ql = QL4.slice(i*n8r, i*n8r+n8r);\n            const qr = QR4.slice(i*n8r, i*n8r+n8r);\n            const qo = QO4.slice(i*n8r, i*n8r+n8r);\n            const qc = QC4.slice(i*n8r, i*n8r+n8r);\n            const s1 = sigmaBuff.slice(i*n8r, i*n8r+n8r);\n            const s2 = sigmaBuff.slice((i+zkey.domainSize*4)*n8r, (i+zkey.domainSize*4)*n8r+n8r);\n            const s3 = sigmaBuff.slice((i+zkey.domainSize*8)*n8r, (i+zkey.domainSize*8)*n8r+n8r);\n            const ap = Fr.add(ch.b[2], Fr.mul(ch.b[1], w));\n            const bp = Fr.add(ch.b[4], Fr.mul(ch.b[3], w));\n            const cp = Fr.add(ch.b[6], Fr.mul(ch.b[5], w));\n            const w2 = Fr.square(w);\n            const zp = Fr.add(Fr.add(Fr.mul(ch.b[7], w2), Fr.mul(ch.b[8], w)), ch.b[9]);\n            const wW = Fr.mul(w, Fr.w[zkey.power]);\n            const wW2 = Fr.square(wW);\n            const zWp = Fr.add(Fr.add(Fr.mul(ch.b[7], wW2), Fr.mul(ch.b[8], wW)), ch.b[9]);\n\n            let pl = Fr.zero;\n            for (let j=0; j<zkey.nPublic; j++) {\n                pl = Fr.sub(pl, Fr.mul( \n                    lPols.slice( (j*5*zkey.domainSize+ zkey.domainSize+ i)*n8r, (j*5*zkey.domainSize+ zkey.domainSize + i+1)*n8r),\n                    A.slice(j*n8r, (j+1)*n8r)\n                ));\n            }\n\n            let [e1, e1z] = mul2(a, b, ap, bp, i%4);\n            e1 = Fr.mul(e1, qm);\n            e1z = Fr.mul(e1z, qm);\n\n            e1 = Fr.add(e1, Fr.mul(a, ql));\n            e1z = Fr.add(e1z, Fr.mul(ap, ql));\n\n            e1 = Fr.add(e1, Fr.mul(b, qr));\n            e1z = Fr.add(e1z, Fr.mul(bp, qr));\n\n            e1 = Fr.add(e1, Fr.mul(c, qo));\n            e1z = Fr.add(e1z, Fr.mul(cp, qo));\n\n            e1 = Fr.add(e1, pl);\n            e1 = Fr.add(e1, qc);\n\n            const betaw = Fr.mul(ch.beta, w);\n            let e2a =a;\n            e2a = Fr.add(e2a, betaw);\n            e2a = Fr.add(e2a, ch.gamma);\n\n            let e2b =b;\n            e2b = Fr.add(e2b, Fr.mul(betaw, zkey.k1));\n            e2b = Fr.add(e2b, ch.gamma);\n\n            let e2c =c;\n            e2c = Fr.add(e2c, Fr.mul(betaw, zkey.k2));\n            e2c = Fr.add(e2c, ch.gamma);\n\n            let e2d = z;\n\n            let [e2, e2z] = mul4(e2a, e2b, e2c, e2d, ap, bp, cp, zp, i%4);\n            e2 = Fr.mul(e2, ch.alpha);\n            e2z = Fr.mul(e2z, ch.alpha);\n\n            let e3a = a;\n            e3a = Fr.add(e3a, Fr.mul(ch.beta, s1));\n            e3a = Fr.add(e3a, ch.gamma);\n\n            let e3b = b;\n            e3b = Fr.add(e3b, Fr.mul(ch.beta,s2));\n            e3b = Fr.add(e3b, ch.gamma);\n\n            let e3c = c;\n            e3c = Fr.add(e3c, Fr.mul(ch.beta,s3));\n            e3c = Fr.add(e3c, ch.gamma);\n\n            let e3d = zw;\n            let [e3, e3z] = mul4(e3a, e3b, e3c, e3d, ap, bp, cp, zWp, i%4);\n\n            e3 = Fr.mul(e3, ch.alpha);\n            e3z = Fr.mul(e3z, ch.alpha);\n\n            let e4 = Fr.sub(z, Fr.one);\n            e4 = Fr.mul(e4, lPols.slice( (zkey.domainSize + i)*n8r, (zkey.domainSize+i+1)*n8r));\n            e4 = Fr.mul(e4, Fr.mul(ch.alpha, ch.alpha));\n\n            let e4z = Fr.mul(zp, lPols.slice( (zkey.domainSize + i)*n8r, (zkey.domainSize+i+1)*n8r));\n            e4z = Fr.mul(e4z, Fr.mul(ch.alpha, ch.alpha));\n\n            let e = Fr.add(Fr.sub(Fr.add(e1, e2), e3), e4);\n            let ez = Fr.add(Fr.sub(Fr.add(e1z, e2z), e3z), e4z);\n\n            T.set(e, i*n8r);\n            Tz.set(ez, i*n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power+2]);\n        }\n\n        if (logger) logger.debug(\"ifft T\");    \n        let t = await Fr.ifft(T);\n\n        if (logger) logger.debug(\"dividing T/Z\");    \n        for (let i=0; i<zkey.domainSize; i++) {\n            t.set(Fr.neg(t.slice(i*n8r, i*n8r+n8r)), i*n8r);\n        }\n\n        for (let i=zkey.domainSize; i<zkey.domainSize*4; i++) {\n            const a = Fr.sub(\n                t.slice((i-zkey.domainSize)*n8r, (i-zkey.domainSize)*n8r + n8r),\n                t.slice(i*n8r, i*n8r+n8r)\n            );\n            t.set(a, i*n8r);\n            if (i > (zkey.domainSize*3 -4) ) {\n                if (!Fr.isZero(a)) {\n                    throw new Error(\"T Polynomial is not divisible\");\n                }\n            }\n        }\n\n        if (logger) logger.debug(\"ifft Tz\");    \n        const tz = await Fr.ifft(Tz);\n        for (let i=0; i<zkey.domainSize*4; i++) {\n            const a = tz.slice(i*n8r, (i+1)*n8r);\n            if (i > (zkey.domainSize*3 +5) ) {\n                if (!Fr.isZero(a)) {\n                    throw new Error(\"Tz Polynomial is not well calculated\");\n                }\n            } else {\n                t.set(  \n                    Fr.add(\n                        t.slice(i*n8r, (i+1)*n8r),\n                        a\n                    ),\n                    i*n8r\n                );\n            }\n        }\n\n        pol_t = t.slice(0, (zkey.domainSize * 3 + 6) * n8r);\n\n        // t(x) has degree 3n + 5, we are going to split t(x) into three smaller polynomials:\n        // t'_low and t'_mid  with a degree < n and t'_high with a degree n+5\n        // such that t(x) = t'_low(X) + X^n t'_mid(X) + X^{2n} t'_hi(X)\n        // To randomize the parts we use blinding scalars b_10 and b_11 in a way that doesn't change t(X):\n        // t_low(X) = t'_low(X) + b_10 X^n\n        // t_mid(X) = t'_mid(X) - b_10 + b_11 X^n\n        // t_high(X) = t'_high(X) - b_11\n        // such that\n        // t(X) = t_low(X) + X^n t_mid(X) + X^2n t_high(X)\n\n        // compute t_low(X)\n        let polTLow = new BigBuffer((zkey.domainSize + 1) * n8r);\n        polTLow.set(t.slice(0, zkey.domainSize * n8r), 0);\n        // Add blinding scalar b_10 as a new coefficient n\n        polTLow.set(ch.b[10], zkey.domainSize * n8r);\n\n        // compute t_mid(X)\n        let polTMid = new BigBuffer((zkey.domainSize + 1) * n8r);\n        polTMid.set(t.slice(zkey.domainSize * n8r, zkey.domainSize * 2 * n8r), 0);\n        // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        const lowestMid = Fr.sub(polTMid.slice(0, n8r), ch.b[10]);\n        polTMid.set(lowestMid, 0);\n        // Add blinding scalar b_11 as a new coefficient n\n        polTMid.set(ch.b[11], zkey.domainSize * n8r);\n\n        // compute t_high(X)\n        let polTHigh = new BigBuffer((zkey.domainSize + 6) * n8r);\n        polTHigh.set(t.slice(zkey.domainSize * 2 * n8r, (zkey.domainSize * 3 + 6) * n8r), 0);\n        //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        const lowestHigh = Fr.sub(polTHigh.slice(0, n8r), ch.b[11]);\n        polTHigh.set(lowestHigh, 0);\n\n        proof.T1 = await expTau(polTLow, \"multiexp T1\");\n        proof.T2 = await expTau(polTMid, \"multiexp T2\");\n        proof.T3 = await expTau(polTHigh, \"multiexp T3\");\n\n        function mul2(a,b, ap, bp,  p) {\n            let r, rz;\n\n            \n            const a_b = Fr.mul(a,b);\n            const a_bp = Fr.mul(a,bp);\n            const ap_b = Fr.mul(ap,b);\n            const ap_bp = Fr.mul(ap,bp);\n\n            r = a_b;\n\n            let a0 = Fr.add(a_bp, ap_b);\n\n            let a1 = ap_bp;\n\n            rz = a0;\n            if (p) {\n                rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            }\n\n            return [r, rz];\n        }\n\n        function mul4(a,b,c,d, ap, bp, cp, dp, p) {\n            let r, rz;\n\n            \n            const a_b = Fr.mul(a,b);\n            const a_bp = Fr.mul(a,bp);\n            const ap_b = Fr.mul(ap,b);\n            const ap_bp = Fr.mul(ap,bp);\n\n            const c_d = Fr.mul(c,d);\n            const c_dp = Fr.mul(c,dp);\n            const cp_d = Fr.mul(cp,d);\n            const cp_dp = Fr.mul(cp,dp);\n\n            r = Fr.mul(a_b, c_d);\n\n            let a0 = Fr.mul(ap_b, c_d);\n            a0 = Fr.add(a0, Fr.mul(a_bp, c_d));\n            a0 = Fr.add(a0, Fr.mul(a_b, cp_d));\n            a0 = Fr.add(a0, Fr.mul(a_b, c_dp));\n\n            let a1 = Fr.mul(ap_bp, c_d);\n            a1 = Fr.add(a1, Fr.mul(ap_b, cp_d));\n            a1 = Fr.add(a1, Fr.mul(ap_b, c_dp));\n            a1 = Fr.add(a1, Fr.mul(a_bp, cp_d));\n            a1 = Fr.add(a1, Fr.mul(a_bp, c_dp));\n            a1 = Fr.add(a1, Fr.mul(a_b, cp_dp));\n\n            let a2 = Fr.mul(a_bp, cp_dp);\n            a2 = Fr.add(a2, Fr.mul(ap_b, cp_dp));\n            a2 = Fr.add(a2, Fr.mul(ap_bp, c_dp));\n            a2 = Fr.add(a2, Fr.mul(ap_bp, cp_d));\n\n            let a3 = Fr.mul(ap_bp, cp_dp);\n\n            rz = a0;\n            if (p) {\n                rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n                rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n                rz = Fr.add(rz, Fr.mul(Z3[p], a3));\n            }\n\n            return [r, rz];\n        }\n    }\n\n    async function round4() {\n        const pol_qm = new BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_qm, 0 , zkey.domainSize*n8r, sectionsZKey[7][0].p);\n\n        const pol_ql = new BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_ql, 0 , zkey.domainSize*n8r, sectionsZKey[8][0].p);\n\n        const pol_qr = new BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_qr, 0 , zkey.domainSize*n8r, sectionsZKey[9][0].p);\n\n        const pol_qo = new BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_qo, 0 , zkey.domainSize*n8r, sectionsZKey[10][0].p);\n\n        const pol_qc = new BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_qc, 0 , zkey.domainSize*n8r, sectionsZKey[11][0].p);\n\n        const pol_s3 = new BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_s3, 0 , zkey.domainSize*n8r, sectionsZKey[12][0].p + 10*zkey.domainSize*n8r);\n\n        const transcript4 = new Uint8Array(G1.F.n8*2*3);\n        G1.toRprUncompressed(transcript4, 0, proof.T1);\n        G1.toRprUncompressed(transcript4, G1.F.n8*2, proof.T2);\n        G1.toRprUncompressed(transcript4, G1.F.n8*4, proof.T3);\n        ch.xi = hashToFr(transcript4);\n\n        if (logger) logger.debug(\"xi: \" + Fr.toString(ch.xi));    \n\n        proof.eval_a = evalPol(pol_a, ch.xi);\n        proof.eval_b = evalPol(pol_b, ch.xi);\n        proof.eval_c = evalPol(pol_c, ch.xi);\n        proof.eval_s1 = evalPol(pol_s1, ch.xi);\n        proof.eval_s2 = evalPol(pol_s2, ch.xi);\n        proof.eval_t = evalPol(pol_t, ch.xi);\n        proof.eval_zw = evalPol(pol_z, Fr.mul(ch.xi, Fr.w[zkey.power]));\n\n        const coef_ab = Fr.mul(proof.eval_a, proof.eval_b);\n        \n        let e2a = proof.eval_a;\n        const betaxi = Fr.mul(ch.beta, ch.xi);\n        e2a = Fr.add( e2a, betaxi);\n        e2a = Fr.add( e2a, ch.gamma);\n\n        let e2b = proof.eval_b;\n        e2b = Fr.add( e2b, Fr.mul(betaxi, zkey.k1));\n        e2b = Fr.add( e2b, ch.gamma);\n\n        let e2c = proof.eval_c;\n        e2c = Fr.add( e2c, Fr.mul(betaxi, zkey.k2));\n        e2c = Fr.add( e2c, ch.gamma);\n\n        const e2 = Fr.mul(Fr.mul(Fr.mul(e2a, e2b), e2c), ch.alpha);\n\n        let e3a = proof.eval_a;\n        e3a = Fr.add( e3a, Fr.mul(ch.beta, proof.eval_s1));\n        e3a = Fr.add( e3a, ch.gamma);\n\n        let e3b = proof.eval_b;\n        e3b = Fr.add( e3b, Fr.mul(ch.beta, proof.eval_s2));\n        e3b = Fr.add( e3b, ch.gamma);\n\n        let e3 = Fr.mul(e3a, e3b);\n        e3 = Fr.mul(e3, ch.beta);\n        e3 = Fr.mul(e3, proof.eval_zw);\n        e3 = Fr.mul(e3, ch.alpha);\n\n        ch.xim= ch.xi;\n        for (let i=0; i<zkey.power; i++) ch.xim = Fr.mul(ch.xim, ch.xim);\n        const eval_l1 = Fr.div(\n            Fr.sub(ch.xim, Fr.one),\n            Fr.mul(Fr.sub(ch.xi, Fr.one), Fr.e(zkey.domainSize))\n        );\n\n        const e4 = Fr.mul(eval_l1, Fr.mul(ch.alpha, ch.alpha));\n\n        const coefs3 = e3;\n        const coefz = Fr.add(e2, e4);\n\n        pol_r = new BigBuffer((zkey.domainSize+3)*n8r);\n\n        for (let i = 0; i<zkey.domainSize+3; i++) {\n            let v = Fr.mul(coefz, pol_z.slice(i*n8r,(i+1)*n8r));\n            if (i<zkey.domainSize) {\n                v = Fr.add(v, Fr.mul(coef_ab, pol_qm.slice(i*n8r,(i+1)*n8r)));\n                v = Fr.add(v, Fr.mul(proof.eval_a, pol_ql.slice(i*n8r,(i+1)*n8r)));\n                v = Fr.add(v, Fr.mul(proof.eval_b, pol_qr.slice(i*n8r,(i+1)*n8r)));\n                v = Fr.add(v, Fr.mul(proof.eval_c, pol_qo.slice(i*n8r,(i+1)*n8r)));\n                v = Fr.add(v, pol_qc.slice(i*n8r,(i+1)*n8r));\n                v = Fr.sub(v, Fr.mul(coefs3, pol_s3.slice(i*n8r,(i+1)*n8r)));\n            }\n            pol_r.set(v, i*n8r);\n        }\n\n        proof.eval_r = evalPol(pol_r, ch.xi);\n    }\n\n    async function round5() {\n        const transcript5 = new Uint8Array(n8r*7);\n        Fr.toRprBE(transcript5, 0, proof.eval_a);\n        Fr.toRprBE(transcript5, n8r, proof.eval_b);\n        Fr.toRprBE(transcript5, n8r*2, proof.eval_c);\n        Fr.toRprBE(transcript5, n8r*3, proof.eval_s1);\n        Fr.toRprBE(transcript5, n8r*4, proof.eval_s2);\n        Fr.toRprBE(transcript5, n8r*5, proof.eval_zw);\n        Fr.toRprBE(transcript5, n8r*6, proof.eval_r);\n        ch.v = [];\n        ch.v[1] = hashToFr(transcript5);\n        if (logger) logger.debug(\"v: \" + Fr.toString(ch.v[1]));    \n\n        for (let i=2; i<=6; i++ ) ch.v[i] = Fr.mul(ch.v[i-1], ch.v[1]);\n        \n        let pol_wxi = new BigBuffer((zkey.domainSize+6)*n8r);\n\n        const xi2m = Fr.mul(ch.xim, ch.xim);\n\n        for (let i = 0; i < zkey.domainSize + 6; i++) {\n            let w = Fr.zero;\n\n            const polTHigh = pol_t.slice((zkey.domainSize * 2 + i) * n8r, (zkey.domainSize * 2 + i + 1) * n8r);\n            w = Fr.add(w, Fr.mul(xi2m, polTHigh));\n\n            if (i < zkey.domainSize + 3) {\n                w = Fr.add(w, Fr.mul(ch.v[1], pol_r.slice(i * n8r, (i + 1) * n8r)));\n            }\n\n            if (i < zkey.domainSize + 2) {\n                w = Fr.add(w, Fr.mul(ch.v[2], pol_a.slice(i * n8r, (i + 1) * n8r)));\n                w = Fr.add(w, Fr.mul(ch.v[3], pol_b.slice(i * n8r, (i + 1) * n8r)));\n                w = Fr.add(w, Fr.mul(ch.v[4], pol_c.slice(i * n8r, (i + 1) * n8r)));\n            }\n\n            if (i < zkey.domainSize) {\n                const polTLow = pol_t.slice(i * n8r, (i + 1) * n8r);\n                w = Fr.add(w, polTLow);\n\n                const polTMid = pol_t.slice((zkey.domainSize + i) * n8r, (zkey.domainSize + i + 1) * n8r);\n                w = Fr.add(w, Fr.mul(ch.xim, polTMid));\n\n                w = Fr.add(w, Fr.mul(ch.v[5], pol_s1.slice(i * n8r, (i + 1) * n8r)));\n                w = Fr.add(w, Fr.mul(ch.v[6], pol_s2.slice(i * n8r, (i + 1) * n8r)));\n            }\n\n            // b_10 and b_11 blinding scalars were applied on round 3 to randomize the polynomials t_low, t_mid, t_high\n            // Subtract blinding scalar b_10 and b_11 to the lowest coefficient\n            if (i === 0) {\n                w = Fr.sub(w, Fr.mul(xi2m, ch.b[11]));\n                w = Fr.sub(w, Fr.mul(ch.xim, ch.b[10]));\n            }\n\n            // Add blinding scalars b_10 and b_11 to the coefficient n\n            if (i === zkey.domainSize) {\n                w = Fr.add(w, ch.b[10]);\n                w = Fr.add(w, Fr.mul(ch.xim, ch.b[11]));\n            }\n\n            pol_wxi.set(w, i * n8r);\n        }\n\n        let w0 = pol_wxi.slice(0, n8r);\n        w0 = Fr.sub(w0, proof.eval_t);\n        w0 = Fr.sub(w0, Fr.mul(ch.v[1], proof.eval_r));\n        w0 = Fr.sub(w0, Fr.mul(ch.v[2], proof.eval_a));\n        w0 = Fr.sub(w0, Fr.mul(ch.v[3], proof.eval_b));\n        w0 = Fr.sub(w0, Fr.mul(ch.v[4], proof.eval_c));\n        w0 = Fr.sub(w0, Fr.mul(ch.v[5], proof.eval_s1));\n        w0 = Fr.sub(w0, Fr.mul(ch.v[6], proof.eval_s2));\n        pol_wxi.set(w0, 0);\n\n        pol_wxi= divPol1(pol_wxi, ch.xi);\n\n        proof.Wxi = await expTau(pol_wxi, \"multiexp Wxi\");\n\n        let pol_wxiw = new BigBuffer((zkey.domainSize+3)*n8r);\n        for (let i=0; i<zkey.domainSize+3; i++) {\n            const w = pol_z.slice(i*n8r, (i+1)*n8r);\n            pol_wxiw.set(w, i*n8r);\n        }\n        w0 = pol_wxiw.slice(0, n8r);\n        w0 = Fr.sub(w0, proof.eval_zw);\n        pol_wxiw.set(w0, 0);\n\n        pol_wxiw= divPol1(pol_wxiw, Fr.mul(ch.xi, Fr.w[zkey.power]));\n        proof.Wxiw = await expTau(pol_wxiw, \"multiexp Wxiw\");\n    }\n\n    function hashToFr(transcript) {\n        const v = Scalar.fromRprBE(new Uint8Array(keccak256.arrayBuffer(transcript)));\n        return Fr.e(v);\n    }\n\n\n    function evalPol(P, x) {\n        const n = P.byteLength / n8r;\n        if (n == 0) return Fr.zero;\n        let res = P.slice((n-1)*n8r, n*n8r);\n        for (let i=n-2; i>=0; i--) {\n            res = Fr.add(Fr.mul(res, x), P.slice(i*n8r, (i+1)*n8r));\n        }\n        return res;\n    }\n\n    function divPol1(P, d) {\n        const n = P.byteLength/n8r;\n        const res = new BigBuffer(n*n8r);\n        res.set(Fr.zero, (n-1) *n8r);\n        res.set(P.slice((n-1)*n8r, n*n8r), (n-2)*n8r);\n        for (let i=n-3; i>=0; i--) {\n            res.set(\n                Fr.add(\n                    P.slice((i+1)*n8r, (i+2)*n8r), \n                    Fr.mul(\n                        d, \n                        res.slice((i+1)*n8r, (i+2)*n8r)\n                    )\n                ),\n                i*n8r\n            );\n        }\n        if (!Fr.eq(\n            P.slice(0, n8r),\n            Fr.mul(\n                Fr.neg(d),\n                res.slice(0, n8r)\n            )\n        )) {\n            throw new Error(\"Polinomial does not divide\");\n        }\n        return res;\n    }\n\n    async function expTau(b, name) {\n        const n = b.byteLength/n8r;\n        const PTauN = PTau.slice(0, n*curve.G1.F.n8*2);\n        const bm = await curve.Fr.batchFromMontgomery(b);\n        let res = await curve.G1.multiExpAffine(PTauN, bm, logger, name);\n        res = curve.G1.toAffine(res);\n        return res;\n    }\n\n\n    async function to4T(A, pz) {\n        pz = pz || []; \n        let a = await Fr.ifft(A);\n        const a4 = new BigBuffer(n8r*zkey.domainSize*4);\n        a4.set(a, 0);\n\n        const a1 = new BigBuffer(n8r*(zkey.domainSize + pz.length));\n        a1.set(a, 0);\n        for (let i= 0; i<pz.length; i++) {\n            a1.set(\n                Fr.add(\n                    a1.slice((zkey.domainSize+i)*n8r, (zkey.domainSize+i+1)*n8r),\n                    pz[i]\n                ),\n                (zkey.domainSize+i)*n8r\n            );\n            a1.set(\n                Fr.sub(\n                    a1.slice(i*n8r, (i+1)*n8r),\n                    pz[i]\n                ),\n                i*n8r\n            );\n        }\n        const A4 = await Fr.fft(a4);\n        return [a1, A4];\n    }\n\n\n}\n\n\n\n\n", "/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\nimport { Scalar } from \"ffjavascript\";\nimport * as curves from \"./curves.js\";\nimport {  utils }   from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\nimport jsSha3 from \"js-sha3\";\nconst { keccak256 } = jsSha3;\n\n\nexport default async function plonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    let vk_verifier = unstringifyBigInts(_vk_verifier);\n    let proof = unstringifyBigInts(_proof);\n    let publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await curves.getCurveFromName(vk_verifier.curve);\n\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n\n    proof = fromObjectProof(curve,proof);\n    vk_verifier = fromObjectVk(curve, vk_verifier);\n    if (!isWellConstructed(curve, proof)) {\n        logger.error(\"Proof is not well constructed\");\n        return false;\n    }\n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Invalid number of public inputs\");\n        return false;\n    }\n    const challanges = calculateChallanges(curve, proof, publicSignals);\n    if (logger) {\n        logger.debug(\"beta: \" + Fr.toString(challanges.beta, 16));    \n        logger.debug(\"gamma: \" + Fr.toString(challanges.gamma, 16));    \n        logger.debug(\"alpha: \" + Fr.toString(challanges.alpha, 16));    \n        logger.debug(\"xi: \" + Fr.toString(challanges.xi, 16));    \n        logger.debug(\"v1: \" + Fr.toString(challanges.v[1], 16));    \n        logger.debug(\"v6: \" + Fr.toString(challanges.v[6], 16));    \n        logger.debug(\"u: \" + Fr.toString(challanges.u, 16));    \n    }\n    const L = calculateLagrangeEvaluations(curve, challanges, vk_verifier);\n    if (logger) {\n        logger.debug(\"Lagrange Evaluations: \");\n        for (let i=1; i<L.length; i++) {\n            logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));    \n        }\n    }\n    \n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const pl = calculatePl(curve, publicSignals, L);\n    if (logger) {\n        logger.debug(\"Pl: \" + Fr.toString(pl, 16));\n    }\n\n    const t = calculateT(curve, proof, challanges, pl, L[1]);\n    if (logger) {\n        logger.debug(\"t: \" + Fr.toString(t, 16));\n    }\n\n    const D = calculateD(curve, proof, challanges, vk_verifier, L[1]);\n    if (logger) {\n        logger.debug(\"D: \" + G1.toString(G1.toAffine(D), 16));\n    }\n\n    const F = calculateF(curve, proof, challanges, vk_verifier, D);\n    if (logger) {\n        logger.debug(\"F: \" + G1.toString(G1.toAffine(F), 16));\n    }\n\n    const E = calculateE(curve, proof, challanges, vk_verifier, t);\n    if (logger) {\n        logger.debug(\"E: \" + G1.toString(G1.toAffine(E), 16));\n    }\n\n    const res = await isValidPairing(curve, proof, challanges, vk_verifier, E, F);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"OK!\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    return res;\n\n}\n\n\nfunction fromObjectProof(curve, proof) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    const res = {};\n    res.A = G1.fromObject(proof.A);\n    res.B = G1.fromObject(proof.B);\n    res.C = G1.fromObject(proof.C);\n    res.Z = G1.fromObject(proof.Z);\n    res.T1 = G1.fromObject(proof.T1);\n    res.T2 = G1.fromObject(proof.T2);\n    res.T3 = G1.fromObject(proof.T3);\n    res.eval_a = Fr.fromObject(proof.eval_a);\n    res.eval_b = Fr.fromObject(proof.eval_b);\n    res.eval_c = Fr.fromObject(proof.eval_c);\n    res.eval_zw = Fr.fromObject(proof.eval_zw);\n    res.eval_s1 = Fr.fromObject(proof.eval_s1);\n    res.eval_s2 = Fr.fromObject(proof.eval_s2);\n    res.eval_r = Fr.fromObject(proof.eval_r);\n    res.Wxi = G1.fromObject(proof.Wxi);\n    res.Wxiw = G1.fromObject(proof.Wxiw);\n    return res;\n}\n\nfunction fromObjectVk(curve, vk) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n    const Fr = curve.Fr;\n    const res = vk;\n    res.Qm = G1.fromObject(vk.Qm);\n    res.Ql = G1.fromObject(vk.Ql);\n    res.Qr = G1.fromObject(vk.Qr);\n    res.Qo = G1.fromObject(vk.Qo);\n    res.Qc = G1.fromObject(vk.Qc);\n    res.S1 = G1.fromObject(vk.S1);\n    res.S2 = G1.fromObject(vk.S2);\n    res.S3 = G1.fromObject(vk.S3);\n    res.k1 = Fr.fromObject(vk.k1);\n    res.k2 = Fr.fromObject(vk.k2);\n    res.X_2 = G2.fromObject(vk.X_2);\n\n    return res;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    if (!G1.isValid(proof.A)) return false;\n    if (!G1.isValid(proof.B)) return false;\n    if (!G1.isValid(proof.C)) return false;\n    if (!G1.isValid(proof.Z)) return false;\n    if (!G1.isValid(proof.T1)) return false;\n    if (!G1.isValid(proof.T2)) return false;\n    if (!G1.isValid(proof.T3)) return false;\n    if (!G1.isValid(proof.Wxi)) return false;\n    if (!G1.isValid(proof.Wxiw)) return false;\n    return true;\n}\n\nfunction calculateChallanges(curve, proof, publicSignals) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n    const res = {};\n\n    const transcript1 = new Uint8Array(publicSignals.length*n8r + G1.F.n8*2*3);\n    for (let i=0; i<publicSignals.length; i++) {\n        Fr.toRprBE(transcript1, i*n8r, Fr.e(publicSignals[i]));\n    }\n    G1.toRprUncompressed(transcript1, publicSignals.length*n8r + 0, proof.A);\n    G1.toRprUncompressed(transcript1, publicSignals.length*n8r + G1.F.n8*2, proof.B);\n    G1.toRprUncompressed(transcript1, publicSignals.length*n8r + G1.F.n8*4, proof.C);\n\n    res.beta = hashToFr(curve, transcript1);\n\n    const transcript2 = new Uint8Array(n8r);\n    Fr.toRprBE(transcript2, 0, res.beta);\n    res.gamma = hashToFr(curve, transcript2);\n\n    const transcript3 = new Uint8Array(G1.F.n8*2);\n    G1.toRprUncompressed(transcript3, 0, proof.Z);\n    res.alpha = hashToFr(curve, transcript3);\n\n    const transcript4 = new Uint8Array(G1.F.n8*2*3);\n    G1.toRprUncompressed(transcript4, 0, proof.T1);\n    G1.toRprUncompressed(transcript4, G1.F.n8*2, proof.T2);\n    G1.toRprUncompressed(transcript4, G1.F.n8*4, proof.T3);\n    res.xi = hashToFr(curve, transcript4);\n\n    const transcript5 = new Uint8Array(n8r*7);\n    Fr.toRprBE(transcript5, 0, proof.eval_a);\n    Fr.toRprBE(transcript5, n8r, proof.eval_b);\n    Fr.toRprBE(transcript5, n8r*2, proof.eval_c);\n    Fr.toRprBE(transcript5, n8r*3, proof.eval_s1);\n    Fr.toRprBE(transcript5, n8r*4, proof.eval_s2);\n    Fr.toRprBE(transcript5, n8r*5, proof.eval_zw);\n    Fr.toRprBE(transcript5, n8r*6, proof.eval_r);\n    res.v = [];\n    res.v[1] = hashToFr(curve, transcript5);\n\n    for (let i=2; i<=6; i++ ) res.v[i] = Fr.mul(res.v[i-1], res.v[1]);\n\n    const transcript6 = new Uint8Array(G1.F.n8*2*2);\n    G1.toRprUncompressed(transcript6, 0, proof.Wxi);\n    G1.toRprUncompressed(transcript6, G1.F.n8*2, proof.Wxiw);\n    res.u = hashToFr(curve, transcript6);\n\n    return res;\n}\n\nfunction calculateLagrangeEvaluations(curve, challanges, vk) {\n    const Fr = curve.Fr;\n\n    let xin = challanges.xi;\n    let domainSize = 1;\n    for (let i=0; i<vk.power; i++) {\n        xin = Fr.square(xin);\n        domainSize *= 2;\n    }\n    challanges.xin = xin;\n\n    challanges.zh = Fr.sub(xin, Fr.one);\n    const L = [];\n\n    const n = Fr.e(domainSize);\n    let w = Fr.one;\n    for (let i=1; i<=Math.max(1, vk.nPublic); i++) {\n        L[i] = Fr.div(Fr.mul(w, challanges.zh), Fr.mul(n, Fr.sub(challanges.xi, w)));\n        w = Fr.mul(w, Fr.w[vk.power]);\n    }\n\n    return L;\n}\n\nfunction hashToFr(curve, transcript) {\n    const v = Scalar.fromRprBE(new Uint8Array(keccak256.arrayBuffer(transcript)));\n    return curve.Fr.e(v);\n}\n\nfunction calculatePl(curve, publicSignals, L) {\n    const Fr = curve.Fr;\n\n    let pl = Fr.zero;\n    for (let i=0; i<publicSignals.length; i++) {\n        const w = Fr.e(publicSignals[i]);\n        pl = Fr.sub(pl, Fr.mul(w, L[i+1]));\n    }\n    return pl;\n}\n\nfunction calculateT(curve, proof, challanges, pl, l1) {\n    const Fr = curve.Fr;\n    let num = proof.eval_r;\n    num = Fr.add(num, pl);\n\n    let e1 = proof.eval_a;\n    e1 = Fr.add(e1, Fr.mul(challanges.beta, proof.eval_s1));\n    e1 = Fr.add(e1, challanges.gamma);\n\n    let e2 = proof.eval_b;\n    e2 = Fr.add(e2, Fr.mul(challanges.beta, proof.eval_s2));\n    e2 = Fr.add(e2, challanges.gamma);\n\n    let e3 = proof.eval_c;\n    e3 = Fr.add(e3, challanges.gamma);\n\n    let e = Fr.mul(Fr.mul(e1, e2), e3);\n    e = Fr.mul(e, proof.eval_zw);\n    e = Fr.mul(e, challanges.alpha);\n\n    num = Fr.sub(num, e);\n\n    num = Fr.sub(num, Fr.mul(l1, Fr.square(challanges.alpha)));\n\n    const t = Fr.div(num, challanges.zh);\n\n    return t;\n}\n\nfunction calculateD(curve, proof, challanges, vk, l1) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let s1 = Fr.mul(Fr.mul(proof.eval_a, proof.eval_b), challanges.v[1]);\n    let res = G1.timesFr(vk.Qm, s1);\n\n    let s2 = Fr.mul(proof.eval_a, challanges.v[1]);\n    res = G1.add(res, G1.timesFr(vk.Ql, s2));\n\n    let s3 = Fr.mul(proof.eval_b, challanges.v[1]);\n    res = G1.add(res, G1.timesFr(vk.Qr, s3));\n\n    let s4 = Fr.mul(proof.eval_c, challanges.v[1]);\n    res = G1.add(res, G1.timesFr(vk.Qo, s4));\n\n    res = G1.add(res, G1.timesFr(vk.Qc, challanges.v[1]));\n\n    const betaxi = Fr.mul(challanges.beta, challanges.xi);\n    let s6a = proof.eval_a;\n    s6a = Fr.add(s6a, betaxi);\n    s6a = Fr.add(s6a, challanges.gamma);\n\n    let s6b = proof.eval_b;\n    s6b = Fr.add(s6b, Fr.mul(betaxi, vk.k1));\n    s6b = Fr.add(s6b, challanges.gamma);\n\n    let s6c = proof.eval_c;\n    s6c = Fr.add(s6c, Fr.mul(betaxi, vk.k2));\n    s6c = Fr.add(s6c, challanges.gamma);\n\n    let s6 = Fr.mul(Fr.mul(s6a, s6b), s6c);\n    s6 = Fr.mul(s6, Fr.mul(challanges.alpha, challanges.v[1]));\n\n    let s6d = Fr.mul(Fr.mul(l1, Fr.square(challanges.alpha)), challanges.v[1]);\n    s6 = Fr.add(s6, s6d);\n\n    s6 = Fr.add(s6, challanges.u);\n    res = G1.add(res, G1.timesFr(proof.Z, s6));\n\n\n    let s7a = proof.eval_a;\n    s7a = Fr.add(s7a, Fr.mul(challanges.beta, proof.eval_s1));\n    s7a = Fr.add(s7a, challanges.gamma);\n\n    let s7b = proof.eval_b;\n    s7b = Fr.add(s7b, Fr.mul(challanges.beta, proof.eval_s2));\n    s7b = Fr.add(s7b, challanges.gamma);\n\n    let s7 = Fr.mul(s7a, s7b);\n    s7 = Fr.mul(s7, challanges.alpha);\n    s7 = Fr.mul(s7, challanges.v[1]);\n    s7 = Fr.mul(s7, challanges.beta);\n    s7 = Fr.mul(s7, proof.eval_zw);\n    res = G1.sub(res, G1.timesFr(vk.S3, s7));\n\n    return res;\n}\n\nfunction calculateF(curve, proof, challanges, vk, D) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let res = proof.T1;\n\n    res = G1.add(res, G1.timesFr(proof.T2, challanges.xin));\n    res = G1.add(res, G1.timesFr(proof.T3, Fr.square(challanges.xin)));\n    res = G1.add(res, D);\n    res = G1.add(res, G1.timesFr(proof.A, challanges.v[2]));\n    res = G1.add(res, G1.timesFr(proof.B, challanges.v[3]));\n    res = G1.add(res, G1.timesFr(proof.C, challanges.v[4]));\n    res = G1.add(res, G1.timesFr(vk.S1, challanges.v[5]));\n    res = G1.add(res, G1.timesFr(vk.S2, challanges.v[6]));\n\n    return res;\n}\n\n\nfunction calculateE(curve, proof, challanges, vk, t) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let s = t;\n\n    s = Fr.add(s, Fr.mul(challanges.v[1], proof.eval_r));\n    s = Fr.add(s, Fr.mul(challanges.v[2], proof.eval_a));\n    s = Fr.add(s, Fr.mul(challanges.v[3], proof.eval_b));\n    s = Fr.add(s, Fr.mul(challanges.v[4], proof.eval_c));\n    s = Fr.add(s, Fr.mul(challanges.v[5], proof.eval_s1));\n    s = Fr.add(s, Fr.mul(challanges.v[6], proof.eval_s2));\n    s = Fr.add(s, Fr.mul(challanges.u, proof.eval_zw));\n\n    const res = G1.timesFr(G1.one, s);\n\n    return res;\n}\n\nasync function isValidPairing(curve, proof, challanges, vk, E, F) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let A1 = proof.Wxi;\n    A1 = G1.add(A1, G1.timesFr(proof.Wxiw, challanges.u));\n\n    let B1 = G1.timesFr(proof.Wxi, challanges.xi);\n    const s = Fr.mul(Fr.mul(challanges.u, challanges.xi), Fr.w[vk.power]);\n    B1 = G1.add(B1, G1.timesFr(proof.Wxiw, s));\n    B1 = G1.add(B1, F);\n    B1 = G1.sub(B1, E);\n\n    const res = await curve.pairingEq(\n        G1.neg(A1) , vk.X_2,\n        B1 , curve.G2.one\n    );\n\n    return res;\n\n}\n", "/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { getCurveFromName } from \"./curves.js\";\nimport {  utils }   from \"ffjavascript\";\nconst { unstringifyBigInts} = utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nexport default async function plonkExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await getCurveFromName(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    const proofBuff = new Uint8Array(G1.F.n8*2*9 + Fr.n8*7);\n    G1.toRprUncompressed(proofBuff, 0, G1.e(proof.A));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*2, G1.e(proof.B));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*4, G1.e(proof.C));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*6, G1.e(proof.Z));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*8, G1.e(proof.T1));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*10, G1.e(proof.T2));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*12, G1.e(proof.T3));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*14, G1.e(proof.Wxi));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*16, G1.e(proof.Wxiw));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 , Fr.e(proof.eval_a));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8, Fr.e(proof.eval_b));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*2, Fr.e(proof.eval_c));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*3, Fr.e(proof.eval_s1));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*4, Fr.e(proof.eval_s2));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*5, Fr.e(proof.eval_zw));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*6, Fr.e(proof.eval_r));\n\n    const proofHex = Array.from(proofBuff).map(i2hex).join(\"\");\n\n    const S=\"0x\"+proofHex+\",[\"+inputs+\"]\";\n\n    return S;\n}\n", "import { Id } from '@iden3/js-iden3-core';\nimport { ProvingMethod, ProvingMethodAlg, ZKProof } from './proving';\nimport { AuthV2Circuit, Groth16, prove, verify } from './common';\nimport { Hash, newHashFromString } from '@iden3/js-merkletree';\n\n// AuthV2PubSignals auth.circom public signals\nexport interface AuthV2PubSignals {\n  userID: Id;\n  challenge: bigint;\n  GISTRoot: Hash;\n}\n\nexport const AuthV2Groth16Alg = new ProvingMethodAlg(Groth16, AuthV2Circuit);\n\n// ProvingMethodGroth16AuthV2 instance for Groth16 proving method with an authV2 circuit\nexport class ProvingMethodGroth16AuthV2 implements ProvingMethod {\n  constructor(public readonly methodAlg: ProvingMethodAlg) {}\n\n  get alg(): string {\n    return this.methodAlg.alg;\n  }\n\n  get circuitId(): string {\n    return this.methodAlg.circuitId;\n  }\n\n  async verify(\n    messageHash: Uint8Array,\n    proof: ZKProof,\n    verificationKey: Uint8Array,\n  ): Promise<boolean> {\n    return verify<AuthV2PubSignals>(\n      messageHash,\n      proof,\n      verificationKey,\n      this.unmarshall,\n    );\n  }\n\n  prove(\n    inputs: Uint8Array,\n    provingKey: Uint8Array,\n    wasm: Uint8Array,\n  ): Promise<ZKProof> {\n    return prove(inputs, provingKey, wasm);\n  }\n\n  unmarshall(pubSignals: string[]): AuthV2PubSignals {\n    const len = 3;\n\n    if (pubSignals.length !== len) {\n      throw new Error(\n        `invalid number of Output values expected ${len} got ${pubSignals.length}`,\n      );\n    }\n\n    return {\n      userID: Id.fromBigInt(BigInt(pubSignals[0])),\n      challenge: BigInt(pubSignals[1]),\n      GISTRoot: newHashFromString(pubSignals[2]),\n    };\n  }\n}\n\nexport const provingMethodGroth16AuthV2Instance: ProvingMethod =\n  new ProvingMethodGroth16AuthV2(new ProvingMethodAlg(Groth16, AuthV2Circuit));\n", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "export {};\n//# sourceMappingURL=hash.js.map", "export {};\n//# sourceMappingURL=node.js.map", "export {};\n//# sourceMappingURL=bytes.js.map", "export {};\n//# sourceMappingURL=storage.js.map", "export {};\n//# sourceMappingURL=merkletree.js.map"],
  "mappings": "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AAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACrD,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,CAAC,EACrD,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAE,EACrD,CAAC,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,CAAC,EACrD,CAAC,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,EACrD,CAAC,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAE,EACrD,CAAC,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,CAAC,EACrD,CAAC,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,CAAC,EACrD,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,EAAE,EACrD,CAAC,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,CAAC,EACrD,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACrD,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,CAAC,EACrD,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAE,EACrD,CAAC,EAAG,GAAI,EAAG,GAAI,EAA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",
  "names": ["defaultSetTimout", "defaultClearTimeout", "runTimeout", "fun", "cachedSetTimeout", "runClearTimeout", "marker", "cachedClearTimeout", "cleanUpNextTick", "draining", "currentQueue", "queue", "queueIndex", "drainQueue", "timeout", "len", "nextTick", "args", "i", "Item", "array", "noop", "binding", "name", "cwd", "chdir", "dir", "umask", "hrtime", "previousTimestamp", "clocktime", "performanceNow", "performance", "seconds", "nanoseconds", "uptime", "currentTime", "dif", "startTime", "title", "platform", "browser", "env", "argv", "version", "versions", "release", "config", "on", "addListener", "once", "off", "removeListener", "removeAllListeners", "emit", "process", "defines", "init_virtual_process_polyfill", "__esmMin", "key", "segs", "target", "seg", "init", "inited", "code", "i", "len", "lookup", "revLookup", "base64toByteArray", "b64", "j", "l", "tmp", "placeHolders", "arr", "Arr", "L", "tripletToBase64", "num", "encodeChunk", "uint8", "start", "end", "output", "base64fromByteArray", "extraBytes", "parts", "maxChunkLength", "len2", "kMaxLength", "Buffer", "createBuffer", "that", "length", "arg", "encodingOrOffset", "allocUnsafe", "from", "value", "fromArrayBuffer", "fromString", "fromObject", "assertSize", "size", "alloc", "fill", "encoding", "checked", "string", "byteLength", "actual", "fromArrayLike", "array", "byteOffset", "obj", "internalIsBuffer", "isnan", "b", "loweredCase", "utf8ToBytes", "base64ToBytes", "slowToString", "hexSlice", "utf8Slice", "asciiSlice", "latin1Slice", "base64Slice", "utf16leSlice", "swap", "n", "m", "bidirectionalIndexOf", "buffer", "val", "dir", "arrayIndexOf", "indexSize", "arrLength", "valLength", "read", "buf", "foundIndex", "found", "hexWrite", "offset", "remaining", "strLen", "parsed", "utf8Write", "blitBuffer", "asciiWrite", "asciiToBytes", "latin1Write", "base64Write", "ucs2Write", "utf16leToBytes", "res", "firstByte", "codePoint", "bytesPerSequence", "secondByte", "thirdByte", "fourthByte", "tempCodePoint", "decodeCodePointsArray", "codePoints", "MAX_ARGUMENTS_LENGTH", "ret", "out", "toHex", "bytes", "checkOffset", "ext", "checkInt", "max", "min", "objectWriteUInt16", "littleEndian", "objectWriteUInt32", "checkIEEE754", "writeFloat", "noAssert", "ieee754write", "writeDouble", "base64clean", "str", "stringtrim", "INVALID_BASE64_RE", "units", "leadSurrogate", "byteArray", "c", "hi", "lo", "src", "dst", "isBuffer", "isFastBuffer", "isSlowBuffer", "ieee754read", "isLE", "mLen", "nBytes", "e", "eLen", "eMax", "eBias", "nBits", "d", "s", "rt", "init_Buffer", "__esmMin", "init_virtual_process_polyfill", "init_buffer", "a", "x", "y", "list", "pos", "target", "thisStart", "thisEnd", "thisCopy", "targetCopy", "newBuf", "sliceLen", "mul", "maxBytes", "limit", "sub", "targetStart", "init_buffer", "__esmMin", "init_Buffer", "events_exports", "__export", "EventEmitter", "events_default", "EventHandlers", "$getMaxListeners", "that", "emitNone", "handler", "isFn", "self", "len", "listeners", "arrayClone", "i", "emitOne", "arg1", "emitTwo", "arg2", "emitThree", "arg3", "emitMany", "args", "_addListener", "target", "type", "listener", "prepend", "m", "events", "existing", "w", "emitWarning", "e", "_onceWrap", "fired", "g", "listenerCount", "evlistener", "spliceOne", "list", "index", "k", "n", "arr", "copy", "unwrapListeners", "ret", "domain", "init_events", "__esmMin", "init_virtual_process_polyfill", "init_buffer", "er", "needDomainExit", "doError", "err", "position", "originalListener", "keys", "key", "emitter", "require_events", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "polyfill", "k", "require_stream_browser", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "buffer_exports", "__export", "Buffer", "INSPECT_MAX_BYTES", "SlowBuffer", "isBuffer", "_kMaxLength", "init", "inited", "code", "i", "len", "lookup", "revLookup", "toByteArray", "b64", "j", "l", "tmp", "placeHolders", "arr", "Arr", "L", "tripletToBase64", "num", "encodeChunk", "uint8", "start", "end", "output", "fromByteArray", "extraBytes", "parts", "maxChunkLength", "len2", "read", "buffer", "offset", "isLE", "mLen", "nBytes", "e", "m", "eLen", "eMax", "eBias", "nBits", "d", "s", "write", "value", "c", "rt", "kMaxLength", "createBuffer", "that", "length", "arg", "encodingOrOffset", "allocUnsafe", "from", "fromArrayBuffer", "fromString", "fromObject", "assertSize", "size", "alloc", "fill", "encoding", "checked", "string", "byteLength", "actual", "fromArrayLike", "array", "byteOffset", "obj", "internalIsBuffer", "isnan", "isArray", "b", "loweredCase", "utf8ToBytes", "base64ToBytes", "slowToString", "hexSlice", "utf8Slice", "asciiSlice", "latin1Slice", "base64Slice", "utf16leSlice", "swap", "n", "bidirectionalIndexOf", "val", "dir", "arrayIndexOf", "indexSize", "arrLength", "valLength", "buf", "foundIndex", "found", "hexWrite", "remaining", "strLen", "parsed", "utf8Write", "blitBuffer", "asciiWrite", "asciiToBytes", "latin1Write", "base64Write", "ucs2Write", "utf16leToBytes", "res", "firstByte", "codePoint", "bytesPerSequence", "secondByte", "thirdByte", "fourthByte", "tempCodePoint", "decodeCodePointsArray", "codePoints", "MAX_ARGUMENTS_LENGTH", "ret", "out", "toHex", "bytes", "checkOffset", "ext", "checkInt", "max", "min", "objectWriteUInt16", "littleEndian", "objectWriteUInt32", "checkIEEE754", "writeFloat", "noAssert", "writeDouble", "base64clean", "str", "stringtrim", "INVALID_BASE64_RE", "units", "leadSurrogate", "byteArray", "hi", "lo", "src", "dst", "isFastBuffer", "isSlowBuffer", "toString", "init_buffer", "__esmMin", "init_virtual_process_polyfill", "a", "x", "y", "list", "pos", "target", "thisStart", "thisEnd", "thisCopy", "targetCopy", "newBuf", "sliceLen", "mul", "maxBytes", "limit", "sub", "targetStart", "require_buffer", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "polyfill", "k", "defaultSetTimout", "defaultClearTimeout", "runTimeout", "fun", "cachedSetTimeout", "runClearTimeout", "marker", "cachedClearTimeout", "cleanUpNextTick", "draining", "currentQueue", "queue", "queueIndex", "drainQueue", "timeout", "len", "nextTick", "args", "i", "Item", "array", "noop", "binding", "name", "cwd", "chdir", "dir", "umask", "hrtime", "previousTimestamp", "clocktime", "performanceNow", "performance", "seconds", "nanoseconds", "uptime", "currentTime", "dif", "startTime", "title", "platform", "browser", "env", "argv", "version", "versions", "release", "config", "on", "addListener", "once", "off", "removeListener", "removeAllListeners", "emit", "browser$1", "process_default", "init_process", "__esmMin", "init_virtual_process_polyfill", "init_buffer", "inherits", "inherits_default", "init_inherits", "__esmMin", "init_virtual_process_polyfill", "init_buffer", "ctor", "superCtor", "TempCtor", "util_exports", "__export", "_extend", "debuglog", "util_default", "deprecate", "format", "inherits_default", "inspect", "isArray", "isBoolean", "isBuffer", "isDate", "isError", "isFunction", "isNull", "isNullOrUndefined", "isNumber", "isObject", "isPrimitive", "isRegExp", "isString", "isSymbol", "isUndefined", "log", "f", "objects", "i", "args", "len", "str", "formatRegExp", "x", "fn", "msg", "process_default", "warned", "deprecated", "set", "debugEnviron", "debugs", "pid", "obj", "opts", "ctx", "stylizeNoColor", "stylizeWithColor", "formatValue", "styleType", "style", "arrayToHash", "array", "hash", "val", "idx", "value", "recurseTimes", "ret", "primitive", "formatPrimitive", "keys", "visibleKeys", "formatError", "name", "base", "braces", "n", "output", "formatArray", "key", "formatProperty", "reduceToSingleString", "simple", "l", "hasOwnProperty", "desc", "line", "numLinesEst", "length", "prev", "cur", "ar", "arg", "re", "objectToString", "d", "e", "maybeBuf", "Buffer", "o", "pad", "timestamp", "time", "months", "origin", "add", "prop", "init_util", "__esmMin", "init_virtual_process_polyfill", "init_buffer", "init_process", "init_inherits", "require_util", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "polyfill", "k", "require_buffer_list", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "ownKeys", "object", "enumerableOnly", "keys", "symbols", "sym", "_objectSpread", "target", "i", "source", "key", "_defineProperty", "obj", "value", "_classCallCheck", "instance", "Constructor", "_defineProperties", "props", "descriptor", "_createClass", "protoProps", "staticProps", "_require", "Buffer", "_require2", "inspect", "custom", "copyBuffer", "src", "offset", "BufferList", "v", "entry", "ret", "s", "p", "n", "hasStrings", "c", "str", "nb", "buf", "_", "options", "require_destroy", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "destroy", "err", "cb", "_this", "readableDestroyed", "writableDestroyed", "process", "emitErrorNT", "emitCloseNT", "emitErrorAndCloseNT", "self", "undestroy", "errorOrDestroy", "stream", "rState", "wState", "require_errors_browser", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "_inheritsLoose", "subClass", "superClass", "codes", "createErrorType", "code", "message", "Base", "getMessage", "arg1", "arg2", "arg3", "NodeError", "_Base", "oneOf", "expected", "thing", "len", "i", "startsWith", "str", "search", "pos", "endsWith", "this_len", "includes", "start", "name", "value", "actual", "determiner", "msg", "type", "arg", "require_state", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "ERR_INVALID_OPT_VALUE", "highWaterMarkFrom", "options", "isDuplex", "duplexKey", "getHighWaterMark", "state", "hwm", "name", "require_inherits_browser", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "ctor", "superCtor", "TempCtor", "require_browser", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "deprecate", "fn", "msg", "config", "warned", "deprecated", "name", "val", "require_stream_writable", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "Writable", "CorkedRequest", "state", "_this", "onCorkedFinish", "Duplex", "WritableState", "internalUtil", "Stream", "Buffer", "OurUint8Array", "_uint8ArrayToBuffer", "chunk", "_isUint8Array", "obj", "destroyImpl", "_require", "getHighWaterMark", "_require$codes", "ERR_INVALID_ARG_TYPE", "ERR_METHOD_NOT_IMPLEMENTED", "ERR_MULTIPLE_CALLBACK", "ERR_STREAM_CANNOT_PIPE", "ERR_STREAM_DESTROYED", "ERR_STREAM_NULL_VALUES", "ERR_STREAM_WRITE_AFTER_END", "ERR_UNKNOWN_ENCODING", "errorOrDestroy", "nop", "options", "stream", "isDuplex", "noDecode", "er", "onwrite", "current", "out", "realHasInstance", "object", "writeAfterEnd", "cb", "process", "validChunk", "encoding", "ret", "isBuf", "writeOrBuffer", "clearBuffer", "decodeChunk", "newChunk", "len", "last", "doWrite", "writev", "onwriteError", "sync", "finishMaybe", "onwriteStateUpdate", "finished", "needFinish", "afterWrite", "onwriteDrain", "entry", "l", "buffer", "holder", "count", "allBuffers", "endWritable", "callFinal", "err", "prefinish", "need", "rState", "corkReq", "value", "require_stream_duplex", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "objectKeys", "obj", "keys", "key", "Duplex", "Readable", "Writable", "v", "method", "options", "onend", "process", "onEndNT", "self", "value", "require_safe_buffer", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "buffer", "Buffer", "copyProps", "src", "dst", "key", "SafeBuffer", "arg", "encodingOrOffset", "length", "size", "fill", "encoding", "buf", "require_string_decoder", "__commonJSMin", "exports", "init_virtual_process_polyfill", "init_buffer", "Buffer", "isEncoding", "encoding", "_normalizeEncoding", "enc", "retried", "normalizeEncoding", "nenc", "StringDecoder", "nb", "utf16Text", "utf16End", "utf8FillLast", "base64Text", "base64End", "simpleWrite", "simpleEnd", "buf", "r", "i", "utf8End", "utf8Text", "utf8CheckByte", "byte", "utf8CheckIncomplete", "self", "j", "utf8CheckExtraBytes", "p", "total", "end", "c", "n", "require_end_of_stream", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "ERR_STREAM_PREMATURE_CLOSE", "once", "callback", "called", "_len", "args", "_key", "noop", "isRequest", "stream", "eos", "opts", "readable", "writable", "onlegacyfinish", "onfinish", "writableEnded", "readableEnded", "onend", "onerror", "err", "onclose", "onrequest", "require_async_iterator", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "_Object$setPrototypeO", "_defineProperty", "obj", "key", "value", "finished", "kLastResolve", "kLastReject", "kError", "kEnded", "kLastPromise", "kHandlePromise", "kStream", "createIterResult", "done", "readAndResolve", "iter", "resolve", "data", "onReadable", "process", "wrapForNext", "lastPromise", "reject", "AsyncIteratorPrototype", "ReadableStreamAsyncIteratorPrototype", "_this", "error", "promise", "_this2", "err", "createReadableStreamAsyncIterator", "stream", "_Object$create", "iterator", "require_from_browser", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "require_stream_readable", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "Readable", "Duplex", "ReadableState", "EE", "EElistenerCount", "emitter", "type", "Stream", "Buffer", "OurUint8Array", "_uint8ArrayToBuffer", "chunk", "_isUint8Array", "obj", "debugUtil", "debug", "BufferList", "destroyImpl", "_require", "getHighWaterMark", "_require$codes", "ERR_INVALID_ARG_TYPE", "ERR_STREAM_PUSH_AFTER_EOF", "ERR_METHOD_NOT_IMPLEMENTED", "ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "StringDecoder", "createReadableStreamAsyncIterator", "from", "errorOrDestroy", "kProxyEvents", "prependListener", "event", "fn", "options", "stream", "isDuplex", "value", "err", "cb", "encoding", "state", "skipChunkCheck", "readableAddChunk", "addToFront", "onEofChunk", "er", "chunkInvalid", "addChunk", "maybeReadMore", "emitReadable", "enc", "decoder", "p", "content", "MAX_HWM", "computeNewHighWaterMark", "n", "howMuchToRead", "nOrig", "endReadable", "doRead", "ret", "fromList", "emitReadable_", "process", "flow", "maybeReadMore_", "len", "dest", "pipeOpts", "src", "doEnd", "endFn", "onend", "unpipe", "onunpipe", "readable", "unpipeInfo", "cleanup", "ondrain", "pipeOnDrain", "cleanedUp", "onclose", "onfinish", "onerror", "ondata", "indexOf", "dests", "i", "index", "ev", "res", "nReadingNextTick", "updateReadableListening", "self", "resume", "resume_", "_this", "paused", "method", "endReadableNT", "wState", "iterable", "opts", "xs", "x", "l", "require_stream_transform", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "Transform", "_require$codes", "ERR_METHOD_NOT_IMPLEMENTED", "ERR_MULTIPLE_CALLBACK", "ERR_TRANSFORM_ALREADY_TRANSFORMING", "ERR_TRANSFORM_WITH_LENGTH_0", "Duplex", "afterTransform", "er", "data", "ts", "cb", "rs", "options", "prefinish", "_this", "done", "chunk", "encoding", "n", "err", "err2", "stream", "require_stream_passthrough", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "PassThrough", "Transform", "options", "chunk", "encoding", "cb", "require_pipeline", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "eos", "once", "callback", "called", "_require$codes", "ERR_MISSING_ARGS", "ERR_STREAM_DESTROYED", "noop", "err", "isRequest", "stream", "destroyer", "reading", "writing", "closed", "destroyed", "call", "fn", "pipe", "from", "to", "popCallback", "streams", "pipeline", "_len", "_key", "error", "destroys", "i", "require_readable_browser", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "require_blake", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "Transform", "engine", "options", "chunk", "encoding", "callback", "error", "err", "data", "Buffer", "digest", "require_api", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "Blake", "engines", "getEngine", "algorithm", "options", "Engine", "require_blake", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "Blake", "arr", "j", "data", "block", "offset", "i", "Buffer", "require_blake256", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "Blake", "zo", "Buffer", "oo", "rot", "x", "n", "g", "v", "m", "i", "a", "b", "c", "d", "e", "sigma", "u256", "lo", "hi", "msglen", "buffer", "require_blake224", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "Blake256", "zo", "Buffer", "oo", "buffer", "i", "require_blake512", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "Blake", "zo", "Buffer", "oo", "rot", "v", "i", "j", "n", "hi", "lo", "g", "m", "a", "b", "c", "d", "e", "sigma", "u512", "len", "msglen", "buffer", "require_blake384", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "Blake512", "zo", "Buffer", "oo", "buffer", "i", "require_lib", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "require_js", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "crypto_exports", "__export", "crypto_default", "init_crypto", "__esmMin", "init_virtual_process_polyfill", "init_buffer", "require_utils", "__commonJSMin", "exports", "init_virtual_process_polyfill", "init_buffer", "_a", "len", "b", "v", "i", "a", "require_build_int", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "n64", "_prefix", "prefix", "n32", "n8", "buildCopy", "f", "c", "i", "buildZero", "buildOne", "buildIsZero", "getCompCode", "n", "buildEq", "buildGte", "buildAdd", "buildSub", "buildMul", "loadX", "loadY", "mulij", "j", "X", "Y", "c0", "c1", "k", "buildSquare", "c0_old", "c1_old", "buildSquareOld", "_buildMul1", "_buildAdd1", "buildDiv", "Caux", "Raux", "C", "R", "pr1", "R1", "R2", "buildInverseMod", "aux1", "aux2", "aux3", "aux4", "aux5", "aux6", "mulBuff", "aux7", "require_build_timesscalar", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "fnName", "elementLen", "opAB", "opAA", "opCopy", "opInit", "f", "c", "aux", "innerLoop", "code", "i", "require_build_batchinverse", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "buildBatchInverse", "prefix", "n8", "c", "AUX", "require_build_batchconvertion", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "buildBatchConvertion", "fnName", "internalFnName", "sizeIn", "sizeOut", "reverse", "f", "c", "require_build_batchop", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "buildBatchConvertion", "fnName", "internalFnName", "sizeIn", "sizeOut", "reverse", "f", "c", "require_bigint", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "compare", "a", "b", "square", "n", "isOdd", "isEven", "isNegative", "isPositive", "bitLength", "abs", "isUnit", "modInv", "t", "newT", "r", "newR", "q", "lastT", "lastR", "modPow", "exp", "mod", "base", "compareAbs", "isDivisibleBy", "isBasicPrime", "v", "prev", "millerRabinTest", "nPrev", "d", "i", "x", "next", "isPrime", "p", "bits", "logN", "require_build_f1m", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "buildInt", "utils", "buildExp", "buildBatchInverse", "buildBatchConvertion", "buildBatchOp", "bitLength", "modInv", "modPow", "isPrime", "isOdd", "square", "_q", "_prefix", "_intPrefix", "q", "n64", "n32", "n8", "prefix", "intPrefix", "pq", "pR2", "pOne", "pZero", "_minusOne", "_e", "pe", "_ePlusOne", "pePlusOne", "buildOne", "f", "c", "buildAdd", "buildSub", "buildNeg", "buildIsNegative", "AUX", "buildSign", "buildMReduct", "carries", "np32", "i", "j", "buildMul", "loadX", "loadY", "loadQ", "mulij", "X", "Y", "mulqm", "Q", "M", "c0", "c1", "k", "buildSquare", "c0_old", "c1_old", "buildSquareOld", "buildToMontgomery", "buildFromMontgomery", "pAux2", "buildInverse", "_nqr", "s2", "_t", "pt", "_nqrToT", "pNqrToT", "_tPlusOneOver2", "ptPlusOneOver2", "buildSqrt", "ONE", "C", "T", "R", "SQ", "B", "buildIsSquare", "buildLoad", "pAux", "buildTimesScalar", "buildIsOne", "require_build_f1", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "buildF1m", "bitLength", "_q", "_prefix", "_f1mPrefix", "_intPrefix", "q", "n64", "n8", "prefix", "intPrefix", "f1mPrefix", "pR2", "pq", "pePlusOne", "buildMul", "pAux1", "f", "c", "buildSquare", "buildInverse", "buildIsNegative", "require_build_f2m", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "buildExp", "buildBatchInverse", "utils", "mulNonResidueFn", "prefix", "f1mPrefix", "f1n8", "q", "buildAdd", "f", "c", "x0", "x1", "y0", "y1", "r0", "r1", "buildTimesScalar", "buildSub", "buildNeg", "buildConjugate", "buildIsNegative", "buildMul", "A", "B", "C", "D", "buildMul1", "y", "buildSquare", "AB", "APB", "APNB", "ABPNAB", "buildToMontgomery", "buildFromMontgomery", "buildCopy", "buildZero", "buildOne", "buildEq", "buildIsZero", "buildInverse", "t0", "t1", "t2", "t3", "buildSign", "buildIsOne", "buildSqrt", "e34", "e12", "a", "a1", "alpha", "a0", "pn1", "n1", "n1a", "n1b", "b", "buildIsSquare", "require_build_f3m", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "buildExp", "buildBatchInverse", "mulNonResidueFn", "prefix", "f1mPrefix", "f1n8", "buildAdd", "f", "c", "x0", "x1", "x2", "y0", "y1", "y2", "r0", "r1", "r2", "buildTimesScalar", "buildSub", "buildNeg", "buildIsNegative", "buildMul", "cd", "a", "b", "A", "B", "C", "aA", "bB", "cC", "a_b", "A_B", "a_c", "A_C", "b_c", "B_C", "aA_bB", "aA_cC", "bB_cC", "AUX", "buildSquare", "s0", "ab", "s1", "s2", "bc", "s3", "s4", "buildToMontgomery", "buildFromMontgomery", "buildCopy", "buildZero", "buildOne", "buildEq", "buildIsZero", "buildInverse", "t0", "t1", "t2", "t3", "t4", "t5", "c0", "c1", "c2", "t6", "buildSign", "buildIsOne", "require_build_timesscalarnaf", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "fnName", "elementLen", "opAB", "opAA", "opAmB", "opCopy", "opInit", "f", "c", "aux", "getBit", "IDX", "pushBit", "b", "require_build_multiexp", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "prefix", "fnName", "opAdd", "n8b", "n8g", "buildGetChunk", "f", "c", "buildMutiexpChunk", "buildMultiexp", "aux", "pTSizes", "buildReduceTable", "require_build_curve_jacobian_a0", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "buildTimesScalarNAF", "buildBatchConvertion", "buildMultiexp", "prefix", "prefixField", "pB", "n64", "n8", "buildIsZero", "f", "c", "buildIsZeroAffine", "buildCopy", "i", "buildCopyAffine", "buildZero", "buildZeroAffine", "buildEq", "x1", "y1", "z1", "x2", "y2", "z2", "Z1Z1", "Z2Z2", "U1", "U2", "Z1_cubed", "Z2_cubed", "S1", "S2", "buildEqMixed", "buildDouble", "x", "y", "z", "x3", "y3", "z3", "A", "B", "C", "D", "E", "F", "G", "eightC", "buildDoubleAffine", "XX", "YY", "YYYY", "S", "M", "eightYYYY", "buildEqAffine", "buildToMontgomery", "buildToMontgomeryAffine", "buildFromMontgomery", "buildFromMontgomeryAffine", "buildAdd", "H", "S2_minus_S1", "I", "J", "r", "r2", "V", "V2", "S1_J2", "buildAddMixed", "HH", "S2_minus_y1", "y1_J2", "buildAddAffine", "y2_minus_y1", "buildNeg", "buildNegAffine", "buildSub", "AUX", "buildSubMixed", "buildSubAffine", "buildNormalize", "Z_inv", "Z2_inv", "Z3_inv", "buildToAffine", "buildToJacobian", "buildBatchToAffine", "tmp", "buildReverseBytes", "buildLEMtoC", "buildLEMtoU", "pTmp", "tmpX", "tmpY", "buildUtoLEM", "buildCtoLEM", "buildInCurveAffine", "x3b", "buildInCurve", "aux", "require_build_fft", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "isOdd", "modInv", "modPow", "utils", "prefix", "gPrefix", "fPrefix", "opGtimesF", "n8f", "n8g", "q", "rem", "maxBits", "nr", "w", "n", "bytes", "R", "i", "m", "ROOTs", "i2", "bytesi2", "INV2", "shift", "bytesShiftToSmallM", "bytesSConst", "shiftToSmallM", "sConst", "SHIFT_TO_M", "SCONST", "rev", "x", "r", "rtable", "REVTABLE", "buildLog2", "f", "c", "buildFFT", "One", "buildIFFT", "buildRawFFT", "W", "T", "U", "buildFinalInverse", "buildReversePermutation", "buildRev", "buildFFTJoin", "buildFFTJoinExt", "buildFFTJoinExtInv", "buildPrepareLagrangeEvaluation", "buildFFTMix", "buildFFTFinal", "require_build_pol", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "prefix", "prefixField", "n8", "buildZero", "f", "c", "buildConstructLC", "aux", "require_build_qap", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "prefix", "prefixField", "n8", "buildBuildABC", "f", "c", "aux", "buildJoinABC", "buildBatchAdd", "require_build_applykey", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "fnName", "gPrefix", "frPrefix", "sizeGIn", "sizeGOut", "sizeF", "opGtimesF", "f", "c", "t", "require_build_bn128", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "utils", "buildF1m", "buildF1", "buildF2m", "buildF3m", "buildCurve", "buildFFT", "buildPol", "buildQAP", "buildApplyKey", "bitLength", "modInv", "isOdd", "isNegative", "_prefix", "prefix", "q", "r", "n64", "n8", "frsize", "f1size", "f2size", "ftsize", "pr", "f1mPrefix", "pG1b", "toMontgomery", "g1mPrefix", "f2mPrefix", "pG2b", "g2mPrefix", "buildGTimesFr", "fnName", "opMul", "f", "c", "AUX", "a", "G1gen", "pG1gen", "G1zero", "pG1zero", "G2gen", "pG2gen", "G2zero", "pG2zero", "pOneT", "pNonResidueF6", "pTwoInv", "pAltBn128Twist", "pTwistCoefB", "build_mulNR6", "f6mPrefix", "build_mulNR12", "ftmPrefix", "ateLoopBitBytes", "bits", "pAteLoopBitBytes", "isLoopNegative", "ateCoefSize", "ateNDblCoefs", "ateNCoefs", "acc", "b", "prePSize", "preQSize", "finalExpIsNegative", "finalExpZ", "naf", "n", "E", "res", "z", "buildPrepareG1", "buildPrepAddStep", "X2", "Y2", "X1", "Y1", "Z1", "ELL_0", "ELL_VW", "ELL_VV", "D", "F", "G", "H", "I", "J", "buildPrepDoubleStep", "A", "B", "C", "E2", "buildMulByQ", "x", "y", "x3", "y3", "z3", "MulByQX", "MulByQY", "buildPrepareG2", "QX", "pR", "R", "RX", "RY", "RZ", "cQX", "cQY", "pQ1", "Q1", "pQ2", "Q2", "Q2Y", "buildMulBy024Old", "x0", "x2", "x4", "z0", "pAUX12", "AUX12", "AUX12_0", "AUX12_2", "AUX12_4", "AUX12_6", "AUX12_8", "AUX12_10", "buildMulBy024", "z1", "z2", "z4", "z5", "t0", "t1", "t2", "s0", "T3", "T4", "D0", "D2", "D4", "S1", "buildMillerLoop", "preP_PX", "preP_PY", "pVW", "VW", "pVV", "VV", "buildFrobeniusMap", "F12", "F6", "i", "X", "Xc0", "Xc1", "Rc0", "Rc1", "coef", "mul2", "pCoef", "ac0", "ac1", "bc0", "bc1", "buildFinalExponentiationFirstChunk", "elt", "eltC0", "eltC1", "pA", "Ac0", "Ac1", "buildCyclotomicSquare", "x1", "x5", "r0", "r4", "r3", "r2", "r1", "r5", "t3", "t4", "t5", "tmp", "buildCyclotomicExp", "exponent", "exponentNafBytes", "pExponentNafBytes", "inverse", "buildFinalExponentiationLastChunk", "result", "K", "L", "M", "N", "O", "P", "Q", "S", "T", "U", "buildFinalExponentiation", "eltToFirstChunk", "buildFinalExponentiationOld", "pExponent", "pPreP", "pPreQ", "buildPairingEquation", "nPairings", "resT", "auxT", "buildPairing", "require_build_bls12381", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "utils", "buildF1m", "buildF1", "buildF2m", "buildF3m", "buildCurve", "buildFFT", "buildPol", "buildQAP", "buildApplyKey", "bitLength", "isOdd", "isNegative", "_prefix", "prefix", "q", "r", "n64q", "n8q", "f1size", "f2size", "ftsize", "n64r", "n8r", "frsize", "pr", "f1mPrefix", "pG1b", "toMontgomery", "g1mPrefix", "f2mPrefix", "pG2b", "g2mPrefix", "buildGTimesFr", "fnName", "opMul", "f", "c", "AUX", "a", "G1gen", "pG1gen", "G1zero", "pG1zero", "G2gen", "pG2gen", "G2zero", "pG2zero", "pOneT", "pBls12381Twist", "build_mulNR2", "x0c", "x0", "x1", "r0", "r1", "f6mPrefix", "build_mulNR6", "c0copy", "ftmPrefix", "ateLoopBitBytes", "bits", "pAteLoopBitBytes", "isLoopNegative", "ateCoefSize", "ateNDblCoefs", "ateNCoefs", "acc", "b", "prePSize", "preQSize", "finalExpIsNegative", "finalExpZ", "naf", "n", "E", "res", "z", "buildPrepareG1", "buildPrepDoubleStep", "Rx", "Ry", "Rz", "t0", "t3", "t6", "zsquared", "t1", "t2", "t4", "t5", "buildPrepAddStep", "Qx", "Qy", "t10", "t9", "ysquared", "ztsquared", "t7", "t8", "buildPrepareG2", "Q", "pR", "R", "base", "buildF6Mul1", "A_c0", "A_c1", "A_c2", "c1", "b_b", "Ac0_Ac1", "Ac1_Ac2", "buildF6Mul01", "c0", "a_a", "Ac0_Ac2", "buildF12Mul014", "c4", "aa", "bb", "o", "R_c0", "R_c1", "buildELL", "Px", "Py", "F", "coef0_0", "coef0_1", "coef1_0", "coef1_1", "coef2", "pc0", "c0_c0", "c0_c1", "pc1", "c1_c0", "c1_c1", "buildMillerLoop", "preP", "coefs", "buildFrobeniusMap", "F12", "F6", "i", "X", "Xc0", "Xc1", "Rc0", "Rc1", "coef", "mul2", "pCoef", "ac0", "ac1", "bc0", "bc1", "buildCyclotomicSquare", "x4", "x3", "x2", "x5", "r4", "r3", "r2", "r5", "tmp", "buildCyclotomicExp", "exponent", "isExpNegative", "exponentNafBytes", "pExponentNafBytes", "x", "inverse", "buildFinalExponentiation", "elt", "buildFinalExponentiationOld", "pExponent", "pPreP", "pPreQ", "buildPairingEquation", "nPairings", "resT", "auxT", "buildPairing", "buildInGroupG2", "WINV", "FROB2X", "FROB3Y", "wInv", "frob2X", "frob3Y", "px", "py", "aux", "x_winv", "y_winv", "pf2", "f2", "f2x", "f2x_c1", "f2x_c2", "f2y", "f2y_c1", "f2y_c2", "pf3", "f3", "f3x", "f3x_c1", "f3x_c2", "f3y", "f3y_c1", "f3y_c2", "f3z", "fInGroup", "c2", "aux2", "buildInGroupG1", "BETA", "BETA2", "Z2M1D3", "beta", "beta2", "z2m1d3", "psp", "sp", "spx", "spy", "ps2p", "s2p", "s2px", "s2py", "require_wasmcurves", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "require_browser", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "require_base64_js", "__commonJSMin", "exports", "init_virtual_process_polyfill", "init_buffer", "byteLength", "toByteArray", "fromByteArray", "lookup", "revLookup", "Arr", "code", "i", "len", "getLens", "b64", "validLen", "placeHoldersLen", "lens", "_byteLength", "tmp", "arr", "curByte", "tripletToBase64", "num", "encodeChunk", "uint8", "start", "end", "output", "extraBytes", "parts", "maxChunkLength", "len2", "require_ieee754", "__commonJSMin", "exports", "init_virtual_process_polyfill", "init_buffer", "buffer", "offset", "isLE", "mLen", "nBytes", "e", "m", "eLen", "eMax", "eBias", "nBits", "i", "d", "s", "value", "c", "rt", "require_buffer", "__commonJSMin", "exports", "init_virtual_process_polyfill", "init_buffer", "base64", "ieee754", "customInspectSymbol", "Buffer", "SlowBuffer", "K_MAX_LENGTH", "typedArraySupport", "arr", "proto", "createBuffer", "length", "buf", "arg", "encodingOrOffset", "allocUnsafe", "from", "value", "fromString", "fromArrayView", "isInstance", "fromArrayBuffer", "valueOf", "b", "fromObject", "assertSize", "size", "alloc", "fill", "encoding", "checked", "string", "byteLength", "actual", "fromArrayLike", "array", "i", "arrayView", "copy", "byteOffset", "obj", "len", "numberIsNaN", "a", "x", "y", "list", "buffer", "pos", "mustMatch", "loweredCase", "utf8ToBytes", "base64ToBytes", "slowToString", "start", "end", "hexSlice", "utf8Slice", "asciiSlice", "latin1Slice", "base64Slice", "utf16leSlice", "swap", "n", "m", "str", "max", "target", "thisStart", "thisEnd", "thisCopy", "targetCopy", "bidirectionalIndexOf", "val", "dir", "arrayIndexOf", "indexSize", "arrLength", "valLength", "read", "foundIndex", "found", "j", "hexWrite", "offset", "remaining", "strLen", "parsed", "utf8Write", "blitBuffer", "asciiWrite", "asciiToBytes", "base64Write", "ucs2Write", "utf16leToBytes", "res", "firstByte", "codePoint", "bytesPerSequence", "secondByte", "thirdByte", "fourthByte", "tempCodePoint", "decodeCodePointsArray", "MAX_ARGUMENTS_LENGTH", "codePoints", "ret", "out", "hexSliceLookupTable", "bytes", "newBuf", "checkOffset", "ext", "noAssert", "mul", "checkInt", "min", "maxBytes", "limit", "sub", "checkIEEE754", "writeFloat", "littleEndian", "writeDouble", "targetStart", "code", "INVALID_BASE64_RE", "base64clean", "units", "leadSurrogate", "byteArray", "c", "hi", "lo", "src", "dst", "type", "alphabet", "table", "i16", "require_crypto", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "polyfill", "k", "require_cross_sha256", "__commonJSMin", "exports", "init_virtual_process_polyfill", "init_buffer", "buffer_1", "sha256js", "data", "encoding", "block", "blockSize", "length", "accum", "offset", "assigned", "remainder", "i", "rem", "bits", "lowBits", "highBits", "hash", "x", "y", "z", "M", "W", "a", "b", "c", "d", "e", "f", "g", "h", "j", "T1", "T2", "sha256nodeCrypto", "_nodeCryptoAvailable", "isNodeCryptoAvailable", "isAvailable", "__require", "cryptoModule", "sha256", "hashSha256", "require_base58_chars", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "base58_chars", "require_base58_to_binary", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "base58_chars", "base58_to_binary", "base58String", "lz", "psz", "size", "i", "acc", "j", "x", "lastValue", "value", "require_create_base58_map", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "base58_chars", "create_base58_map", "base58M", "i", "require_binary_to_base58", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "base58_chars", "create_base58_map", "base58Map", "binary_to_base58", "uint8array", "result", "byte", "carry", "j", "x", "require_public", "__commonJSMin", "exports", "init_virtual_process_polyfill", "init_buffer", "require_lib", "__commonJSMin", "exports", "init_virtual_process_polyfill", "init_buffer", "parse", "string", "encoding", "opts", "_opts$out", "i", "end", "out", "bits", "buffer", "written", "_i", "value", "stringify", "data", "_opts", "_opts$pad", "pad", "mask", "base16Encoding", "base32Encoding", "base32HexEncoding", "base64Encoding", "base64UrlEncoding", "base16", "base32", "base32hex", "base64", "base64url", "codec", "fs_exports", "__export", "fs_default", "init_fs", "__esmMin", "init_virtual_process_polyfill", "init_buffer", "require_nanoassert", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "assert", "AssertionError", "t", "m", "err", "require_ascii", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "byteLength", "string", "toString", "buffer", "len", "result", "i", "write", "offset", "length", "require_base64", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "alphabet", "codes", "i", "byteLength", "string", "len", "toString", "buffer", "result", "write", "offset", "length", "j", "a", "b", "c", "d", "require_hex", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "byteLength", "string", "toString", "buffer", "len", "result", "i", "n", "write", "offset", "length", "a", "hexValue", "b", "char", "require_utf8", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "byteLength", "string", "length", "i", "n", "code", "toString", "decoder", "buffer", "len", "output", "byte", "bytesNeeded", "codePoint", "k", "write", "encoder", "offset", "j", "count", "bits", "require_utf16le", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "byteLength", "string", "toString", "buffer", "len", "result", "i", "write", "offset", "length", "units", "c", "hi", "lo", "require_browser", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "ascii", "base64", "hex", "utf8", "utf16le", "LE", "codecFor", "encoding", "isBuffer", "value", "isEncoding", "alloc", "size", "fill", "buffer", "allocUnsafe", "allocUnsafeSlow", "byteLength", "string", "compare", "a", "b", "len", "i", "n", "x", "y", "concat", "buffers", "totalLength", "result", "offset", "copy", "source", "target", "targetStart", "start", "end", "equals", "from", "encodingOrOffset", "length", "fromString", "fromArray", "fromBuffer", "fromArrayBuffer", "codec", "array", "arrayBuffer", "byteOffset", "includes", "indexOf", "bidirectionalIndexOf", "first", "foundIndex", "found", "j", "lastIndexOf", "swap", "m", "swap16", "swap32", "swap64", "toBuffer", "toString", "write", "writeDoubleLE", "writeFloatLE", "writeUInt32LE", "writeInt32LE", "readDoubleLE", "readFloatLE", "readUInt32LE", "readInt32LE", "require_blake2b", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "__commonJS", "cb", "mod", "__toBinary", "table", "i", "base64", "n", "bytes2", "i2", "j", "c0", "c1", "c2", "c3", "exports2", "module2", "bytes", "compiled", "imports", "require_blake2b_wasm", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "assert", "b4a", "wasm", "wasmPromise", "mod", "head", "freeList", "Blake2b", "BYTES_MIN", "BYTES_MAX", "BYTES", "KEYBYTES_MIN", "KEYBYTES_MAX", "KEYBYTES", "SALTBYTES", "PERSONALBYTES", "digestLength", "key", "salt", "personal", "noAssert", "size", "input", "enc", "i", "cb", "noop", "ph", "require_fs", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "polyfill", "k", "path_exports", "__export", "basename", "path_default", "delimiter", "dirname", "extname", "isAbsolute", "join", "normalize", "relative", "resolve", "sep", "normalizeArray", "parts", "allowAboveRoot", "up", "i", "last", "resolvedPath", "resolvedAbsolute", "path", "filter", "p", "isPathAbsolute", "trailingSlash", "substr", "paths", "index", "from", "to", "trim", "arr", "start", "end", "fromParts", "toParts", "length", "samePartsLength", "outputParts", "result", "splitPath", "root", "dir", "ext", "f", "xs", "res", "splitPathRe", "init_path", "__esmMin", "init_virtual_process_polyfill", "init_buffer", "filename", "str", "len", "require_path", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "polyfill", "k", "require_utils", "__commonJSMin", "exports", "init_virtual_process_polyfill", "init_buffer", "regExpChars", "hasOwnProperty", "hasOwn", "obj", "key", "string", "_ENCODE_HTML_RULES", "_MATCH_HTML", "encode_char", "escapeFuncStr", "markup", "to", "from", "p", "list", "i", "val", "str", "match", "require_ejs", "__commonJSMin", "exports", "init_virtual_process_polyfill", "init_buffer", "fs", "path", "utils", "scopeOptionWarned", "_VERSION_STRING", "_DEFAULT_OPEN_DELIMITER", "_DEFAULT_CLOSE_DELIMITER", "_DEFAULT_DELIMITER", "_DEFAULT_LOCALS_NAME", "_NAME", "_REGEX_STRING", "_OPTS_PASSABLE_WITH_DATA", "_OPTS_PASSABLE_WITH_DATA_EXPRESS", "_BOM", "_JS_IDENTIFIER", "name", "filename", "isDir", "dirname", "extname", "resolve", "includePath", "ext", "resolvePaths", "paths", "filePath", "v", "getIncludePath", "options", "views", "match", "handleCache", "template", "func", "hasTemplate", "fileLoader", "tryHandleCache", "data", "cb", "result", "err", "reject", "includeFile", "opts", "includerResult", "rethrow", "str", "flnm", "lineno", "esc", "lines", "start", "end", "context", "line", "i", "curr", "stripSemi", "templ", "Template", "d", "o", "args", "viewOpts", "text", "delim", "open", "close", "src", "fn", "prepended", "appended", "escapeFn", "ctor", "sanitizedFilename", "destructuring", "e", "returnedFn", "include", "includeData", "basename", "self", "matches", "c", "index", "closing", "pat", "arr", "firstPos", "newLineCount", "require_sha3", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "INPUT_ERROR", "FINALIZE_ERROR", "WINDOW", "root", "WEB_WORKER", "NODE_JS", "process", "COMMON_JS", "AMD", "ARRAY_BUFFER", "HEX_CHARS", "SHAKE_PADDING", "CSHAKE_PADDING", "KECCAK_PADDING", "PADDING", "SHIFT", "RC", "BITS", "SHAKE_BITS", "OUTPUT_TYPES", "CSHAKE_BYTEPAD", "obj", "createOutputMethod", "bits", "padding", "outputType", "message", "Keccak", "createShakeOutputMethod", "outputBits", "createCshakeOutputMethod", "n", "s", "methods", "createKmacOutputMethod", "key", "createOutputMethods", "method", "createMethod", "i", "type", "createShakeMethod", "createCshakeMethod", "w", "createKmacMethod", "Kmac", "algorithms", "methodNames", "algorithm", "j", "methodName", "newMethodName", "notString", "blocks", "byteCount", "length", "blockCount", "index", "code", "f", "x", "right", "o", "bytes", "str", "strs", "paddingBytes", "zeros", "outputBlocks", "extraBytes", "hex", "block", "buffer", "array", "offset", "h", "l", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "b10", "b11", "b12", "b13", "b14", "b15", "b16", "b17", "b18", "b19", "b20", "b21", "b22", "b23", "b24", "b25", "b26", "b27", "b28", "b29", "b30", "b31", "b32", "b33", "b34", "b35", "b36", "b37", "b38", "b39", "b40", "b41", "b42", "b43", "b44", "b45", "b46", "b47", "b48", "b49", "src_exports", "__export", "Header", "ProvingMethodAlg", "Token", "hash", "proving", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_blake_hash", "init_virtual_process_polyfill", "init_buffer", "Hex", "n", "src", "dst", "j", "i", "s", "c", "a", "b", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "scalar_exports", "__export", "abs", "add", "band", "bitLength", "bits", "bor", "bxor", "div", "e", "eq", "exp", "fromArray", "fromRprBE", "fromRprLE", "fromString", "geq", "gt", "isNegative", "isOdd", "isZero", "land", "leq", "lnot", "lor", "lt", "mod", "mul", "naf", "neg", "neq", "one", "pow", "shiftLeft", "shiftRight", "shl", "shr", "square", "sub", "toArray", "toLEBuff", "toNumber", "toRprBE", "toRprLE", "toString", "zero", "init_virtual_process_polyfill", "init_buffer", "hexLen", "s", "radix", "a", "acc", "i", "aS", "n", "E", "res", "z", "rem", "b", "buff", "o", "n8", "v", "l", "ch", "init_virtual_process_polyfill", "init_buffer", "_revTable", "i", "_revSlow", "idx", "bits", "res", "a", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "exp", "F", "base", "e", "isZero", "n", "bits", "res", "i", "init_virtual_process_polyfill", "init_buffer", "buildSqrt", "F", "eq", "mod", "alg5_tonelliShanks", "alg4_kong", "alg3_atkin", "alg2_shanks", "pm2mod4", "pow", "alg10_adj", "alg9_adj", "alg8_complex", "sub", "isOdd", "div", "c0", "c", "w", "a0", "v", "x", "b", "z", "b2k", "k", "i", "a", "a1", "n", "alfa", "x0", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_crypto", "getRandomBytes", "n", "array", "process", "i", "crypto_default", "init_virtual_process_polyfill", "init_buffer", "FFT", "G", "F", "opMulGF", "rem", "s", "nqr", "n", "i", "r", "nroots", "rootsi", "j", "p", "bits", "log2", "m", "__fft", "res", "twoinvm", "resn", "V", "PF", "pall", "offset", "step", "ndiv2", "p1", "p2", "out", "ZqField", "p", "bitLength", "e", "r", "buildSqrt", "FFT", "a", "b", "res", "nres", "base", "s", "aa", "bb", "t", "newt", "newr", "q", "exp", "nb", "n", "m", "c", "sq", "i", "j", "na", "nBytes", "getRandomBytes", "vs", "rng", "v", "buff", "o", "toRprLE", "toRprBE", "fromRprLE", "fromRprBE", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_wasmcurves", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "utils_exports", "__export", "array2buffer", "beBuff2int", "beInt2Buff", "bitReverse", "buffReverseBits", "buffer2array", "leBuff2int", "leInt2Buff", "log2", "stringifyBigInts", "stringifyFElements", "unstringifyBigInts", "unstringifyFElements", "init_virtual_process_polyfill", "init_buffer", "stringifyBigInts", "o", "fromRprLE", "res", "k", "unstringifyBigInts", "beBuff2int", "buff", "i", "offset", "buffV", "beInt2Buff", "n", "len", "r", "leBuff2int", "leInt2Buff", "bitLength", "stringifyFElements", "F", "unstringifyFElements", "_revTable", "_revSlow", "idx", "bits", "a", "bitReverse", "log2", "V", "buffReverseBits", "eSize", "tmp", "array2buffer", "arr", "sG", "buffer2array", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "BigBuffer", "size", "i", "n", "fr", "to", "len", "firstPage", "lastPage", "buff", "p", "o", "r", "l", "srcView", "offset", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "thread", "self", "instance", "memory", "e", "data", "init", "res", "runTask", "code", "wasmModule", "alloc", "length", "u32", "currentPages", "requiredPages", "allocBuffer", "buffer", "p", "setBuffer", "getBuffer", "pointer", "u8", "task", "ctx", "oldAlloc", "i", "params", "j", "u32b", "init_virtual_process_polyfill", "init_buffer", "_endianness", "endianness", "a", "b", "c", "hostname", "loadavg", "uptime", "freemem", "totalmem", "cpus", "type", "release", "networkInterfaces", "getNetworkInterfaces", "tmpDir", "tmpdir", "EOL", "os_default", "networkInterfaces", "getNetworkInterfaces", "release", "type", "cpus", "totalmem", "freemem", "uptime", "loadavg", "hostname", "endianness", "import_web_worker", "stringToBase64", "str", "process", "Buffer", "threadSource", "thread", "workerSource", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "toNumber", "n", "isNegative", "isZero", "bitLength", "u32", "b", "v", "toUTF8Array", "str", "utf8", "i", "charcode", "string", "bytes", "varuint32", "varuint", "n", "code", "v", "toNumber", "isNegative", "isZero", "varint", "_n", "sign", "bits", "bitLength", "paddingBits", "padding", "paddingMask", "varint32", "varint64", "toHexString", "byteArray", "byte", "CodeBuilder", "func", "localName", "valCode", "idx", "varuint32", "idxCode", "_offset", "_align", "offset", "align", "_codeVal", "codeVal", "fnName", "args", "fnIdx", "condCode", "thenCode", "elseCode", "bCode", "relPath", "rCode", "dCode", "num", "varint64", "varint32", "opcode", "op1code", "op2code", "typeCodes", "FunctionBuilder", "module", "fnName", "fnType", "moduleName", "fieldName", "paramName", "paramType", "idx", "localName", "localType", "_length", "length", "returnType", "params", "varuint32", "p", "returns", "locals", "l", "body", "code", "CodeBuilder", "ModuleBuilder", "u32", "fnName", "idx", "FunctionBuilder", "moduleName", "_fieldName", "fieldName", "pagesSize", "_exportName", "exportName", "offset", "bytes", "a", "b", "size", "p", "s", "uint8array", "signatureIdxByName", "signature", "signatureName", "toHexString", "i", "sectionType", "section", "varuint32", "entries", "string", "varint32", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_wasmcurves", "init_virtual_process_polyfill", "init_buffer", "bls12381r", "e", "bn128r", "bls12381q", "bn128q", "Scalar", "scalar_exports", "utils", "utils_exports", "BabyJub", "F", "Scalar", "a", "b", "res", "beta", "gamma", "delta", "tau", "dtau", "base", "e", "rem", "exp", "P", "x2", "y2", "buff", "n", "sign", "x2h", "x", "ZqField", "babyJub", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "OPT", "utils", "poseidon_constants_opt_default", "N_ROUNDS_F", "N_ROUNDS_P", "SPONGE_INPUTS", "SPONGE_CHUNK_SIZE", "F", "ZqField", "Scalar", "pow5", "a", "Poseidon", "inputs", "t", "nRoundsF", "nRoundsP", "C", "S", "M", "P", "state", "i", "r", "_", "acc", "j", "s0", "k", "msg", "dirty", "hash", "buff", "v", "idx", "poseidon", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "Constants", "init_virtual_process_polyfill", "init_buffer", "import_cross_sha256", "init_virtual_process_polyfill", "init_buffer", "fromLittleEndian", "bytes", "n256", "result", "base", "byte", "fromBigEndian", "toLittleEndian", "bigNumber", "len", "i", "toBigEndian", "checkBigIntInField", "a", "Constants", "BytesHelper", "int", "Constants", "n", "toLittleEndian", "bytes", "typ", "genesis", "checksum", "c", "b", "len", "s", "acc", "cur", "str", "hash", "buffer", "Buffer", "hex", "i", "current", "fromLittleEndian", "ElemBytes", "value", "checkBigIntInField", "Hex", "elements", "result", "element", "SchemaHash", "bytes", "Constants", "Hex", "s", "schemaEncodedBytes", "i", "BytesHelper", "start", "init_virtual_process_polyfill", "init_buffer", "base58Js", "Id", "typ", "genesis", "BytesHelper", "bytes", "b", "fromLittleEndian", "id", "Constants", "i", "s", "bigInt", "nonce", "bigIntHash", "poseidon", "state", "idenStateData", "ElemBytes", "idGenesisBytes", "SlotName", "SubjectFlag", "IdPosition", "MerklizedFlag", "MerklizedRootPosition", "Flags", "init_virtual_process_polyfill", "init_buffer", "Blockchain", "NetworkId", "DidMethod", "DIDMethodByte", "DIDMethodNetwork", "DidMethod", "import_cross_sha256", "qString", "hash", "message", "hashBytes", "bi", "fromBigEndian", "m", "checkBigIntInField", "poseidon", "a", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "ProvingMethodAlg", "alg", "circuitId", "provingMethods", "registerProvingMethod", "f", "res", "getProvingMethod", "rej", "func", "method", "prepare", "f", "hash", "circuitId", "init_virtual_process_polyfill", "init_buffer", "import_index", "base16", "cjs", "base32", "base32hex", "base64", "base64url", "codec", "Header", "RawJSONWebZeroknowledge", "payload", "protectedHeaders", "header", "zkp", "headers", "key", "alg", "circuitId", "method", "getProvingMethod", "ProvingMethodAlg", "token", "Token", "value", "inputsPreparer", "tokenStr", "parts", "rawProtected", "base64url", "rawPayload", "proof", "provingKey", "wasm", "msgHash", "inputs", "prepare", "marshaledProof", "serializedProtected", "serializedProof", "serializedPayload", "serializedHeadersJSON", "serializedHeaders", "messageToProof", "hashInt", "hash", "toBigEndian", "verificationKey", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "witnessBuilder", "code", "options", "wasmModule", "err", "wc", "errStr", "msgStr", "instance", "getMessage", "msg", "printSharedRWMemory", "sanityCheck", "WitnessCalculator", "message", "c", "shared_rw_memory_size", "arr", "j", "fromArray32", "i", "input", "keys", "input_counter", "k", "h", "fnvHash", "hMSB", "hLSB", "fArr", "flatArray", "signalSize", "arrFr", "toArray32", "w", "buff32", "buff", "pos", "n8", "idSection1lengthHex", "idSection2lengthHex", "rem", "size", "res", "radix", "a", "fillArray", "str", "uint64_max", "hash", "shash", "n", "init_virtual_process_polyfill", "init_buffer", "groth16_exports", "__export", "groth16ExportSolidityCallData", "groth16FullProve", "groth16Prove", "groth16Verify", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_fs", "open", "fileName", "openFlags", "cacheSize", "pageSize", "fd", "fs_default", "stats", "FastFile", "p", "self", "P", "resolve", "reject", "s", "logEntry", "S", "i", "page", "j", "pageIdxs", "deletablePages", "freePages", "ops", "load", "idx", "fp", "getNewPage", "res", "loading", "err", "buff", "pos", "firstPage", "lastPage", "pagePromises", "o", "r", "l", "srcView", "len", "buffDst", "offset", "v", "tmpBuff32", "tmpBuff64", "tmpBuff64v", "b", "view", "currentPosition", "currentPage", "endOfStringFound", "str", "pagePromise", "offsetOnPage", "dataArray", "indexEndOfString", "element", "init_virtual_process_polyfill", "init_buffer", "createNew", "o", "initialSize", "fd", "MemFile", "readExisting", "tmpBuff32", "tmpBuff32v", "tmpBuff64", "tmpBuff64v", "MemFile", "newLen", "newAllocSize", "newData", "buff", "pos", "buffDest", "offset", "len", "buffSrc", "self", "v", "b", "view", "currentPosition", "dataArray", "indexEndOfString", "element", "endOfStringFound", "str", "init_virtual_process_polyfill", "init_buffer", "createNew", "o", "initialSize", "fd", "BigMemFile", "nPages", "i", "readExisting", "tmpBuff32", "tmpBuff32v", "tmpBuff64", "tmpBuff64v", "BigMemFile", "newLen", "nPages", "i", "newSize", "p", "buff", "pos", "self", "o", "srcView", "buffDst", "offset", "len", "r", "l", "v", "b", "view", "fixedSize", "currentPosition", "endOfStringFound", "str", "currentPage", "offsetOnPage", "readLength", "dataArray", "indexEndOfString", "element", "init_virtual_process_polyfill", "init_buffer", "O_RDONLY", "O_RDWR", "O_CREAT", "O_TRUNC", "DEFAULT_CACHE_SIZE", "DEFAULT_PAGE_SIZE", "createOverride", "o", "b", "c", "open", "O_TRUNC", "O_CREAT", "O_RDWR", "createNew", "readExisting", "o", "b", "c", "process", "res", "ab", "DEFAULT_CACHE_SIZE", "DEFAULT_PAGE_SIZE", "open", "O_RDONLY", "readBinFile", "fileName", "type", "maxVersion", "cacheSize", "pageSize", "fd", "readExisting", "b", "readedType", "i", "nSections", "sections", "ht", "hl", "createBinFile", "version", "createOverride", "buff", "startWriteSection", "idSection", "endWriteSection", "sectionSize", "oldPos", "startReadUniqueSection", "endReadSection", "noCheck", "writeBigInt", "n", "n8", "pos", "Scalar", "readBigInt", "readSection", "fd", "sections", "idSection", "offset", "length", "buff", "BigBuffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "scalar_exports", "__export", "abs", "add", "band", "bitLength", "bits", "bor", "bxor", "div", "e", "eq", "exp", "fromArray", "fromRprBE", "fromRprLE", "fromString", "geq", "gt", "isNegative", "isOdd", "isZero", "land", "leq", "lnot", "lor", "lt", "mod", "mul", "naf", "neg", "neq", "one", "pow", "shiftLeft", "shiftRight", "shl", "shr", "square", "sub", "toArray", "toLEBuff", "toNumber", "toRprBE", "toRprLE", "toString", "zero", "init_virtual_process_polyfill", "init_buffer", "hexLen", "s", "radix", "a", "acc", "i", "aS", "n", "E", "res", "z", "rem", "b", "buff", "o", "n8", "v", "l", "ch", "init_virtual_process_polyfill", "init_buffer", "_revTable", "i", "_revSlow", "idx", "bits", "res", "a", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "quarterRound", "st", "a", "b", "c", "doubleRound", "ChaCha", "seed", "add", "mul", "i", "init_crypto", "getRandomBytes", "n", "array", "process", "i", "crypto_default", "getRandomSeed", "arr", "arrV", "seed", "threadRng", "getThreadRng", "ChaCha", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_wasmcurves", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "utils_exports", "__export", "array2buffer", "beBuff2int", "beInt2Buff", "bitReverse", "buffReverseBits", "buffer2array", "leBuff2int", "leInt2Buff", "log2", "stringifyBigInts", "stringifyFElements", "unstringifyBigInts", "unstringifyFElements", "init_virtual_process_polyfill", "init_buffer", "stringifyBigInts", "o", "fromRprLE", "res", "k", "unstringifyBigInts", "beBuff2int", "buff", "i", "offset", "buffV", "beInt2Buff", "n", "len", "r", "leBuff2int", "leInt2Buff", "bitLength", "stringifyFElements", "F", "unstringifyFElements", "_revTable", "_revSlow", "idx", "bits", "a", "bitReverse", "log2", "V", "buffReverseBits", "eSize", "tmp", "array2buffer", "arr", "sG", "buffer2array", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "BigBuffer", "size", "i", "n", "fr", "to", "len", "firstPage", "lastPage", "buff", "p", "o", "r", "l", "srcView", "offset", "buildBatchConvert", "tm", "fnName", "sIn", "sOut", "buffIn", "nPoints", "pointsPerChunk", "opPromises", "i", "n", "task", "result", "fullBuffOut", "BigBuffer", "p", "WasmField1", "tm", "prefix", "n8", "p", "shiftRight", "one", "bitLength", "sub", "shiftLeft", "r", "isOdd", "i", "buildBatchConvert", "opName", "b", "a", "toLEBuff", "e", "ra", "isNegative", "neg", "gt", "mod", "buff", "leInt2Buff", "radix", "an", "s", "fromRprLE", "toString", "rng", "v", "zero", "add", "band", "geq", "toRprLE", "getThreadRng", "offset", "buff2", "aux", "res", "buffIn", "returnArray", "sIn", "sOut", "array2buffer", "nPoints", "pointsPerChunk", "opPromises", "n", "task", "result", "fullBuffOut", "BigBuffer", "buffer2array", "init_virtual_process_polyfill", "init_buffer", "WasmField2", "tm", "prefix", "F", "opName", "b", "a", "toLEBuff", "e", "c1", "c2", "res", "radix", "s1", "s2", "rng", "getThreadRng", "buff", "b1", "b2", "init_virtual_process_polyfill", "init_buffer", "WasmField3", "tm", "prefix", "F", "opName", "b", "a", "toLEBuff", "e", "c1", "c2", "c3", "res", "radix", "s1", "s2", "s3", "rng", "getThreadRng", "buff", "b1", "b2", "b3", "init_virtual_process_polyfill", "init_buffer", "WasmCurve", "tm", "prefix", "F", "pGen", "pGb", "cofactor", "toLEBuff", "buildBatchConvert", "opName", "b", "a", "s", "e", "fnName", "arr", "offset", "res", "buff", "radix", "x", "y", "z", "aa", "x3b", "y2", "rng", "P", "greatest", "Pbuff", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "thread", "self", "instance", "memory", "e", "data", "init", "res", "runTask", "code", "wasmModule", "alloc", "length", "u32", "currentPages", "requiredPages", "allocBuffer", "buffer", "p", "setBuffer", "getBuffer", "pointer", "u8", "task", "ctx", "oldAlloc", "i", "params", "j", "u32b", "import_web_worker", "MEM_SIZE", "Deferred", "resolve", "reject", "sleep", "ms", "stringToBase64", "str", "process", "Buffer", "threadSource", "thread", "workerSource", "buildThreadManager", "wasm", "singleThread", "tm", "ThreadManager", "wasmModule", "concurrency", "os_default", "i", "Worker", "getOnMsg", "initPromises", "copyCode", "e", "data", "workerId", "transfers", "_deferred", "work", "actionData", "d", "res", "buff", "pointer", "length", "buffer", "init_virtual_process_polyfill", "init_buffer", "buildBatchApplyKey", "curve", "groupName", "G", "Fr", "tm", "buff", "first", "inc", "inType", "outType", "fnName", "fnAffine", "sGin", "sGmid", "sGout", "nPoints", "pointsPerChunk", "opPromises", "t", "i", "n", "task", "result", "outBuff", "BigBuffer", "p", "init_virtual_process_polyfill", "init_buffer", "buildPairing", "curve", "tm", "a", "b", "pA", "pB", "pRes", "res", "buffCt", "nEqs", "opPromises", "i", "task", "g1Buff", "g2Buff", "result", "pMR", "pCt", "r", "p", "pP", "pPrepP", "q", "pQ", "pPrepQ", "preP", "preQ", "pPreP", "pPreQ", "init_virtual_process_polyfill", "init_buffer", "pTSizes", "buildMultiexp", "curve", "groupName", "G", "tm", "_multiExpChunk", "buffBases", "buffScalars", "inType", "logger", "logText", "sGIn", "fnName", "nPoints", "sScalar", "bitChunkSize", "log2", "nChunks", "opPromises", "i", "task", "result", "res", "j", "_multiExp", "chunkSize", "n", "buffBasesChunk", "buffScalarsChunk", "r", "init_virtual_process_polyfill", "init_buffer", "buildFFT", "curve", "groupName", "G", "Fr", "tm", "_fft", "buff", "inverse", "inType", "outType", "logger", "loggerTxt", "MAX_BITS_THREAD", "sIn", "sMid", "sOut", "fnIn2Mid", "fnMid2Out", "fnFFTMix", "fnFFTJoin", "fnFFTFinal", "returnArray", "array2buffer", "nPoints", "bits", "log2", "buffOut", "_fftExtInv", "_fftExt", "buffer2array", "inv", "buffReverseBits", "chunks", "pointsInChunk", "nChunks", "l2Chunk", "promises", "i", "task", "buffChunk", "j", "r", "nGroups", "nChunksPerGroup", "opPromises", "k", "first", "inc", "o1", "o2", "res", "resChunk", "BigBuffer", "p", "b1", "b2", "_fftJoinExt", "res1", "buff1", "buff2", "fn", "fnName", "chunkSize", "n", "firstChunk", "result", "fullBuffOut1", "fullBuffOut2", "t0", "t1", "shiftToSmallM", "sConst", "sG", "power", "pointsPerChunk", "powerChunk", "b", "fullBuffOut", "factor", "sGout", "fnToAffine", "buildEngine", "params", "tm", "buildThreadManager", "curve", "e", "WasmField1", "WasmField2", "WasmCurve", "WasmField3", "buildBatchApplyKey", "buildMultiexp", "buildFFT", "buildPairing", "arr", "sG", "buff", "i", "n", "buildBn128", "singleThread", "plugins", "moduleBuilder", "ModuleBuilder", "buildBn128wasm", "bn128wasm", "params", "e", "curve", "buildEngine", "init_virtual_process_polyfill", "init_buffer", "import_wasmcurves", "buildBls12381", "singleThread", "plugins", "moduleBuilder", "ModuleBuilder", "buildBls12381wasm", "bls12381wasm", "params", "e", "curve", "buildEngine", "init_virtual_process_polyfill", "init_buffer", "bls12381r", "e", "bn128r", "bls12381q", "bn128q", "Scalar", "scalar_exports", "utils", "utils_exports", "init_virtual_process_polyfill", "init_buffer", "bls12381r", "Scalar", "bn128r", "bls12381q", "bn128q", "getCurveFromQ", "q", "curve", "Scalar", "bn128q", "buildBn128", "bls12381q", "buildBls12381", "getCurveFromName", "name", "normName", "normalizeName", "n", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "init_crypto", "_revTable", "i", "_revSlow", "idx", "bits", "res", "a", "log2", "V", "readG1", "fd", "curve", "toObject", "buff", "res", "readG2", "readHeader", "sections", "startReadUniqueSection", "protocolId", "endReadSection", "readHeaderGroth16", "readHeaderPlonk", "zkey", "n8q", "readBigInt", "n8r", "getCurveFromQ", "log2", "init_virtual_process_polyfill", "init_buffer", "writeBin", "fd", "witnessBin", "prime", "startWriteSection", "n8", "Scalar", "writeBigInt", "endWriteSection", "readHeader", "sections", "startReadUniqueSection", "q", "readBigInt", "nWitness", "endReadSection", "stringifyBigInts", "utils", "groth16Prove", "zkeyFileName", "witnessFileName", "logger", "fdWtns", "sectionsWtns", "readBinFile", "wtns", "readHeader", "fdZKey", "sectionsZKey", "zkey", "Scalar", "curve", "Fr", "G1", "G2", "power", "log2", "buffWitness", "readSection", "buffCoeffs", "buffA_T", "buffB_T", "buffC_T", "buildABC1", "inc", "buffA", "buffAodd", "buffAodd_T", "buffB", "buffBodd", "buffBodd_T", "buffC", "buffCodd", "buffCodd_T", "buffPodd_T", "joinABC", "proof", "buffBasesA", "buffBasesB1", "pib1", "buffBasesB2", "buffBasesC", "buffBasesH", "resH", "r", "s", "publicSignals", "i", "b", "witness", "coeffs", "n8", "sCoef", "nCoef", "outBuffA", "BigBuffer", "outBuffB", "outBuffC", "outBuf", "buffCoef", "buffCoefV", "m", "c", "coef", "nElements", "promises", "n", "task", "aChunk", "bChunk", "cChunk", "result", "outBuff", "p", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "flatArray", "a", "res", "fillArray", "i", "fnvHash", "str", "uint64_max", "hash", "shash", "n", "toArray32", "s", "size", "rem", "radix", "init_virtual_process_polyfill", "init_buffer", "scalar_exports", "__export", "abs", "add", "band", "bitLength", "bits", "bor", "bxor", "div", "e", "eq", "exp", "fromArray", "fromRprBE", "fromRprLE", "fromString", "geq", "gt", "isNegative", "isOdd", "isZero", "land", "leq", "lnot", "lor", "lt", "mod", "mul", "naf", "neg", "neq", "one", "pow", "shiftLeft", "shiftRight", "shl", "shr", "square", "sub", "toArray", "toLEBuff", "toNumber", "toRprBE", "toRprLE", "toString", "zero", "init_virtual_process_polyfill", "init_buffer", "hexLen", "s", "radix", "a", "acc", "i", "aS", "n", "E", "res", "z", "rem", "b", "buff", "o", "n8", "v", "l", "ch", "init_virtual_process_polyfill", "init_buffer", "_revTable", "i", "_revSlow", "idx", "bits", "res", "a", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "exp", "F", "base", "e", "isZero", "n", "bits", "res", "i", "init_virtual_process_polyfill", "init_buffer", "buildSqrt", "F", "eq", "mod", "alg5_tonelliShanks", "alg4_kong", "alg3_atkin", "alg2_shanks", "pm2mod4", "pow", "alg10_adj", "alg9_adj", "alg8_complex", "sub", "isOdd", "div", "c0", "c", "w", "a0", "v", "x", "b", "z", "b2k", "k", "i", "a", "a1", "n", "alfa", "x0", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_crypto", "getRandomBytes", "n", "array", "process", "i", "crypto_default", "init_virtual_process_polyfill", "init_buffer", "FFT", "G", "F", "opMulGF", "rem", "s", "nqr", "n", "i", "r", "nroots", "rootsi", "j", "p", "bits", "log2", "m", "__fft", "res", "twoinvm", "resn", "V", "PF", "pall", "offset", "step", "ndiv2", "p1", "p2", "out", "ZqField", "p", "bitLength", "e", "r", "buildSqrt", "FFT", "a", "b", "res", "nres", "base", "s", "aa", "bb", "t", "newt", "newr", "q", "exp", "nb", "n", "m", "c", "sq", "i", "j", "na", "nBytes", "getRandomBytes", "vs", "rng", "v", "buff", "o", "toRprLE", "toRprBE", "fromRprLE", "fromRprBE", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_wasmcurves", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "_revTable", "i", "_revSlow", "idx", "bits", "res", "a", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "thread", "self", "instance", "memory", "e", "data", "init", "res", "runTask", "code", "wasmModule", "alloc", "length", "u32", "currentPages", "requiredPages", "allocBuffer", "buffer", "p", "setBuffer", "getBuffer", "pointer", "u8", "task", "ctx", "oldAlloc", "i", "params", "j", "u32b", "import_web_worker", "stringToBase64", "str", "process", "Buffer", "threadSource", "thread", "workerSource", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_wasmcurves", "init_virtual_process_polyfill", "init_buffer", "bls12381r", "e", "bn128r", "bls12381q", "bn128q", "Scalar", "scalar_exports", "builder", "code", "options", "memorySize", "memory", "memoryAllocated", "err", "wasmModule", "wc", "errStr", "msgStr", "majorVersion", "minorVersion", "patchVersion", "instance", "getMessage", "msg", "shared_rw_memory_size", "arr", "j", "Scalar", "pstr", "a", "b", "c", "d", "p2str", "signal", "pVal", "cIdx", "sanityCheck", "WitnessCalculatorCircom2", "WitnessCalculatorCircom1", "message", "p", "i8", "bytes", "i", "pRawPrime", "ZqField", "input", "pSigOffset", "pFr", "k", "h", "fnvHash", "hMSB", "hLSB", "sigOffset", "fArr", "flatArray", "self", "old0", "w", "pWitness", "pWitnessBuffer", "buff", "v", "idx", "res", "fromMontgomery", "n", "minShort", "maxShort", "keys", "input_counter", "arrFr", "toArray32", "buff32", "n8", "idSection1lengthHex", "pos", "idSection2lengthHex", "unstringifyBigInts", "utils", "wtnsCalculate", "_input", "wasmFileName", "wtnsFileName", "options", "input", "fdWasm", "readExisting", "wasm", "wc", "builder", "w", "fdWtns", "createBinFile", "writeBin", "createOverride", "unstringifyBigInts", "utils", "groth16FullProve", "_input", "wasmFile", "zkeyFileName", "logger", "input", "wtns", "wtnsCalculate", "groth16Prove", "init_virtual_process_polyfill", "init_buffer", "unstringifyBigInts", "utils", "groth16Verify", "_vk_verifier", "_publicSignals", "_proof", "logger", "vk_verifier", "proof", "publicSignals", "curve", "getCurveFromName", "IC0", "IC", "w", "i", "buffP", "Scalar", "cpub", "pi_a", "pi_b", "pi_c", "vk_gamma_2", "vk_delta_2", "vk_alpha_1", "vk_beta_2", "init_virtual_process_polyfill", "init_buffer", "unstringifyBigInts", "utils", "p256", "n", "nstr", "groth16ExportSolidityCallData", "_proof", "_pub", "proof", "pub", "inputs", "i", "S", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_crypto", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "fromString", "s", "radix", "e", "zero", "e", "one", "init_virtual_process_polyfill", "init_buffer", "_revTable", "i", "_revSlow", "idx", "bits", "res", "a", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_crypto", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_wasmcurves", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "_revTable", "i", "_revSlow", "idx", "bits", "res", "a", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "thread", "self", "instance", "memory", "e", "data", "init", "res", "runTask", "code", "wasmModule", "alloc", "length", "u32", "currentPages", "requiredPages", "allocBuffer", "buffer", "p", "setBuffer", "getBuffer", "pointer", "u8", "task", "ctx", "oldAlloc", "i", "params", "j", "u32b", "import_web_worker", "stringToBase64", "str", "process", "Buffer", "threadSource", "thread", "workerSource", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_wasmcurves", "init_virtual_process_polyfill", "init_buffer", "bls12381r", "e", "bn128r", "bls12381q", "bn128q", "init_virtual_process_polyfill", "init_buffer", "bls12381r", "Scalar", "bn128r", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "unstringifyBigInts", "utils", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_crypto", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "stringifyBigInts", "utils", "init_virtual_process_polyfill", "init_buffer", "import_ejs", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_blake2b_wasm", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "import_js_sha3", "stringifyBigInts", "utils", "keccak256", "jsSha3", "unstringifyBigInts", "utils", "init_virtual_process_polyfill", "init_buffer", "import_js_sha3", "unstringifyBigInts", "utils", "keccak256", "jsSha3", "init_virtual_process_polyfill", "init_buffer", "unstringifyBigInts", "utils", "Groth16", "AuthCircuit", "AuthV2Circuit", "prove", "inputs", "provingKey", "wasm", "witnessCalculator", "witnessBuilder", "jsonString", "parsedData", "wtnsBytes", "proof", "publicSignals", "groth16_exports", "verify", "messageHash", "verificationKey", "unmarshall", "fromBigEndian", "Buffer", "ProvingMethodGroth16Auth", "methodAlg", "pubsignals", "outputs", "Id", "messageHash", "proof", "verificationKey", "verify", "inputs", "provingKey", "wasm", "prove", "provingMethodGroth16AuthInstance", "ProvingMethodAlg", "Groth16", "AuthCircuit", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "EMPTY_NODE_VALUE", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "PROOF_FLAG_LEN", "NOT_EMPTIES_LEN", "init_virtual_process_polyfill", "init_buffer", "qString", "FIELD_SIZE", "MAX_NUM_IN_FIELD", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "checkBigIntInField", "bigNum", "FIELD_SIZE", "bytesEqual", "b1", "b2", "areEqual", "ele", "idx", "swapEndianness", "bytes", "tempBuffer", "tempBytes", "_", "bytes2BinaryString", "acc", "i", "hextable", "bytes2Hex", "u", "arr", "j", "v", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "bigIntToUINT8Array", "bigNum", "n256", "bytes", "i", "newHashFromBigInt", "bigNum", "checkBigIntInField", "bytes", "bigIntToUINT8Array", "hash", "Hash", "newHashFromString", "decimalString", "bigNum", "checkBigIntInField", "newHashFromBigInt", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "Hash", "_bytes", "bytes", "swapEndianness", "bytes2Hex", "hash", "bytesEqual", "bytes2BinaryString", "ZERO_HASH", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "init_virtual_process_polyfill", "init_buffer", "AuthV2Groth16Alg", "ProvingMethodAlg", "Groth16", "AuthV2Circuit", "ProvingMethodGroth16AuthV2", "methodAlg", "messageHash", "proof", "verificationKey", "verify", "inputs", "provingKey", "wasm", "prove", "pubSignals", "Id", "newHashFromString", "provingMethodGroth16AuthV2Instance", "registerProvingMethod", "provingMethodGroth16AuthInstance", "provingMethodGroth16AuthV2Instance", "proving", "getProvingMethod"]
}
